//
//  ToolProtocolConformanceTests.swift
//  FoundationChatCoreTests
//
//  Tests to verify Tool protocol conformance
//

import XCTest
@testable import FoundationChatCore
import FoundationModels

@available(macOS 26.0, iOS 26.0, *)
final class ToolProtocolConformanceTests: XCTestCase {
    
    // MARK: - DuckDuckGoFoundationTool Conformance
    
    func testDuckDuckGoFoundationToolConformsToTool() {
        let tool = DuckDuckGoFoundationTool()
        
        // Verify required properties exist
        XCTAssertFalse(tool.name.isEmpty, "Tool must have a name")
        XCTAssertFalse(tool.description.isEmpty, "Tool must have a description")
        
        // Verify parameters property exists (should be auto-generated by @Generable)
        // Access it to ensure it compiles and exists
        let parameters = tool.parameters
        XCTAssertNotNil(parameters, "Tool must have parameters property")
        
        print("✓ DuckDuckGoFoundationTool has all required properties")
        print("  Name: \(tool.name)")
        print("  Description length: \(tool.description.count)")
        print("  Parameters type: \(type(of: parameters))")
    }
    
    func testDuckDuckGoFoundationToolCanBeUsedWithLanguageModelSession() {
        // Verify the tool can be passed to LanguageModelSession
        let tool = DuckDuckGoFoundationTool()
        let session = LanguageModelSession(tools: [tool])
        
        // If this compiles and runs, the tool conforms correctly
        XCTAssertNotNil(session, "Should be able to create session with tool")
        
        print("✓ DuckDuckGoFoundationTool can be used with LanguageModelSession")
    }
    
    func testDuckDuckGoFoundationToolHasCorrectTypes() {
        // Verify typealiases by using the type directly
        let outputType = DuckDuckGoFoundationTool.Output.self
        XCTAssertTrue(outputType == String.self, "Output should be String")
        
        // Verify Arguments struct exists and has @Generable
        let args = DuckDuckGoFoundationTool.Arguments(query: "test")
        XCTAssertEqual(args.query, "test", "Arguments should have query property")
        
        print("✓ DuckDuckGoFoundationTool has correct types")
        print("  Output type: \(outputType)")
        print("  Arguments type: \(type(of: args))")
    }
    
    // MARK: - TrackedTool Conformance
    
    func testTrackedToolConformsToTool() {
        let originalTool = DuckDuckGoFoundationTool()
        let tracker = ToolCallTracker()
        let sessionId = UUID().uuidString
        
        let trackedTool = TrackedTool(wrapping: originalTool, sessionId: sessionId, tracker: tracker)
        
        // Verify required properties exist
        XCTAssertFalse(trackedTool.name.isEmpty, "TrackedTool must have a name")
        XCTAssertFalse(trackedTool.description.isEmpty, "TrackedTool must have a description")
        
        // Verify parameters property exists
        let parameters = trackedTool.parameters
        XCTAssertNotNil(parameters, "TrackedTool must have parameters property")
        
        // Verify it matches the wrapped tool's parameters
        XCTAssertEqual(trackedTool.name, originalTool.name, "TrackedTool should delegate name")
        XCTAssertEqual(trackedTool.description, originalTool.description, "TrackedTool should delegate description")
        
        print("✓ TrackedTool has all required properties")
        print("  Name: \(trackedTool.name)")
        print("  Description length: \(trackedTool.description.count)")
    }
    
    func testTrackedToolCanBeUsedWithLanguageModelSession() {
        // Verify the tracked tool can be passed to LanguageModelSession
        let originalTool = DuckDuckGoFoundationTool()
        let tracker = ToolCallTracker()
        let sessionId = UUID().uuidString
        
        let trackedTool = TrackedTool(wrapping: originalTool, sessionId: sessionId, tracker: tracker)
        let session = LanguageModelSession(tools: [trackedTool])
        
        // If this compiles and runs, the tool conforms correctly
        XCTAssertNotNil(session, "Should be able to create session with tracked tool")
        
        print("✓ TrackedTool can be used with LanguageModelSession")
    }
    
    func testTrackedToolDelegatesCorrectly() {
        let originalTool = DuckDuckGoFoundationTool()
        let tracker = ToolCallTracker()
        let sessionId = UUID().uuidString
        
        let trackedTool = TrackedTool(wrapping: originalTool, sessionId: sessionId, tracker: tracker)
        
        // Verify typealiases match by checking they're the same type
        let trackedOutputType = type(of: trackedTool).Output.self
        let originalOutputType = type(of: originalTool).Output.self
        XCTAssertTrue(trackedOutputType == originalOutputType, "Output types should match")
        
        // Verify Arguments by creating instances
        let trackedArgs = TrackedTool<DuckDuckGoFoundationTool>.Arguments(query: "test")
        let originalArgs = DuckDuckGoFoundationTool.Arguments(query: "test")
        XCTAssertEqual(trackedArgs.query, originalArgs.query, "Arguments should have same structure")
        
        print("✓ TrackedTool delegates types correctly")
    }
    
    // MARK: - Protocol Conformance Verification
    
    func testBothToolsAreSendable() {
        // Verify both tools conform to Sendable
        let ddgTool = DuckDuckGoFoundationTool()
        let tracker = ToolCallTracker()
        let trackedTool = TrackedTool(wrapping: ddgTool, sessionId: UUID().uuidString, tracker: tracker)
        
        // This test passes if the types compile with Sendable conformance
        func checkSendable<T: Sendable>(_ value: T) -> Bool {
            return true
        }
        
        XCTAssertTrue(checkSendable(ddgTool), "DuckDuckGoFoundationTool should be Sendable")
        XCTAssertTrue(checkSendable(trackedTool), "TrackedTool should be Sendable")
        
        print("✓ Both tools conform to Sendable")
    }
    
    func testToolProtocolRequirements() {
        // Comprehensive test of all Tool protocol requirements
        let tool = DuckDuckGoFoundationTool()
        
        // 1. name: String - verify it exists and is non-empty
        XCTAssertFalse(tool.name.isEmpty, "name must be a non-empty String")
        
        // 2. description: String - verify it exists and is non-empty
        XCTAssertFalse(tool.description.isEmpty, "description must be a non-empty String")
        
        // 3. parameters: GenerationSchema - verify it exists
        let parameters = tool.parameters
        let _: GenerationSchema = parameters // Type check that it's GenerationSchema
        
        // 4. Output associated type - verify by using the type directly
        let outputType = DuckDuckGoFoundationTool.Output.self
        XCTAssertTrue(outputType == String.self, "Output should be String")
        
        // 5. Arguments associated type - verify by creating an instance using the type
        let args = DuckDuckGoFoundationTool.Arguments(query: "test")
        XCTAssertEqual(args.query, "test", "Arguments should work correctly")
        
        // 6. call method exists - verify by checking we can call it (tested in integration tests)
        
        print("✓ All Tool protocol requirements satisfied")
        print("  Name: \(tool.name)")
        print("  Description: \(tool.description.prefix(50))...")
        print("  Parameters type: \(type(of: parameters))")
        print("  Output type: \(outputType)")
    }
}

