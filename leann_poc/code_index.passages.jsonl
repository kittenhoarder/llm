{"id": "0", "text": "import SwiftUI\nimport CoreData\n\n@main\nstruct readApp: App {\n    let persistenceController = PersistenceController.shared\n    \n    @Environment(\\.scenePhase) private var scenePhase\n    \n    var body: some Scene {\n        WindowGroup {\n            LibraryView()\n                .environment(\\.managedObjectContext, persistenceController.container.viewContext)\n                .ignoresSafeArea(.all, edges: .all)\n                .onChange(of: scenePhase) { oldPhase, newPhase in\n                    if newPhase == .background {\n                        persistenceController.save()\n                    }\n                }\n        }\n    }\n}\n\n// MARK: - Core Data Stack\nclass PersistenceController {\n    static let shared = PersistenceController()\n    \n    static var preview: PersistenceController = {\n        let controller = PersistenceController(inMemory: true)\n        return controller\n    }()\n    \n    let container: NSPersistentContainer\n    \n    init(inMemory: Bool = false) {\n        container = NSPersistentContainer(name: \"Read\")\n        \n        if inMemory {\n            container.persistentStoreDescriptions.first?.url = URL(fileURLWithPath: \"/dev/null\")\n        }\n        \n        container.loadPersistentStores { description, error in\n            if let error = error {\n                fatalError(\"Core Data store failed to load: \\(error.localizedDescription)\")\n            }\n        }\n        \n        container.viewContext.automaticallyMergesChangesFromParent = true\n    }\n    \n    func save() {\n        let context = container.viewContext\n        \n        if context.hasChanges {\n            do {\n                try context.save()\n            } catch {\n                let nsError = error as NSError\n                fatalError(\"Unresolved Core Data error \\(nsError), \\(nsError.userInfo)\")\n            }\n        }\n    }\n}\n", "metadata": {"file_path": "readApp.swift", "file_extension": ".swift", "file_name": "readApp.swift", "file_size": 1836, "last_modified": 1766184032.1965783}}
{"id": "1", "text": "import SwiftUI\nimport CoreData\nimport Combine\n\n@MainActor\nclass LibraryViewModel: ObservableObject {\n    enum SortOption: String, CaseIterable {\n        case lastOpened = \"Last Opened\"\n        case title = \"Title\"\n        case author = \"Author\"\n    }\n    \n    @Published var books: [BookItem] = []\n    @Published var searchText: String = \"\" // Temporary input, doesn't trigger search\n    @Published var activeSearchQuery: String = \"\" // Actual search query used for filtering\n    @Published var isSearchActive: Bool = false // Controls search field visibility\n    @Published var selectedBookIds: Set<UUID> = [] // For multi-select deletion mode\n    @Published var isDeletionMode: Bool = false // Tracks if in deletion mode\n    @Published var sortOption: SortOption = .lastOpened {\n        didSet {\n            loadBooks()\n        }\n    }\n    \n    private let bookStorage = BookStorage.shared\n    private var context: NSManagedObjectContext?\n    \n    var filteredBooks: [BookItem] {\n        // Books are already filtered and sorted by loadBooks\n        return books\n    }\n    \n    init() {\n        // loadBooks will be called after context is set\n    }\n    \n    func setContext(_ context: NSManagedObjectContext) {\n        self.context = context\n        bookStorage.setContext(context)\n        loadBooks()\n    }\n    \n    func loadBooks() {\n        Task {\n            do {\n                let fetchedBooks = try await bookStorage.fetchBooks(sortBy: sortOption, searchQuery: activeSearchQuery.isEmpty ? nil : activeSearchQuery)\n                books = fetchedBooks\n            } catch {\n                print(\"Error loading books: \\(error)\")\n            }\n        }\n    }\n    \n    func performSearch() {\n        activeSearchQuery = searchText\n        loadBooks()\n    }\n    \n    func clearSearch() {\n        searchText = \"\"\n        activeSearchQuery = \"\"\n        isSearchActive = false\n        loadBooks()\n    }\n    \n    func deleteBooks(ids: [UUID]) {\n        Task {\n            do {\n                for id in ids {\n                    try await bookStorage.deleteBook(bookId: id)\n                }\n                // Clear selection and exit deletion mode\n                selectedBookIds.removeAll()\n                isDeletionMode = false\n                // Refresh the list\n                loadBooks()\n            } catch {\n                print(\"Error deleting books: \\(error)\")\n                importError = \"Failed to delete books: \\(error.localizedDescription)\"\n            }\n        }\n    }\n    \n    @Published var importError: String?\n    \n    func importBook(from url: URL) {\n        Task {\n            do {\n                let bookItem = try await bookStorage.importBook(at: url)\n                \n                // Parse the book to extract metadata\n                let parser: BookParser = url.pathExtension.lowercased() == \"epub\" ? EPUBParser() : TXTParser()\n                \n                do {\n                    let document = try await parser.parse(url: URL(fileURLWithPath: bookItem.filePath))\n                    \n                    // Update metadata\n                    try await bookStorage.updateBookMetadata(\n                        bookId: bookItem.id,\n                        title: document.title,\n                        author: document.author\n                    )\n                } catch {\n                    print(\"Failed to parse book metadata: \\(error)\")\n                    // Continue anyway - book is imported with basic metadata\n                }\n                \n                loadBooks()\n                importError = nil\n            } catch {\n                let errorMessage = \"Failed to import book: \\(error.localizedDescription)\"\n                print(\"Error importing book: \\(errorMessage)\")\n                importError = errorMessage\n            }\n        }\n    }\n}\n\n", "metadata": {"file_path": "ViewModels/LibraryViewModel.swift", "file_extension": ".swift", "file_name": "LibraryViewModel.swift", "file_size": 3816, "last_modified": 1766184032.1966016}}
{"id": "2", "text": "import SwiftUI\nimport Combine\nimport Foundation\n\n@MainActor\nclass ReaderViewModel: ObservableObject {\n    @Published var document: DocumentModel?\n    @Published var currentReadingIndex: Int = 0\n    @Published var bookmarks: [Bookmark] = []\n    @Published var isLoading: Bool = false\n    @Published var errorMessage: String?\n    \n    let ttsController = TTSController()\n    private let bookStorage = BookStorage.shared\n    private var bookId: UUID?\n    private var persistenceTimer: Timer?\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        // Listen to TTS index updates\n        ttsController.$currentSpokenIndex\n            .sink { [weak self] index in\n                self?.currentReadingIndex = index\n            }\n            .store(in: &cancellables)\n        \n        // Persist position when TTS stops\n        ttsController.$isSpeaking\n            .sink { [weak self] isSpeaking in\n                if !isSpeaking {\n                    Task { @MainActor [weak self] in\n                        try? await self?.persistReadingPosition()\n                    }\n                }\n            }\n            .store(in: &cancellables)\n        \n        // Start periodic persistence timer\n        startPersistenceTimer()\n    }\n    \n    deinit {\n        persistenceTimer?.invalidate()\n    }\n    \n    func loadBook(_ book: BookItem) {\n        bookId = book.id\n        isLoading = true\n        errorMessage = nil\n        \n        Task {\n            do {\n                // Load bookmarks\n                bookmarks = try await bookStorage.getBookmarks(bookId: book.id)\n                \n                // Parse book file on background queue\n                var fileURL = URL(fileURLWithPath: book.filePath)\n                \n                // Debug: Log the file path we're trying to access\n                print(\"üìñ Loading book: \\(book.title)\")\n                print(\"üìÅ File path: \\(book.filePath)\")\n                print(\"üìÅ File URL: \\(fileURL)\")\n                \n                // Check if file exists at stored path\n                if !FileManager.default.fileExists(atPath: fileURL.path) {\n                    // File not found at stored path - try to find it in current Books directory\n                    // This handles the case where app was reinstalled and Documents directory changed\n                    let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n                    let booksURL = documentsURL.appendingPathComponent(\"Books\", isDirectory: true)\n                    let fileName = fileURL.lastPathComponent\n                    let newFilePath = booksURL.appendingPathComponent(fileName)\n                    \n                    print(\"‚ùå File not found at stored path: \\(fileURL.path)\")\n                    print(\"üîç Trying to find file by name: \\(fileName)\")\n                    print(\"üìÇ Current Books directory: \\(booksURL.path)\")\n                    \n                    if FileManager.default.fileExists(atPath: newFilePath.path) {\n                        // File found in current Books directory - update the stored path\n                        print(\"‚úÖ File found in current Books directory, updating path...\")\n                        fileURL = newFilePath\n                        \n                        // Update the filePath in Core Data\n                        try await bookStorage.updateBookFilePath(bookId: book.id, newFilePath: newFilePath.path)\n                    } else {\n                        // File not found anywhere\n                        print(\"‚ùå File not found in current Books directory either\")\n                        if let files = try? FileManager.default.contentsOfDirectory(atPath: booksURL.path) {\n                            print(\"üìö Files in Books directory: \\(files)\")\n                        }\n                        \n                        errorMessage = \"Book file not found. The file may have been deleted. Please re-import the book.\"\n                        isLoading = false\n                        return\n                    }\n                }\n                \n                print(\"‚úÖ File exists, proceeding to parse...\")\n                \n                let parser: BookParser = fileURL.pathExtension.lowercased() == \"epub\" ? EPUBParser() : TXTParser()\n                \n                // Parse in background to keep UI responsive\n                let parsedDocument = try await Task.detached(priority: .userInitiated) {\n                    try await parser.parse(url: fileURL)\n                }.value\n                \n                document = parsedDocument\n                \n                // Update metadata in storage if available\n                if let doc = document {\n                    try await bookStorage.updateBookMetadata(\n                        bookId: book.id,\n                        title: doc.title,\n                        author: doc.author\n                    )\n                }\n                \n                // Restore reading position\n                currentReadingIndex = book.lastPosition\n                \n                // Ensure index is valid\n                if let doc = document, currentReadingIndex >= doc.totalSentences {\n                    currentReadingIndex = 0\n                }\n                \n                isLoading = false\n            } catch {\n                errorMessage = \"Failed to load book: \\(error.localizedDescription)\"\n                isLoading = false\n            }\n        }\n    }\n    \n    func computeTTSStartIndex(from viewportTop: CGFloat, viewportHeight: CGFloat) -> Int {\n        guard let doc = document else { return currentReadingIndex }\n        \n        // Find sentence closest to viewport top\n        // This is a simplified calculation - in a real implementation,\n        // you'd map viewport coordinates to sentence positions\n        let estimatedIndex = Int(viewportTop / 50) // Rough estimate\n        return min(max(estimatedIndex, 0), doc.totalSentences - 1)\n    }\n    \n    func startTTS(from viewportTop: CGFloat, viewportHeight: CGFloat) {\n        guard let doc = document else { return }\n        \n        // For MVP, use current reading index as start position\n        // TODO: Implement proper viewport-to-index mapping\n        let startIndex = max(0, min(currentReadingIndex, doc.totalSentences - 1))\n        \n        do {\n            try ttsController.startSpeaking(from: startIndex, document: doc)\n        } catch let error as TTSError {\n            errorMessage = error.localizedDescription\n        } catch {\n            errorMessage = \"Failed to start text-to-speech: \\(error.localizedDescription)\"\n        }\n    }\n    \n    func stopTTS() {\n        ttsController.stopSpeaking()\n        Task {\n            try? await persistReadingPosition()\n        }\n    }\n    \n    func addBookmark() {\n        guard let bookId = bookId, let doc = document else { return }\n        \n        let position = currentReadingIndex\n        let snippet = doc.snippet(around: position)\n        let label = \"Bookmark \\(bookmarks.count + 1)\"\n        \n        Task {\n            do {\n                let bookmark = try await bookStorage.addBookmark(\n                    bookId: bookId,\n                    position: position,\n                    label: label,\n                    snippet: snippet\n                )\n                bookmarks.append(bookmark)\n            } catch {\n                print(\"Failed to add bookmark: \\(error)\")\n            }\n        }\n    }\n    \n    func deleteBookmark(_ bookmark: Bookmark) {\n        Task {\n            do {\n                try await bookStorage.deleteBookmark(bookmarkId: bookmark.id)\n                bookmarks.removeAll { $0.id == bookmark.id }\n            } catch {\n                print(\"Failed to delete bookmark: \\(error)\")\n            }\n        }\n    }\n    \n    func jumpToBookmark(_ bookmark: Bookmark) {\n        currentReadingIndex = bookmark.position\n        stopTTS()\n    }\n    \n    func updateReadingIndex(_ index: Int) {\n        currentReadingIndex = index\n    }\n    \n    func resetReaderPosition() {\n        // Reset reading position to current index (which should be at reading start indicator)\n        // This ensures TTS starts from the current reading start position, not the last saved position\n        Task {\n            // Persist the current position as the new starting point\n            try? await persistReadingPosition()\n            // Stop TTS if it's running\n            stopTTS()\n        }\n    }\n    \n    func persistReadingPosition() async throws {\n        guard let bookId = bookId else { return }\n        try await bookStorage.updateReadingPosition(bookId: bookId, position: currentReadingIndex)\n    }\n    \n    private func startPersistenceTimer() {\n        persistenceTimer = Timer.scheduledTimer(withTimeInterval: 3.0, repeats: true) { [weak self] _ in\n            Task { @MainActor in\n                try? await self?.persistReadingPosition()\n            }\n        }\n        if let timer = persistenceTimer {\n            RunLoop.current.add(timer, forMode: .common)\n        }\n    }\n}\n\n", "metadata": {"file_path": "ViewModels/ReaderViewModel.swift", "file_extension": ".swift", "file_name": "ReaderViewModel.swift", "file_size": 9085, "last_modified": 1766184032.1966133}}
{"id": "3", "text": "{\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n", "metadata": {"file_path": "Assets.xcassets/Contents.json", "file_extension": ".json", "file_name": "Contents.json", "file_size": 63, "last_modified": 1765400124.3883357}}
{"id": "4", "text": "import Foundation\n\n// MARK: - Document Model\nstruct DocumentModel {\n    let title: String\n    let author: String?\n    let chapters: [Chapter]\n    var tableOfContents: [TOCEntry] = []\n    \n    var totalSentences: Int {\n        chapters.reduce(0) { $0 + $1.totalSentences }\n    }\n    \n    func sentence(at globalIndex: Int) -> Sentence? {\n        var currentIndex = 0\n        for chapter in chapters {\n            if globalIndex < currentIndex + chapter.totalSentences {\n                return chapter.sentence(at: globalIndex - currentIndex)\n            }\n            currentIndex += chapter.totalSentences\n        }\n        return nil\n    }\n    \n    func chapterIndex(for globalIndex: Int) -> Int? {\n        var currentIndex = 0\n        for (index, chapter) in chapters.enumerated() {\n            if globalIndex < currentIndex + chapter.totalSentences {\n                return index\n            }\n            currentIndex += chapter.totalSentences\n        }\n        return nil\n    }\n    \n    /// Returns the global sentence index offset for a given chapter\n    func globalIndexOffset(for chapterIndex: Int) -> Int {\n        guard chapterIndex > 0 && chapterIndex < chapters.count else { return 0 }\n        return chapters[0..<chapterIndex].reduce(0) { $0 + $1.totalSentences }\n    }\n    \n    /// Returns the first sentence global index for a chapter\n    func firstSentenceIndex(for chapterIndex: Int) -> Int? {\n        guard chapterIndex >= 0 && chapterIndex < chapters.count else { return nil }\n        return globalIndexOffset(for: chapterIndex)\n    }\n}\n\n// MARK: - Chapter\nstruct Chapter {\n    let title: String?\n    let paragraphs: [Paragraph]\n    \n    var totalSentences: Int {\n        paragraphs.reduce(0) { $0 + $1.sentences.count }\n    }\n    \n    func sentence(at localIndex: Int) -> Sentence? {\n        var currentIndex = 0\n        for paragraph in paragraphs {\n            if localIndex < currentIndex + paragraph.sentences.count {\n                return paragraph.sentences[localIndex - currentIndex]\n            }\n            currentIndex += paragraph.sentences.count\n        }\n        return nil\n    }\n}\n\n// MARK: - Paragraph\nstruct Paragraph {\n    let sentences: [Sentence]\n    let isBlockquote: Bool\n    let isListItem: Bool\n    let listItemLevel: Int\n    \n    init(sentences: [Sentence], isBlockquote: Bool = false, isListItem: Bool = false, listItemLevel: Int = 0) {\n        self.sentences = sentences\n        self.isBlockquote = isBlockquote\n        self.isListItem = isListItem\n        self.listItemLevel = listItemLevel\n    }\n}\n\n// MARK: - Sentence\nstruct Sentence {\n    let text: String\n    let globalIndex: Int\n    let chapterIndex: Int\n    let paragraphIndex: Int\n    let sentenceIndex: Int\n    let formattedSpans: [FormattedSpan]\n    \n    init(text: String, globalIndex: Int, chapterIndex: Int, paragraphIndex: Int, sentenceIndex: Int, formattedSpans: [FormattedSpan] = []) {\n        self.text = text\n        self.globalIndex = globalIndex\n        self.chapterIndex = chapterIndex\n        self.paragraphIndex = paragraphIndex\n        self.sentenceIndex = sentenceIndex\n        // If no formatted spans provided, create a single plain span\n        self.formattedSpans = formattedSpans.isEmpty ? [FormattedSpan(text: text, style: .none)] : formattedSpans\n    }\n}\n\n// MARK: - Search Result\nstruct SearchResult: Identifiable {\n    let id = UUID()\n    let globalIndex: Int\n    let chapterIndex: Int\n    let chapterTitle: String\n    let matchedText: String\n    let contextSnippet: String\n    let matchRange: Range<String.Index>\n}\n\n// MARK: - DocumentModel Extensions\nextension DocumentModel {\n    /// Get text snippet around a given global index for display\n    func snippet(around index: Int, length: Int = 100) -> String {\n        guard let _ = sentence(at: index) else {\n            return \"\"\n        }\n        \n        // Get surrounding sentences\n        let startIndex = max(0, index - 1)\n        let endIndex = min(totalSentences - 1, index + 1)\n        \n        var snippet = \"\"\n        for i in startIndex...endIndex {\n            if let s = sentence(at: i) {\n                snippet += s.text + \" \"\n            }\n        }\n        \n        if snippet.count > length {\n            let start = snippet.index(snippet.startIndex, offsetBy: 0)\n            let end = snippet.index(start, offsetBy: length)\n            snippet = String(snippet[start..<end]) + \"...\"\n        }\n        \n        return snippet.trimmingCharacters(in: .whitespaces)\n    }\n    \n    /// Get chapter title for a given global index\n    func chapterTitle(for index: Int) -> String {\n        guard let chapterIdx = chapterIndex(for: index),\n              chapterIdx < chapters.count else {\n            return \"Unknown Chapter\"\n        }\n        return chapters[chapterIdx].title ?? \"Chapter \\(chapterIdx + 1)\"\n    }\n    \n    /// Search the document for a query string (case-insensitive)\n    /// Returns an array of SearchResult with matching sentences and context\n    func search(query: String) -> [SearchResult] {\n        guard !query.isEmpty else { return [] }\n        \n        let lowercaseQuery = query.lowercased()\n        var results: [SearchResult] = []\n        \n        for (chapterIdx, chapter) in chapters.enumerated() {\n            let chapterTitleStr = chapter.title ?? \"Chapter \\(chapterIdx + 1)\"\n            \n            for paragraph in chapter.paragraphs {\n                for sentence in paragraph.sentences {\n                    let lowercaseText = sentence.text.lowercased()\n                    \n                    // Check if query exists in sentence\n                    if let range = lowercaseText.range(of: lowercaseQuery) {\n                        // Build context snippet (surrounding sentences)\n                        let contextStart = max(0, sentence.globalIndex - 1)\n                        let contextEnd = min(totalSentences - 1, sentence.globalIndex + 1)\n                        \n                        var context = \"\"\n                        for i in contextStart...contextEnd {\n                            if let s = self.sentence(at: i) {\n                                if i == sentence.globalIndex {\n                                    context += s.text\n                                } else {\n                                    context += s.text\n                                }\n                                if i < contextEnd {\n                                    context += \" \"\n                                }\n                            }\n                        }\n                        \n                        // Truncate context if too long\n                        if context.count > 150 {\n                            // Find the match position in context and center around it\n                            if let matchInContext = context.lowercased().range(of: lowercaseQuery) {\n                                let matchStart = context.distance(from: context.startIndex, to: matchInContext.lowerBound)\n                                let startOffset = max(0, matchStart - 50)\n                                let endOffset = min(context.count, matchStart + query.count + 50)\n                                \n                                let start = context.index(context.startIndex, offsetBy: startOffset)\n                                let end = context.index(context.startIndex, offsetBy: endOffset)\n                                \n                                var truncated = String(context[start..<end])\n                                if startOffset > 0 {\n                                    truncated = \"...\" + truncated\n                                }\n                                if endOffset < context.count {\n                                    truncated = truncated + \"...\"\n                                }\n                                context = truncated\n                            }\n                        }\n                        \n                        // Get the match range in the original text for highlighting\n                        let originalRange = sentence.text.range(\n                            of: query,\n                            options: .caseInsensitive\n                        ) ?? sentence.text.startIndex..<sentence.text.startIndex\n                        \n                        results.append(SearchResult(\n                            globalIndex: sentence.globalIndex,\n                            chapterIndex: chapterIdx,\n                            chapterTitle: chapterTitleStr,\n                            matchedText: sentence.text,\n                            contextSnippet: context,\n                            matchRange: originalRange\n                        ))\n                    }\n                }\n            }\n        }\n        \n        return results\n    }\n}\n", "metadata": {"file_path": "Models/DocumentModel.swift", "file_extension": ".swift", "file_name": "DocumentModel.swift", "file_size": 8786, "last_modified": 1766184032.1967313}}
{"id": "5", "text": "import SwiftUI\nimport Combine\n\n/// Reading mode options for the reader view\nenum ReadingMode: String, CaseIterable {\n    case scroll = \"scroll\"\n    case pages = \"pages\"\n    \n    var displayName: String {\n        switch self {\n        case .scroll: return \"Scroll\"\n        case .pages: return \"Pages\"\n        }\n    }\n    \n    var icon: String {\n        switch self {\n        case .scroll: return \"arrow.up.arrow.down\"\n        case .pages: return \"book.pages\"\n        }\n    }\n}\n\n/// Centralized reading preferences with UserDefaults persistence\nclass ReadingPreferences: ObservableObject {\n    static let shared = ReadingPreferences()\n    \n    /// Current reading mode (scroll or pages)\n    @Published var readingMode: ReadingMode {\n        didSet {\n            UserDefaults.standard.set(readingMode.rawValue, forKey: \"readingMode\")\n        }\n    }\n    \n    /// Default font size for reader\n    @Published var fontSize: Double {\n        didSet {\n            UserDefaults.standard.set(fontSize, forKey: \"readerFontSize\")\n        }\n    }\n    \n    private init() {\n        // Load from UserDefaults\n        if let modeString = UserDefaults.standard.string(forKey: \"readingMode\"),\n           let mode = ReadingMode(rawValue: modeString) {\n            self.readingMode = mode\n        } else {\n            self.readingMode = .scroll\n        }\n        \n        let storedFontSize = UserDefaults.standard.double(forKey: \"readerFontSize\")\n        self.fontSize = storedFontSize > 0 ? storedFontSize : 17.0\n    }\n}\n", "metadata": {"file_path": "Models/ReadingPreferences.swift", "file_extension": ".swift", "file_name": "ReadingPreferences.swift", "file_size": 1503, "last_modified": 1766184032.1968129}}
{"id": "6", "text": "import Foundation\n\nstruct Bookmark: Identifiable {\n    let id: UUID\n    let bookId: UUID\n    let position: Int\n    let label: String\n    let snippet: String\n    let createdAt: Date\n}\n\n\n", "metadata": {"file_path": "Models/Bookmark.swift", "file_extension": ".swift", "file_name": "Bookmark.swift", "file_size": 185, "last_modified": 1765400658.5656161}}
{"id": "7", "text": "import Foundation\n\nstruct BookItem: Identifiable, Hashable {\n    let id: UUID\n    let title: String\n    let author: String?\n    let filePath: String\n    let lastOpened: Date?\n    let lastPosition: Int\n    \n    func hash(into hasher: inout Hasher) {\n        hasher.combine(id)\n    }\n    \n    static func == (lhs: BookItem, rhs: BookItem) -> Bool {\n        lhs.id == rhs.id\n    }\n}\n\n", "metadata": {"file_path": "Models/BookItem.swift", "file_extension": ".swift", "file_name": "BookItem.swift", "file_size": 381, "last_modified": 1765400658.5659318}}
{"id": "8", "text": "import Foundation\nimport AVFoundation\n\nclass TTSDelegate: NSObject, AVSpeechSynthesizerDelegate {\n    var onDidFinish: (() -> Void)?\n    var onDidStart: ((Int) -> Void)?\n    var onWillSpeak: ((Int) -> Void)?\n    \n    private var currentIndex: Int = 0\n    \n    func setCurrentIndex(_ index: Int) {\n        currentIndex = index\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didStart utterance: AVSpeechUtterance) {\n        onDidStart?(currentIndex)\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance) {\n        // This is called as speech progresses, but we track by sentence completion instead\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {\n        // Update index when sentence finishes speaking\n        onWillSpeak?(currentIndex)\n        // Then notify that we're ready for next sentence\n        onDidFinish?()\n    }\n    \n    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didCancel utterance: AVSpeechUtterance) {\n        onDidFinish?()\n    }\n}\n\n\n", "metadata": {"file_path": "Core/TTS/TTSDelegate.swift", "file_extension": ".swift", "file_name": "TTSDelegate.swift", "file_size": 1164, "last_modified": 1766184032.1965425}}
{"id": "9", "text": "import Foundation\nimport AVFoundation\nimport Combine\n\nenum TTSError: LocalizedError {\n    case premiumVoiceUnavailable\n    case noVoiceForLanguage(String)\n    \n    var errorDescription: String? {\n        switch self {\n        case .premiumVoiceUnavailable:\n            return \"High-quality voice is not available. Please download a premium or enhanced voice in Settings > Accessibility > Spoken Content > Voices. Note: On iOS 26.1, premium voices may be labeled as 'enhanced'.\"\n        case .noVoiceForLanguage(let language):\n            return \"No high-quality voice available for language: \\(language). Please download a premium or enhanced voice in Settings > Accessibility > Spoken Content > Voices.\"\n        }\n    }\n}\n\n@MainActor\nclass TTSController: ObservableObject {\n    @Published var isSpeaking: Bool = false\n    @Published var currentSpokenIndex: Int = 0\n    @Published var error: TTSError?\n    @Published var selectedVoiceIdentifier: String? {\n        didSet {\n            // Save to UserDefaults when changed\n            if let identifier = selectedVoiceIdentifier {\n                UserDefaults.standard.set(identifier, forKey: \"selectedVoiceIdentifier\")\n            } else {\n                UserDefaults.standard.removeObject(forKey: \"selectedVoiceIdentifier\")\n            }\n        }\n    }\n    \n    private let synthesizer = AVSpeechSynthesizer()\n    private let delegate = TTSDelegate()\n    private var document: DocumentModel?\n    private var utteranceQueue: [AVSpeechUtterance] = []\n    private var currentSentenceIndex: Int = 0\n    private var sentences: [Sentence] = []\n    private var cancellables = Set<AnyCancellable>()\n    \n    init() {\n        // Load saved voice preference\n        selectedVoiceIdentifier = UserDefaults.standard.string(forKey: \"selectedVoiceIdentifier\")\n        \n        synthesizer.delegate = delegate\n    \n        delegate.onDidStart = { [weak self] index in\n            Task { @MainActor [weak self] in\n                self?.currentSpokenIndex = index\n            }\n        }\n        \n        delegate.onWillSpeak = { [weak self] index in\n            Task { @MainActor [weak self] in\n                self?.currentSpokenIndex = index\n            }\n        }\n        \n        delegate.onDidFinish = { [weak self] in\n            Task { @MainActor [weak self] in\n                self?.handleUtteranceFinished()\n            }\n        }\n    }\n    \n    func getSelectedVoice() -> AVSpeechSynthesisVoice? {\n        if let identifier = selectedVoiceIdentifier,\n           let voice = AVSpeechSynthesisVoice(identifier: identifier) {\n            return voice\n        }\n        return nil\n    }\n    \n    func startSpeaking(from startIndex: Int, document: DocumentModel) throws {\n        guard !isSpeaking else { return }\n        \n        // Clear any previous errors\n        error = nil\n        \n        // Get premium voice - prefer language match, but accept any premium voice\n        let currentLocale = Locale.current\n        let languageCode = currentLocale.language.languageCode?.identifier ?? \"en\"\n        let regionCode = currentLocale.region?.identifier ?? \"US\"\n        let fullLanguage = \"\\(languageCode)-\\(regionCode)\"\n        \n        // First, check if user has selected a voice\n        var selectedVoice: AVSpeechSynthesisVoice?\n        if let identifier = selectedVoiceIdentifier {\n            selectedVoice = AVSpeechSynthesisVoice(identifier: identifier)\n            if selectedVoice != nil {\n                print(\"‚úÖ Using user-selected voice: \\(selectedVoice!.name) [\\(identifier)]\")\n            } else {\n                print(\"‚ö†Ô∏è Selected voice identifier not found: \\(identifier), falling back to auto-detection\")\n                // Clear invalid selection\n                selectedVoiceIdentifier = nil\n            }\n        }\n        \n        // If no user selection, try to find premium voice - prefer language match, but use any premium voice if available\n        let premiumVoice = selectedVoice ?? getPremiumVoice(preferredLanguageCode: languageCode, preferredFullLanguage: fullLanguage)\n        \n        guard let voice = premiumVoice else {\n            error = .premiumVoiceUnavailable\n            throw TTSError.premiumVoiceUnavailable\n        }\n        \n        self.document = document\n        self.currentSentenceIndex = startIndex\n        self.currentSpokenIndex = startIndex\n        \n        // Collect all sentences from start index\n        sentences = []\n        var index = startIndex\n        while index < document.totalSentences {\n            if let sentence = document.sentence(at: index) {\n                sentences.append(sentence)\n                index += 1\n            } else {\n                break\n            }\n        }\n        \n        // Create utterances for sentences with selected voice\n        utteranceQueue = sentences.map { sentence in\n            let utterance = AVSpeechUtterance(string: sentence.text)\n            utterance.voice = voice\n            utterance.rate = AVSpeechUtteranceDefaultSpeechRate\n            utterance.pitchMultiplier = 1.0\n            utterance.volume = 1.0\n            return utterance\n        }\n        \n        // Start speaking\n        isSpeaking = true\n        speakNextUtterance()\n    }\n    \n    private func getPremiumVoice(preferredLanguageCode: String, preferredFullLanguage: String) -> AVSpeechSynthesisVoice? {\n        // Get all available voices\n        let availableVoices = AVSpeechSynthesisVoice.speechVoices()\n        \n        // Get ALL premium voices (regardless of language)\n        let allPremiumVoices = availableVoices.filter { $0.quality == .premium }\n        \n        // Also check for enhanced voices (some iOS versions may mark premium as enhanced)\n        let allEnhancedVoices = availableVoices.filter { $0.quality == .enhanced }\n        \n        // PRIORITY: Check for Siri voices (especially \"Siri voice 2\" which is premium)\n        let siriVoices = availableVoices.filter { voice in\n            let nameLower = voice.name.lowercased()\n            return nameLower.contains(\"siri\")\n        }\n        \n        // Specifically look for \"Siri voice 2\" (user's preferred premium voice)\n        let siriVoice2 = availableVoices.first { voice in\n            let nameLower = voice.name.lowercased()\n            return nameLower.contains(\"siri\") && (nameLower.contains(\"voice 2\") || nameLower.contains(\"voice2\") || nameLower.contains(\"2\"))\n        }\n        \n        // iOS 26.1 workaround: Also check voice identifiers for premium indicators\n        // Premium voices often have identifiers like \"com.apple.ttsbundle.VoiceName-premium\"\n        // or contain \"premium\" in the identifier\n        // Also check for voices that are NOT compact (compact voices are usually lower quality)\n        let premiumByIdentifier = availableVoices.filter { voice in\n            let idLower = voice.identifier.lowercased()\n            let nameLower = voice.name.lowercased()\n            \n            // Check for explicit premium indicators\n            return idLower.contains(\"premium\") ||\n            nameLower.contains(\"premium\") ||\n            idLower.contains(\"-premium\") ||\n            \n            // Premium voices are typically NOT compact versions\n            // Compact voices have \"-compact\" in identifier, premium don't\n            (!idLower.contains(\"compact\") && !idLower.contains(\"siri\") && voice.quality == .enhanced) ||\n            \n            // Check for known premium voice name patterns (e.g., \"Karen\", \"Moira\" for Australian)\n            // These are often premium when they're not compact\n            (nameLower.contains(\"karen\") && !idLower.contains(\"compact\")) ||\n            (nameLower.contains(\"moira\") && !idLower.contains(\"compact\"))\n        }\n        \n        // Also check: if we have both enhanced and default versions of the same voice,\n        // the enhanced one might actually be premium\n        let enhancedNonCompact = availableVoices.filter { voice in\n            voice.quality == .enhanced &&\n            !voice.identifier.lowercased().contains(\"compact\") &&\n            !voice.identifier.lowercased().contains(\"siri\")\n        }\n        \n        // iOS workaround: Combine all potential premium voices\n        // Priority: 1) Siri voice 2, 2) Other Siri voices, 3) Premium by quality, 4) Premium by identifier, 5) Enhanced non-compact, 6) Enhanced by quality\n        var highQualityVoices: [AVSpeechSynthesisVoice] = []\n        if let voice2 = siriVoice2 {\n            highQualityVoices = [voice2]\n        } else if !siriVoices.isEmpty {\n            highQualityVoices = siriVoices\n        } else if !allPremiumVoices.isEmpty {\n            highQualityVoices = allPremiumVoices\n        } else if !premiumByIdentifier.isEmpty {\n            highQualityVoices = premiumByIdentifier\n        } else if !enhancedNonCompact.isEmpty {\n            highQualityVoices = enhancedNonCompact\n        } else if !allEnhancedVoices.isEmpty {\n            highQualityVoices = allEnhancedVoices\n        } else {\n            // Last resort: Check for Australian voices\n            let australianVoices = availableVoices.filter { \n                $0.language.hasPrefix(\"en-AU\") || $0.language == \"en-AU\"\n            }\n            if !australianVoices.isEmpty {\n                highQualityVoices = australianVoices\n            }\n        }\n        \n        // If no high-quality voices exist at all, return nil\n        guard !highQualityVoices.isEmpty else {\n            return nil\n        }\n        \n        // First, try to find a high-quality voice matching the preferred language\n        let languageMatchedVoices = highQualityVoices.filter { voice in\n            voice.language.hasPrefix(preferredLanguageCode) || voice.language == preferredFullLanguage\n        }\n        \n        if !languageMatchedVoices.isEmpty {\n            // Prefer exact match, then any language match\n            if let exactMatch = languageMatchedVoices.first(where: { $0.language == preferredFullLanguage }) {\n                return exactMatch\n            }\n            \n            if let firstMatch = languageMatchedVoices.first {\n                return firstMatch\n            }\n        }\n        \n        // If no language match, use ANY high-quality voice\n        return highQualityVoices.first\n    }\n    \n    func stopSpeaking() {\n        synthesizer.stopSpeaking(at: .immediate)\n        isSpeaking = false\n        utteranceQueue.removeAll()\n        sentences.removeAll()\n    }\n    \n    private func speakNextUtterance() {\n        guard !utteranceQueue.isEmpty, isSpeaking else {\n            isSpeaking = false\n            return\n        }\n        \n        let utterance = utteranceQueue.removeFirst()\n        let sentenceIndex = currentSentenceIndex\n        \n        delegate.setCurrentIndex(sentenceIndex)\n        synthesizer.speak(utterance)\n        currentSentenceIndex += 1\n    }\n    \n    private func handleUtteranceFinished() {\n        if !utteranceQueue.isEmpty {\n            speakNextUtterance()\n        } else {\n            isSpeaking = false\n        }\n    }\n    \n    func handleInterruption() {\n        stopSpeaking()\n    }\n}\n\n\n", "metadata": {"file_path": "Core/TTS/TTSController.swift", "file_extension": ".swift", "file_name": "TTSController.swift", "file_size": 11075, "last_modified": 1766184032.196643}}
{"id": "10", "text": "import Foundation\nimport ZIPFoundation\n\nclass EPUBParser: BookParser {\n    private let contentExtractor: ContentExtractor = HTMLContentExtractor()\n    \n    func parse(url: URL) async throws -> DocumentModel {\n        // Extract EPUB to temporary directory\n        let tempDir = FileManager.default.temporaryDirectory.appendingPathComponent(UUID().uuidString)\n        try? FileManager.default.removeItem(at: tempDir)\n        try FileManager.default.createDirectory(at: tempDir, withIntermediateDirectories: true)\n        \n        defer {\n            try? FileManager.default.removeItem(at: tempDir)\n        }\n        \n        // Unzip EPUB\n        let archive: Archive\n        do {\n            archive = try Archive(url: url, accessMode: .read)\n        } catch {\n            throw BookParserError.parsingFailed(\"Failed to open EPUB archive: \\(error.localizedDescription)\")\n        }\n        \n        for entry in archive {\n            let entryPath = tempDir.appendingPathComponent(entry.path)\n            let entryDir = entryPath.deletingLastPathComponent()\n            try? FileManager.default.createDirectory(at: entryDir, withIntermediateDirectories: true)\n            \n            _ = try archive.extract(entry, to: entryPath)\n        }\n        \n        // Parse container.xml\n        let containerPath = tempDir.appendingPathComponent(\"META-INF/container.xml\")\n        guard FileManager.default.fileExists(atPath: containerPath.path) else {\n            throw BookParserError.parsingFailed(\"container.xml not found\")\n        }\n        \n        let containerData = try Data(contentsOf: containerPath)\n        let container = try parseContainer(data: containerData)\n        \n        // Parse OPF file\n        let opfPath = tempDir.appendingPathComponent(container.rootfilePath)\n        guard FileManager.default.fileExists(atPath: opfPath.path) else {\n            throw BookParserError.parsingFailed(\"OPF file not found at \\(container.rootfilePath)\")\n        }\n        \n        let opfData = try Data(contentsOf: opfPath)\n        let opf = try parseOPF(data: opfData, basePath: opfPath.deletingLastPathComponent())\n        \n        // Parse chapters according to spine\n        // For MVP, load all chapters immediately but in background\n        // In a full implementation, we'd use LazyDocumentModel for lazy loading\n        var chapters: [Chapter] = []\n        var globalIndex = 0\n        \n        for spineItem in opf.spine {\n            guard let manifestItem = opf.manifest.first(where: { $0.id == spineItem.idref }) else {\n                continue\n            }\n            \n            // Resolve chapter path - handle both absolute and relative paths\n            let chapterPath: URL\n            let href = manifestItem.href\n            if href.hasPrefix(\"/\") {\n                // Absolute path from EPUB root\n                chapterPath = tempDir.appendingPathComponent(String(href.dropFirst()))\n            } else {\n                // Relative path from OPF location\n                chapterPath = opfPath.deletingLastPathComponent().appendingPathComponent(href)\n            }\n            \n            guard FileManager.default.fileExists(atPath: chapterPath.path) else {\n                continue\n            }\n            \n            let chapter = try await parseChapter(\n                at: chapterPath,\n                chapterIndex: chapters.count,\n                globalIndex: &globalIndex\n            )\n            chapters.append(chapter)\n        }\n        \n        // Parse table of contents\n        var tableOfContents: [TOCEntry] = []\n        if let tocPath = opf.tocPath {\n            let tocURL = opfPath.deletingLastPathComponent().appendingPathComponent(tocPath)\n            if FileManager.default.fileExists(atPath: tocURL.path) {\n                tableOfContents = parseTOC(at: tocURL, spine: opf.spine, manifest: opf.manifest, basePath: opfPath.deletingLastPathComponent())\n            }\n        }\n        \n        return DocumentModel(\n            title: opf.metadata.title,\n            author: opf.metadata.creator,\n            chapters: chapters,\n            tableOfContents: tableOfContents\n        )\n    }\n    \n    private func parseContainer(data: Data) throws -> EPUBContainer {\n        // Simple XML parsing for container.xml\n        guard let xmlString = String(data: data, encoding: .utf8) else {\n            throw BookParserError.parsingFailed(\"Failed to decode container.xml\")\n        }\n        \n        // Extract rootfile path using simple regex/string matching\n        // This is a simplified parser - in production, use proper XML parser\n        guard let rootfileMatch = xmlString.range(of: #\"full-path=\"([^\"]+)\"\"#, options: .regularExpression) else {\n            throw BookParserError.parsingFailed(\"Could not find rootfile in container.xml\")\n        }\n        \n        let rootfilePath = String(xmlString[rootfileMatch])\n            .replacingOccurrences(of: #\"full-path=\"\"#, with: \"\")\n            .replacingOccurrences(of: #\"\"\"#, with: \"\")\n        \n        return EPUBContainer(rootfile: rootfilePath, rootfilePath: rootfilePath)\n    }\n    \n    private func parseOPF(data: Data, basePath: URL) throws -> OPFPackage {\n        guard let xmlString = String(data: data, encoding: .utf8) else {\n            throw BookParserError.parsingFailed(\"Failed to decode OPF file\")\n        }\n        \n        // Extract metadata\n        let title = extractXMLTag(xmlString, tag: \"dc:title\") ?? \"Unknown Title\"\n        let creator = extractXMLTag(xmlString, tag: \"dc:creator\")\n        \n        // Extract manifest items - handle any attribute order\n        var manifest: [OPFManifestItem] = []\n        let itemPattern = #\"<item\\s+([^>]+)/?\\s*>\"#\n        let itemRegex = try NSRegularExpression(pattern: itemPattern, options: [])\n        let itemMatches = itemRegex.matches(in: xmlString, options: [], range: NSRange(xmlString.startIndex..., in: xmlString))\n        \n        for match in itemMatches {\n            if let attrsRange = Range(match.range(at: 1), in: xmlString) {\n                let attrs = String(xmlString[attrsRange])\n                \n                // Extract individual attributes regardless of order\n                let idPattern = #\"id=\"([^\"]+)\"\"#\n                let hrefPattern = #\"href=\"([^\"]+)\"\"#\n                let mediaTypePattern = #\"media-type=\"([^\"]+)\"\"#\n                \n                var id: String?\n                var href: String?\n                var mediaType: String?\n                \n                if let idRegex = try? NSRegularExpression(pattern: idPattern),\n                   let idMatch = idRegex.firstMatch(in: attrs, range: NSRange(attrs.startIndex..., in: attrs)),\n                   let idRange = Range(idMatch.range(at: 1), in: attrs) {\n                    id = String(attrs[idRange])\n                }\n                \n                if let hrefRegex = try? NSRegularExpression(pattern: hrefPattern),\n                   let hrefMatch = hrefRegex.firstMatch(in: attrs, range: NSRange(attrs.startIndex..., in: attrs)),\n                   let hrefRange = Range(hrefMatch.range(at: 1), in: attrs) {\n                    href = String(attrs[hrefRange])\n                }\n                \n                if let mtRegex = try? NSRegularExpression(pattern: mediaTypePattern),\n                   let mtMatch = mtRegex.firstMatch(in: attrs, range: NSRange(attrs.startIndex..., in: attrs)),\n                   let mtRange = Range(mtMatch.range(at: 1), in: attrs) {\n                    mediaType = String(attrs[mtRange])\n                }\n                \n                if let id = id, let href = href, let mediaType = mediaType {\n                    manifest.append(OPFManifestItem(id: id, href: href, mediaType: mediaType))\n                }\n            }\n        }\n        \n        // Extract spine items and TOC reference\n        var spine: [OPFSpineItem] = []\n        var tocId: String? = nil\n        \n        // Check for toc attribute in spine element\n        let spineTocPattern = #\"<spine[^>]+toc=\"([^\"]+)\"\"#\n        if let spineTocRegex = try? NSRegularExpression(pattern: spineTocPattern, options: []),\n           let spineTocMatch = spineTocRegex.firstMatch(in: xmlString, options: [], range: NSRange(xmlString.startIndex..., in: xmlString)),\n           let tocIdRange = Range(spineTocMatch.range(at: 1), in: xmlString) {\n            tocId = String(xmlString[tocIdRange])\n        }\n        \n        let spinePattern = #\"<itemref[^>]+idref=\"([^\"]+)\"\"#\n        let spineRegex = try NSRegularExpression(pattern: spinePattern, options: [])\n        let spineMatches = spineRegex.matches(in: xmlString, options: [], range: NSRange(xmlString.startIndex..., in: xmlString))\n        \n        for match in spineMatches {\n            if match.numberOfRanges >= 2,\n               let idrefRange = Range(match.range(at: 1), in: xmlString) {\n                let idref = String(xmlString[idrefRange])\n                spine.append(OPFSpineItem(idref: idref))\n            }\n        }\n        \n        // Find TOC path from manifest\n        var tocPath: String? = nil\n        \n        // First, try to find NCX file by toc ID from spine\n        if let tocId = tocId,\n           let ncxItem = manifest.first(where: { $0.id == tocId }) {\n            tocPath = ncxItem.href\n        }\n        \n        // If not found, look for NCX by media type\n        if tocPath == nil,\n           let ncxItem = manifest.first(where: { $0.mediaType == \"application/x-dtbncx+xml\" }) {\n            tocPath = ncxItem.href\n        }\n        \n        // Also check for EPUB3 nav document\n        if tocPath == nil {\n            // Look for nav property in manifest items\n            let navPattern = #\"<item[^>]+properties=\"[^\"]*nav[^\"]*\"[^>]+href=\"([^\"]+)\"\"#\n            if let navRegex = try? NSRegularExpression(pattern: navPattern, options: []),\n               let navMatch = navRegex.firstMatch(in: xmlString, options: [], range: NSRange(xmlString.startIndex..., in: xmlString)),\n               let navHrefRange = Range(navMatch.range(at: 1), in: xmlString) {\n                tocPath = String(xmlString[navHrefRange])\n            }\n        }\n        \n        return OPFPackage(\n            metadata: OPFMetadata(title: title, creator: creator, date: nil),\n            manifest: manifest,\n            spine: spine,\n            tocPath: tocPath\n        )\n    }\n    \n    private func extractXMLTag(_ xml: String, tag: String) -> String? {\n        let pattern = #\"<#(tag)[^>]*>([^<]+)</#(tag)>\"#.replacingOccurrences(of: \"#(tag)\", with: tag)\n        let regex = try? NSRegularExpression(pattern: pattern, options: [])\n        let range = NSRange(xml.startIndex..., in: xml)\n        \n        if let match = regex?.firstMatch(in: xml, options: [], range: range),\n           match.numberOfRanges >= 3,\n           let textRange = Range(match.range(at: 2), in: xml) {\n            return String(xml[textRange]).trimmingCharacters(in: .whitespaces)\n        }\n        return nil\n    }\n    \n    private func parseChapter(at url: URL, chapterIndex: Int, globalIndex: inout Int) async throws -> Chapter {\n        let data = try Data(contentsOf: url)\n        guard let htmlString = String(data: data, encoding: .utf8) else {\n            throw BookParserError.parsingFailed(\"Failed to decode chapter HTML\")\n        }\n        \n        // Extract title from HTML (if present)\n        let title = contentExtractor.extractTitle(from: htmlString)\n        \n        // Extract paragraphs using the content extractor (preserves structure and formatting)\n        let extractedParagraphs = contentExtractor.extractText(from: htmlString)\n        \n        // Convert extracted paragraphs to document paragraphs with sentences\n        var documentParagraphs: [Paragraph] = []\n        \n        for (paraIndex, extractedPara) in extractedParagraphs.enumerated() {\n            // Split text into sentences while preserving formatting spans\n            let sentenceTexts = splitIntoSentences(extractedPara.text)\n            \n            // Map formatted spans to sentences\n            let sentences = sentenceTexts\n                .enumerated()\n                .map { index, text in\n                    // Find spans that belong to this sentence\n                    let sentenceSpans = mapSpansToSentence(\n                        text: text,\n                        allSpans: extractedPara.formattedSpans,\n                        fullText: extractedPara.text\n                    )\n                    \n                    return Sentence(\n                        text: text.trimmingCharacters(in: .whitespaces),\n                        globalIndex: globalIndex + index,\n                        chapterIndex: chapterIndex,\n                        paragraphIndex: paraIndex,\n                        sentenceIndex: index,\n                        formattedSpans: sentenceSpans\n                    )\n                }\n            \n            if !sentences.isEmpty {\n                documentParagraphs.append(Paragraph(\n                    sentences: sentences,\n                    isBlockquote: extractedPara.isBlockquote,\n                    isListItem: extractedPara.isListItem,\n                    listItemLevel: extractedPara.listItemLevel\n                ))\n                globalIndex += sentences.count\n            }\n        }\n        \n        return Chapter(title: title, paragraphs: documentParagraphs)\n    }\n    \n    /// Map formatting spans from the full paragraph to a specific sentence\n    private func mapSpansToSentence(text: String, allSpans: [FormattedSpan], fullText: String) -> [FormattedSpan] {\n        // Find where this sentence appears in the full text\n        guard let sentenceRange = fullText.range(of: text) else {\n            return [FormattedSpan(text: text, style: .none)]\n        }\n        \n        let sentenceStart = fullText.distance(from: fullText.startIndex, to: sentenceRange.lowerBound)\n        let sentenceEnd = sentenceStart + text.count\n        \n        // Track position in spans\n        var currentPos = 0\n        var resultSpans: [FormattedSpan] = []\n        \n        for span in allSpans {\n            let spanEnd = currentPos + span.text.count\n            \n            // Check if this span overlaps with the sentence\n            if spanEnd > sentenceStart && currentPos < sentenceEnd {\n                // Calculate the overlap\n                let overlapStart = max(currentPos, sentenceStart)\n                let overlapEnd = min(spanEnd, sentenceEnd)\n                \n                if overlapStart < overlapEnd {\n                    // Extract the overlapping portion of the span text\n                    let spanTextStart = overlapStart - currentPos\n                    let spanTextEnd = overlapEnd - currentPos\n                    \n                    let startIdx = span.text.index(span.text.startIndex, offsetBy: spanTextStart)\n                    let endIdx = span.text.index(span.text.startIndex, offsetBy: min(spanTextEnd, span.text.count))\n                    \n                    let extractedText = String(span.text[startIdx..<endIdx])\n                    if !extractedText.isEmpty {\n                        resultSpans.append(FormattedSpan(text: extractedText, style: span.style))\n                    }\n                }\n            }\n            \n            currentPos = spanEnd\n        }\n        \n        // If no spans found, return plain text\n        if resultSpans.isEmpty {\n            return [FormattedSpan(text: text, style: .none)]\n        }\n        \n        return resultSpans\n    }\n    \n    // MARK: - TOC Parsing\n    \n    private func parseTOC(at url: URL, spine: [OPFSpineItem], manifest: [OPFManifestItem], basePath: URL) -> [TOCEntry] {\n        guard let data = try? Data(contentsOf: url),\n              let xmlString = String(data: data, encoding: .utf8) else {\n            return []\n        }\n        \n        // Check if this is NCX (EPUB2) or nav.xhtml (EPUB3)\n        if url.pathExtension.lowercased() == \"ncx\" || xmlString.contains(\"<ncx\") {\n            return parseNCX(xmlString, spine: spine, manifest: manifest, basePath: basePath)\n        } else {\n            return parseNavXHTML(xmlString, spine: spine, manifest: manifest, basePath: basePath)\n        }\n    }\n    \n    private func parseNCX(_ xml: String, spine: [OPFSpineItem], manifest: [OPFManifestItem], basePath: URL) -> [TOCEntry] {\n        var entries: [TOCEntry] = []\n        \n        // Parse navPoint elements\n        let navPointPattern = #\"<navPoint[^>]*>[\\s\\S]*?<navLabel>[\\s\\S]*?<text>([^<]+)</text>[\\s\\S]*?</navLabel>[\\s\\S]*?<content\\s+src=\"([^\"]+)\"[^/]*/?>[\\s\\S]*?</navPoint>\"#\n        \n        guard let regex = try? NSRegularExpression(pattern: navPointPattern, options: []) else {\n            return entries\n        }\n        \n        let matches = regex.matches(in: xml, options: [], range: NSRange(xml.startIndex..., in: xml))\n        \n        for match in matches {\n            guard match.numberOfRanges >= 3,\n                  let labelRange = Range(match.range(at: 1), in: xml),\n                  let srcRange = Range(match.range(at: 2), in: xml) else {\n                continue\n            }\n            \n            let label = String(xml[labelRange]).trimmingCharacters(in: .whitespacesAndNewlines)\n            let src = String(xml[srcRange])\n            \n            // Extract just the file path (remove fragment identifier)\n            let filePath = src.components(separatedBy: \"#\").first ?? src\n            \n            // Find chapter index by matching href to spine/manifest\n            let chapterIndex = findChapterIndex(for: filePath, spine: spine, manifest: manifest)\n            \n            entries.append(TOCEntry(\n                title: label,\n                chapterIndex: chapterIndex,\n                href: src,\n                depth: 0\n            ))\n        }\n        \n        return entries\n    }\n    \n    private func parseNavXHTML(_ xml: String, spine: [OPFSpineItem], manifest: [OPFManifestItem], basePath: URL) -> [TOCEntry] {\n        var entries: [TOCEntry] = []\n        \n        // Find the nav element with epub:type=\"toc\"\n        let navPattern = #\"<nav[^>]*epub:type=\"toc\"[^>]*>[\\s\\S]*?<ol[^>]*>([\\s\\S]*?)</ol>\"#\n        \n        guard let navRegex = try? NSRegularExpression(pattern: navPattern, options: []),\n              let navMatch = navRegex.firstMatch(in: xml, options: [], range: NSRange(xml.startIndex..., in: xml)),\n              let olRange = Range(navMatch.range(at: 1), in: xml) else {\n            // Fallback: try to find any ol with li > a structure\n            return parseSimpleNavLinks(xml, spine: spine, manifest: manifest)\n        }\n        \n        let olContent = String(xml[olRange])\n        \n        // Parse li > a elements\n        let liPattern = #\"<li[^>]*>[\\s\\S]*?<a[^>]+href=\"([^\"]+)\"[^>]*>([^<]+)</a>\"#\n        \n        guard let liRegex = try? NSRegularExpression(pattern: liPattern, options: []) else {\n            return entries\n        }\n        \n        let matches = liRegex.matches(in: olContent, options: [], range: NSRange(olContent.startIndex..., in: olContent))\n        \n        for match in matches {\n            guard match.numberOfRanges >= 3,\n                  let hrefRange = Range(match.range(at: 1), in: olContent),\n                  let textRange = Range(match.range(at: 2), in: olContent) else {\n                continue\n            }\n            \n            let href = String(olContent[hrefRange])\n            let text = String(olContent[textRange]).trimmingCharacters(in: .whitespacesAndNewlines)\n            \n            let filePath = href.components(separatedBy: \"#\").first ?? href\n            let chapterIndex = findChapterIndex(for: filePath, spine: spine, manifest: manifest)\n            \n            entries.append(TOCEntry(\n                title: text,\n                chapterIndex: chapterIndex,\n                href: href,\n                depth: 0\n            ))\n        }\n        \n        return entries\n    }\n    \n    private func parseSimpleNavLinks(_ xml: String, spine: [OPFSpineItem], manifest: [OPFManifestItem]) -> [TOCEntry] {\n        var entries: [TOCEntry] = []\n        \n        // Simple pattern to find any anchor links that might be TOC\n        let linkPattern = #\"<a[^>]+href=\"([^\"]+)\"[^>]*>([^<]+)</a>\"#\n        \n        guard let regex = try? NSRegularExpression(pattern: linkPattern, options: []) else {\n            return entries\n        }\n        \n        let matches = regex.matches(in: xml, options: [], range: NSRange(xml.startIndex..., in: xml))\n        \n        for match in matches {\n            guard match.numberOfRanges >= 3,\n                  let hrefRange = Range(match.range(at: 1), in: xml),\n                  let textRange = Range(match.range(at: 2), in: xml) else {\n                continue\n            }\n            \n            let href = String(xml[hrefRange])\n            let text = String(xml[textRange]).trimmingCharacters(in: .whitespacesAndNewlines)\n            \n            // Skip external links and anchors\n            guard !href.hasPrefix(\"http\"), !href.hasPrefix(\"#\"), !text.isEmpty else {\n                continue\n            }\n            \n            let filePath = href.components(separatedBy: \"#\").first ?? href\n            let chapterIndex = findChapterIndex(for: filePath, spine: spine, manifest: manifest)\n            \n            // Only include if we found a valid chapter\n            if chapterIndex >= 0 {\n                entries.append(TOCEntry(\n                    title: text,\n                    chapterIndex: chapterIndex,\n                    href: href,\n                    depth: 0\n                ))\n            }\n        }\n        \n        return entries\n    }\n    \n    private func findChapterIndex(for href: String, spine: [OPFSpineItem], manifest: [OPFManifestItem]) -> Int {\n        // Normalize the href (remove leading ./ or /)\n        var normalizedHref = href\n        if normalizedHref.hasPrefix(\"./\") {\n            normalizedHref = String(normalizedHref.dropFirst(2))\n        }\n        if normalizedHref.hasPrefix(\"/\") {\n            normalizedHref = String(normalizedHref.dropFirst())\n        }\n        \n        // URL decode the href\n        normalizedHref = normalizedHref.removingPercentEncoding ?? normalizedHref\n        \n        // Find manifest item by href\n        guard let manifestItem = manifest.first(where: { item in\n            var itemHref = item.href\n            if itemHref.hasPrefix(\"./\") {\n                itemHref = String(itemHref.dropFirst(2))\n            }\n            itemHref = itemHref.removingPercentEncoding ?? itemHref\n            return itemHref == normalizedHref || item.href == href\n        }) else {\n            return -1\n        }\n        \n        // Find spine index for this manifest item\n        for (index, spineItem) in spine.enumerated() {\n            if spineItem.idref == manifestItem.id {\n                return index\n            }\n        }\n        \n        return -1\n    }\n    \n    // MARK: - Sentence Splitting\n    \n    private func splitIntoSentences(_ text: String) -> [String] {\n        let sentenceEndings = CharacterSet(charactersIn: \".!?\")\n        var sentences: [String] = []\n        var currentSentence = \"\"\n        \n        for char in text {\n            currentSentence.append(char)\n            if sentenceEndings.contains(char.unicodeScalars.first!) {\n                let trimmed = currentSentence.trimmingCharacters(in: .whitespaces)\n                if !trimmed.isEmpty {\n                    sentences.append(trimmed)\n                }\n                currentSentence = \"\"\n            }\n        }\n        \n        let trimmed = currentSentence.trimmingCharacters(in: .whitespaces)\n        if !trimmed.isEmpty {\n            sentences.append(trimmed)\n        }\n        \n        return sentences.isEmpty ? [text] : sentences\n    }\n}\n\n", "metadata": {"file_path": "Core/BookParser/EPUBParser.swift", "file_extension": ".swift", "file_name": "EPUBParser.swift", "file_size": 23742, "last_modified": 1766184032.1966634}}
{"id": "11", "text": "import Foundation\n\n/// A lazy-loading wrapper around DocumentModel that loads chapters on demand\nclass LazyDocumentModel {\n    let title: String\n    let author: String?\n    private let chapterLoaders: [() async throws -> Chapter]\n    private var loadedChapters: [Int: Chapter] = [:]\n    private let totalChapters: Int\n    \n    init(title: String, author: String?, chapterLoaders: [() async throws -> Chapter]) {\n        self.title = title\n        self.author = author\n        self.chapterLoaders = chapterLoaders\n        self.totalChapters = chapterLoaders.count\n    }\n    \n    func getChapter(at index: Int) async throws -> Chapter {\n        if let loaded = loadedChapters[index] {\n            return loaded\n        }\n        \n        guard index < chapterLoaders.count else {\n            throw BookParserError.parsingFailed(\"Chapter index out of range\")\n        }\n        \n        let chapter = try await chapterLoaders[index]()\n        loadedChapters[index] = chapter\n        return chapter\n    }\n    \n    func loadFirstChapter() async throws {\n        if loadedChapters[0] == nil {\n            _ = try await getChapter(at: 0)\n        }\n    }\n    \n    func preloadChapters(startingFrom index: Int, count: Int) async {\n        let endIndex = min(index + count, totalChapters)\n        for i in index..<endIndex {\n            if loadedChapters[i] == nil {\n                Task {\n                    _ = try? await getChapter(at: i)\n                }\n            }\n        }\n    }\n    \n    var chapterCount: Int {\n        totalChapters\n    }\n}\n\n\n", "metadata": {"file_path": "Core/BookParser/LazyDocumentModel.swift", "file_extension": ".swift", "file_name": "LazyDocumentModel.swift", "file_size": 1545, "last_modified": 1766184032.1964195}}
{"id": "12", "text": "import Foundation\n\nclass TXTParser: BookParser {\n    func parse(url: URL) async throws -> DocumentModel {\n        let data = try Data(contentsOf: url)\n        guard let text = String(data: data, encoding: .utf8) else {\n            throw BookParserError.parsingFailed(\"Failed to decode text as UTF-8\")\n        }\n        \n        // Split into paragraphs\n        let paragraphs = text.components(separatedBy: .newlines)\n            .map { $0.trimmingCharacters(in: .whitespaces) }\n            .filter { !$0.isEmpty }\n        \n        // Split paragraphs into sentences\n        var globalIndex = 0\n        var documentParagraphs: [Paragraph] = []\n        \n        for paragraphText in paragraphs {\n            let sentences = splitIntoSentences(paragraphText)\n                .enumerated()\n                .map { index, text in\n                    Sentence(\n                        text: text.trimmingCharacters(in: .whitespaces),\n                        globalIndex: globalIndex + index,\n                        chapterIndex: 0,\n                        paragraphIndex: documentParagraphs.count,\n                        sentenceIndex: index\n                    )\n                }\n            \n            if !sentences.isEmpty {\n                documentParagraphs.append(Paragraph(sentences: sentences))\n                globalIndex += sentences.count\n            }\n        }\n        \n        // Create a single chapter for plain text\n        let chapter = Chapter(title: nil, paragraphs: documentParagraphs)\n        \n        // Extract title from filename\n        let title = url.deletingPathExtension().lastPathComponent\n        \n        return DocumentModel(\n            title: title,\n            author: nil,\n            chapters: [chapter]\n        )\n    }\n    \n    private func splitIntoSentences(_ text: String) -> [String] {\n        // Simple sentence splitting based on punctuation\n        let sentenceEndings = CharacterSet(charactersIn: \".!?\")\n        var sentences: [String] = []\n        var currentSentence = \"\"\n        \n        for char in text {\n            currentSentence.append(char)\n            if let firstScalar = char.unicodeScalars.first,\n               sentenceEndings.contains(firstScalar) {\n                let trimmed = currentSentence.trimmingCharacters(in: .whitespaces)\n                if !trimmed.isEmpty {\n                    sentences.append(trimmed)\n                }\n                currentSentence = \"\"\n            }\n        }\n        \n        // Add remaining text if any\n        let trimmed = currentSentence.trimmingCharacters(in: .whitespaces)\n        if !trimmed.isEmpty {\n            sentences.append(trimmed)\n        }\n        \n        return sentences.isEmpty ? [text] : sentences\n    }\n}\n\n\n", "metadata": {"file_path": "Core/BookParser/TXTParser.swift", "file_extension": ".swift", "file_name": "TXTParser.swift", "file_size": 2731, "last_modified": 1766184032.1963725}}
{"id": "13", "text": "import Foundation\n\n// MARK: - EPUB Container\nstruct EPUBContainer {\n    let rootfile: String\n    let rootfilePath: String\n}\n\n// MARK: - OPF Package\nstruct OPFPackage {\n    let metadata: OPFMetadata\n    let manifest: [OPFManifestItem]\n    let spine: [OPFSpineItem]\n    var tocPath: String? = nil // Path to NCX or nav.xhtml\n}\n\nstruct OPFMetadata {\n    let title: String\n    let creator: String?\n    let date: String?\n}\n\nstruct OPFManifestItem {\n    let id: String\n    let href: String\n    let mediaType: String\n}\n\nstruct OPFSpineItem {\n    let idref: String\n}\n\n// MARK: - Table of Contents\nstruct TOCEntry: Identifiable {\n    let id: UUID\n    let title: String\n    let chapterIndex: Int\n    let href: String\n    let depth: Int // For nested TOC (0 = top level)\n    \n    init(id: UUID = UUID(), title: String, chapterIndex: Int, href: String, depth: Int = 0) {\n        self.id = id\n        self.title = title\n        self.chapterIndex = chapterIndex\n        self.href = href\n        self.depth = depth\n    }\n}\n\n// MARK: - NCX Navigation Point (for parsing)\nstruct NCXNavPoint {\n    let id: String\n    let playOrder: Int\n    let label: String\n    let contentSrc: String\n    let children: [NCXNavPoint]\n}\n\n\n", "metadata": {"file_path": "Core/BookParser/EPUBModels.swift", "file_extension": ".swift", "file_name": "EPUBModels.swift", "file_size": 1203, "last_modified": 1766184032.1966367}}
{"id": "14", "text": "import Foundation\n\nprotocol BookParser {\n    func parse(url: URL) async throws -> DocumentModel\n}\n\nenum BookParserError: Error {\n    case unsupportedFormat\n    case fileNotFound\n    case parsingFailed(String)\n}\n\n\n", "metadata": {"file_path": "Core/BookParser/BookParser.swift", "file_extension": ".swift", "file_name": "BookParser.swift", "file_size": 213, "last_modified": 1765400658.5632963}}
{"id": "15", "text": "import Foundation\n\n/// Protocol for extracting text content from various formats\nprotocol ContentExtractor {\n    func extractText(from html: String) -> [ExtractedParagraph]\n    func extractTitle(from html: String) -> String?\n}\n\n/// Text formatting styles that can be applied to text spans\nstruct TextStyle: OptionSet {\n    let rawValue: Int\n    \n    static let bold = TextStyle(rawValue: 1 << 0)\n    static let italic = TextStyle(rawValue: 1 << 1)\n    static let underline = TextStyle(rawValue: 1 << 2)\n    static let strikethrough = TextStyle(rawValue: 1 << 3)\n    static let superscript = TextStyle(rawValue: 1 << 4)\n    static let subscriptStyle = TextStyle(rawValue: 1 << 5)\n    static let code = TextStyle(rawValue: 1 << 6)\n    \n    static let none: TextStyle = []\n}\n\n/// A span of text with associated formatting\nstruct FormattedSpan {\n    let text: String\n    let style: TextStyle\n}\n\n/// Represents a paragraph extracted from HTML content with rich formatting\nstruct ExtractedParagraph {\n    let text: String\n    let isHeading: Bool\n    let headingLevel: Int? // 1-6 for h1-h6\n    let isBlockquote: Bool\n    let isListItem: Bool\n    let listItemLevel: Int\n    let formattedSpans: [FormattedSpan]\n    \n    init(text: String, isHeading: Bool = false, headingLevel: Int? = nil,\n         isBlockquote: Bool = false, isListItem: Bool = false, listItemLevel: Int = 0,\n         formattedSpans: [FormattedSpan] = []) {\n        self.text = text\n        self.isHeading = isHeading\n        self.headingLevel = headingLevel\n        self.isBlockquote = isBlockquote\n        self.isListItem = isListItem\n        self.listItemLevel = listItemLevel\n        // If no formatted spans provided, create a single plain span\n        self.formattedSpans = formattedSpans.isEmpty ? [FormattedSpan(text: text, style: .none)] : formattedSpans\n    }\n}\n\n/// HTML content extractor that preserves paragraph structure, inline formatting, and handles dialogue correctly\nclass HTMLContentExtractor: ContentExtractor {\n    \n    // MARK: - HTML Entity Decoding\n    \n    /// Comprehensive HTML entity decoding\n    private func decodeHTMLEntities(_ text: String) -> String {\n        var result = text\n        \n        // Named entities (most common)\n        let namedEntities: [String: String] = [\n            \"&nbsp;\": \" \",\n            \"&amp;\": \"&\",\n            \"&lt;\": \"<\",\n            \"&gt;\": \">\",\n            \"&quot;\": \"\\\"\",\n            \"&apos;\": \"'\",\n            \"&ldquo;\": \"\\u{201C}\",\n            \"&rdquo;\": \"\\u{201D}\",\n            \"&lsquo;\": \"\\u{2018}\",\n            \"&rsquo;\": \"\\u{2019}\",\n            \"&mdash;\": \"‚Äî\",\n            \"&ndash;\": \"‚Äì\",\n            \"&hellip;\": \"‚Ä¶\",\n            \"&copy;\": \"¬©\",\n            \"&reg;\": \"¬Æ\",\n            \"&trade;\": \"‚Ñ¢\",\n            \"&deg;\": \"¬∞\",\n            \"&plusmn;\": \"¬±\",\n            \"&frac12;\": \"¬Ω\",\n            \"&frac14;\": \"¬º\",\n            \"&frac34;\": \"¬æ\",\n            \"&times;\": \"√ó\",\n            \"&divide;\": \"√∑\",\n            \"&euro;\": \"‚Ç¨\",\n            \"&pound;\": \"¬£\",\n            \"&yen;\": \"¬•\",\n            \"&cent;\": \"¬¢\",\n            \"&sect;\": \"¬ß\",\n            \"&para;\": \"¬∂\",\n            \"&bull;\": \"‚Ä¢\",\n            \"&middot;\": \"¬∑\",\n            \"&laquo;\": \"¬´\",\n            \"&raquo;\": \"¬ª\",\n            \"&iexcl;\": \"¬°\",\n            \"&iquest;\": \"¬ø\",\n            \"&#39;\": \"'\",\n            \"&#34;\": \"\\\"\",\n            \"&#38;\": \"&\",\n            \"&#60;\": \"<\",\n            \"&#62;\": \">\"\n        ]\n        \n        for (entity, replacement) in namedEntities {\n            result = result.replacingOccurrences(of: entity, with: replacement)\n        }\n        \n        // Decode numeric entities (decimal): &#123;\n        let decimalPattern = #\"&#(\\d+);\"#\n        if let regex = try? NSRegularExpression(pattern: decimalPattern, options: []) {\n            let range = NSRange(result.startIndex..., in: result)\n            let matches = regex.matches(in: result, options: [], range: range).reversed()\n            \n            for match in matches {\n                if let codeRange = Range(match.range(at: 1), in: result),\n                   let codePoint = Int(result[codeRange]),\n                   let scalar = Unicode.Scalar(codePoint) {\n                    let char = String(Character(scalar))\n                    if let fullRange = Range(match.range, in: result) {\n                        result.replaceSubrange(fullRange, with: char)\n                    }\n                }\n            }\n        }\n        \n        // Decode numeric entities (hexadecimal): &#x1F4A9;\n        let hexPattern = #\"&#[xX]([0-9a-fA-F]+);\"#\n        if let regex = try? NSRegularExpression(pattern: hexPattern, options: []) {\n            let range = NSRange(result.startIndex..., in: result)\n            let matches = regex.matches(in: result, options: [], range: range).reversed()\n            \n            for match in matches {\n                if let codeRange = Range(match.range(at: 1), in: result),\n                   let codePoint = Int(result[codeRange], radix: 16),\n                   let scalar = Unicode.Scalar(codePoint) {\n                    let char = String(Character(scalar))\n                    if let fullRange = Range(match.range, in: result) {\n                        result.replaceSubrange(fullRange, with: char)\n                    }\n                }\n            }\n        }\n        \n        return result\n    }\n    \n    // MARK: - HTML Cleaning\n    \n    /// Remove script, style, and other non-content elements\n    private func removeNonContentElements(_ html: String) -> String {\n        var result = html\n        \n        // Remove script tags and content (handle multiline)\n        result = result.replacingOccurrences(\n            of: #\"<script[^>]*>[\\s\\S]*?</script>\"#,\n            with: \"\",\n            options: .regularExpression\n        )\n        \n        // Remove style tags and content\n        result = result.replacingOccurrences(\n            of: #\"<style[^>]*>[\\s\\S]*?</style>\"#,\n            with: \"\",\n            options: .regularExpression\n        )\n        \n        // Remove head section\n        result = result.replacingOccurrences(\n            of: #\"<head[^>]*>[\\s\\S]*?</head>\"#,\n            with: \"\",\n            options: .regularExpression\n        )\n        \n        // Remove comments\n        result = result.replacingOccurrences(\n            of: #\"<!--[\\s\\S]*?-->\"#,\n            with: \"\",\n            options: .regularExpression\n        )\n        \n        return result\n    }\n    \n    // MARK: - Inline Formatting Extraction\n    \n    /// Extract formatted spans from HTML content, preserving bold, italic, etc.\n    private func extractFormattedSpans(from html: String) -> [FormattedSpan] {\n        var spans: [FormattedSpan] = []\n        var currentText = \"\"\n        var currentStyle: TextStyle = .none\n        var styleStack: [TextStyle] = []\n        \n        // Use markers to track inline formatting\n        var processedHTML = html\n        \n        // Replace inline formatting tags with markers\n        // Note: Use word boundaries or specific tag matching to avoid false positives\n        let inlineMarkers: [(pattern: String, closePattern: String, style: TextStyle)] = [\n            (#\"<(b|strong)(\\s[^>]*)?>(?!/)\"#, #\"</(b|strong)>\"#, .bold),\n            (#\"<(i|em|cite)(\\s[^>]*)?>(?!/)\"#, #\"</(i|em|cite)>\"#, .italic),\n            (#\"<(u|ins)(\\s[^>]*)?>(?!/)\"#, #\"</(u|ins)>\"#, .underline),\n            (#\"<(del|strike)(\\s[^>]*)?>(?!/)\"#, #\"</(del|strike)>\"#, .strikethrough),\n            (#\"<sup(\\s[^>]*)?>(?!/)\"#, #\"</sup>\"#, .superscript),\n            (#\"<sub(\\s[^>]*)?>(?!/)\"#, #\"</sub>\"#, .subscriptStyle),\n            (#\"<(code|tt)(\\s[^>]*)?>(?!/)\"#, #\"</(code|tt)>\"#, .code)\n        ]\n        \n        // Track positions and styles\n        struct StyleMarker {\n            let position: Int\n            let style: TextStyle\n            let isOpen: Bool\n        }\n        \n        var markers: [StyleMarker] = []\n        \n        // Find all style markers\n        for (openPattern, closePattern, style) in inlineMarkers {\n            // Find opening tags\n            if let regex = try? NSRegularExpression(pattern: openPattern, options: .caseInsensitive) {\n                let range = NSRange(processedHTML.startIndex..., in: processedHTML)\n                let matches = regex.matches(in: processedHTML, options: [], range: range)\n                for match in matches {\n                    markers.append(StyleMarker(position: match.range.location, style: style, isOpen: true))\n                }\n            }\n            \n            // Find closing tags\n            if let regex = try? NSRegularExpression(pattern: closePattern, options: .caseInsensitive) {\n                let range = NSRange(processedHTML.startIndex..., in: processedHTML)\n                let matches = regex.matches(in: processedHTML, options: [], range: range)\n                for match in matches {\n                    markers.append(StyleMarker(position: match.range.location, style: style, isOpen: false))\n                }\n            }\n        }\n        \n        // Sort markers by position\n        markers.sort { $0.position < $1.position }\n        \n        // Remove all HTML tags but track where formatting changes\n        let plainText = processedHTML.replacingOccurrences(\n            of: #\"<[^>]+>\"#,\n            with: \"\",\n            options: .regularExpression\n        )\n        \n        // If no formatting found, return single plain span\n        if markers.isEmpty {\n            let decodedText = decodeHTMLEntities(normalizeWhitespace(plainText))\n            if !decodedText.isEmpty {\n                return [FormattedSpan(text: decodedText, style: .none)]\n            }\n            return []\n        }\n        \n        // Build spans by processing the text with style tracking\n        // For simplicity, we'll use a simpler approach: parse text segments between tags\n        var segments: [(text: String, style: TextStyle)] = []\n        var activeStyles: TextStyle = .none\n        \n        // Process HTML character by character, tracking styles\n        var i = processedHTML.startIndex\n        var textBuffer = \"\"\n        \n        while i < processedHTML.endIndex {\n            let char = processedHTML[i]\n            \n            if char == \"<\" {\n                // Save current buffer\n                if !textBuffer.isEmpty {\n                    segments.append((textBuffer, activeStyles))\n                    textBuffer = \"\"\n                }\n                \n                // Find end of tag\n                if let tagEnd = processedHTML[i...].firstIndex(of: \">\") {\n                    let tagContent = String(processedHTML[i...tagEnd])\n                    \n                    // Check what kind of tag this is\n                    let isClosing = tagContent.hasPrefix(\"</\")\n                    let tagLower = tagContent.lowercased()\n                    \n                    // Update active styles based on tag\n                    for (openPattern, closePattern, style) in inlineMarkers {\n                        if !isClosing {\n                            if let regex = try? NSRegularExpression(pattern: openPattern, options: .caseInsensitive),\n                               regex.firstMatch(in: tagContent, range: NSRange(tagContent.startIndex..., in: tagContent)) != nil {\n                                activeStyles.insert(style)\n                            }\n                        } else {\n                            if let regex = try? NSRegularExpression(pattern: closePattern, options: .caseInsensitive),\n                               regex.firstMatch(in: tagContent, range: NSRange(tagContent.startIndex..., in: tagContent)) != nil {\n                                activeStyles.remove(style)\n                            }\n                        }\n                    }\n                    \n                    i = processedHTML.index(after: tagEnd)\n                    continue\n                }\n            }\n            \n            textBuffer.append(char)\n            i = processedHTML.index(after: i)\n        }\n        \n        // Save final buffer\n        if !textBuffer.isEmpty {\n            segments.append((textBuffer, activeStyles))\n        }\n        \n        // Convert segments to spans, merging adjacent segments with same style\n        var mergedSpans: [FormattedSpan] = []\n        for segment in segments {\n            let decodedText = decodeHTMLEntities(segment.text)\n            if decodedText.isEmpty { continue }\n            \n            if let last = mergedSpans.last, last.style == segment.style {\n                // Merge with previous span\n                mergedSpans[mergedSpans.count - 1] = FormattedSpan(\n                    text: last.text + decodedText,\n                    style: segment.style\n                )\n            } else {\n                mergedSpans.append(FormattedSpan(text: decodedText, style: segment.style))\n            }\n        }\n        \n        return mergedSpans\n    }\n    \n    // MARK: - Block Element Extraction\n    \n    /// Extract paragraphs from HTML, preserving structure and inline formatting\n    func extractText(from html: String) -> [ExtractedParagraph] {\n        var paragraphs: [ExtractedParagraph] = []\n        \n        // Clean non-content elements first\n        let cleanedHTML = removeNonContentElements(html)\n        \n        // Extract body content if present\n        var bodyContent = cleanedHTML\n        if let bodyMatch = cleanedHTML.range(of: #\"<body[^>]*>([\\s\\S]*)</body>\"#, options: .regularExpression) {\n            let bodyHTML = String(cleanedHTML[bodyMatch])\n            bodyContent = bodyHTML\n                .replacingOccurrences(of: #\"<body[^>]*>\"#, with: \"\", options: .regularExpression)\n                .replacingOccurrences(of: \"</body>\", with: \"\")\n        }\n        \n        // Process block elements with markers\n        var processedContent = bodyContent\n        \n        // Block and heading markers\n        let blockMarker = \"‚ü¶BLOCK‚üß\"\n        let blockquoteOpenMarker = \"‚ü¶BQ‚üß\"\n        let blockquoteCloseMarker = \"‚ü¶/BQ‚üß\"\n        let listItemMarker = \"‚ü¶LI‚üß\"\n        \n        let headingMarkers = [\n            (\"h1\", \"‚ü¶H1‚üß\", \"‚ü¶/H1‚üß\"),\n            (\"h2\", \"‚ü¶H2‚üß\", \"‚ü¶/H2‚üß\"),\n            (\"h3\", \"‚ü¶H3‚üß\", \"‚ü¶/H3‚üß\"),\n            (\"h4\", \"‚ü¶H4‚üß\", \"‚ü¶/H4‚üß\"),\n            (\"h5\", \"‚ü¶H5‚üß\", \"‚ü¶/H5‚üß\"),\n            (\"h6\", \"‚ü¶H6‚üß\", \"‚ü¶/H6‚üß\")\n        ]\n        \n        // Replace heading tags with markers\n        for (tag, openMarker, closeMarker) in headingMarkers {\n            processedContent = processedContent.replacingOccurrences(\n                of: #\"<\\#(tag)[^>]*>\"#.replacingOccurrences(of: \"#(tag)\", with: tag),\n                with: blockMarker + openMarker,\n                options: [.regularExpression, .caseInsensitive]\n            )\n            processedContent = processedContent.replacingOccurrences(\n                of: #\"</\\#(tag)>\"#.replacingOccurrences(of: \"#(tag)\", with: tag),\n                with: closeMarker + blockMarker,\n                options: [.regularExpression, .caseInsensitive]\n            )\n        }\n        \n        // Handle blockquotes\n        processedContent = processedContent.replacingOccurrences(\n            of: #\"<blockquote[^>]*>\"#,\n            with: blockMarker + blockquoteOpenMarker,\n            options: [.regularExpression, .caseInsensitive]\n        )\n        processedContent = processedContent.replacingOccurrences(\n            of: \"</blockquote>\",\n            with: blockquoteCloseMarker + blockMarker,\n            options: [.regularExpression, .caseInsensitive]\n        )\n        \n        // Handle list items\n        processedContent = processedContent.replacingOccurrences(\n            of: #\"<li[^>]*>\"#,\n            with: blockMarker + listItemMarker,\n            options: [.regularExpression, .caseInsensitive]\n        )\n        processedContent = processedContent.replacingOccurrences(\n            of: \"</li>\",\n            with: blockMarker,\n            options: [.regularExpression, .caseInsensitive]\n        )\n        \n        // Replace other block elements with markers\n        let blockTags = [\"p\", \"div\", \"dd\", \"dt\", \"figcaption\", \"article\", \"section\", \"aside\", \"ul\", \"ol\"]\n        for tag in blockTags {\n            processedContent = processedContent.replacingOccurrences(\n                of: #\"<\\#(tag)[^>]*>\"#.replacingOccurrences(of: \"#(tag)\", with: tag),\n                with: blockMarker,\n                options: [.regularExpression, .caseInsensitive]\n            )\n            processedContent = processedContent.replacingOccurrences(\n                of: #\"</\\#(tag)>\"#.replacingOccurrences(of: \"#(tag)\", with: tag),\n                with: blockMarker,\n                options: [.regularExpression, .caseInsensitive]\n            )\n        }\n        \n        // Handle <br> tags\n        processedContent = processedContent.replacingOccurrences(\n            of: #\"<br\\s*/?>\"#,\n            with: \" \",\n            options: [.regularExpression, .caseInsensitive]\n        )\n        \n        // Split by block markers and process\n        let blocks = processedContent.components(separatedBy: blockMarker)\n        \n        var inBlockquote = false\n        \n        for block in blocks {\n            var text = block\n            var isHeading = false\n            var headingLevel: Int? = nil\n            var isBlockquote = inBlockquote\n            var isListItem = false\n            \n            // Track blockquote state\n            if text.contains(blockquoteOpenMarker) {\n                inBlockquote = true\n                isBlockquote = true\n                text = text.replacingOccurrences(of: blockquoteOpenMarker, with: \"\")\n            }\n            if text.contains(blockquoteCloseMarker) {\n                inBlockquote = false\n                text = text.replacingOccurrences(of: blockquoteCloseMarker, with: \"\")\n            }\n            \n            // Check for list item\n            if text.contains(listItemMarker) {\n                isListItem = true\n                text = text.replacingOccurrences(of: listItemMarker, with: \"‚Ä¢ \")\n            }\n            \n            // Check for headings\n            for (index, (_, openMarker, closeMarker)) in headingMarkers.enumerated() {\n                if text.contains(openMarker) {\n                    isHeading = true\n                    headingLevel = index + 1\n                    text = text\n                        .replacingOccurrences(of: openMarker, with: \"\")\n                        .replacingOccurrences(of: closeMarker, with: \"\")\n                    break\n                }\n            }\n            \n            // Extract formatted spans from the remaining HTML\n            let spans = extractFormattedSpans(from: text)\n            \n            // Build plain text from spans\n            let plainText = spans.map { $0.text }.joined()\n            let normalizedText = normalizeWhitespace(plainText)\n            \n            guard !normalizedText.isEmpty else { continue }\n            \n            // Normalize spans' text as well\n            let normalizedSpans = normalizeSpans(spans)\n            \n            paragraphs.append(ExtractedParagraph(\n                text: normalizedText,\n                isHeading: isHeading,\n                headingLevel: headingLevel,\n                isBlockquote: isBlockquote,\n                isListItem: isListItem,\n                listItemLevel: isListItem ? 1 : 0,\n                formattedSpans: normalizedSpans\n            ))\n        }\n        \n        return paragraphs\n    }\n    \n    /// Normalize spans by cleaning up whitespace\n    private func normalizeSpans(_ spans: [FormattedSpan]) -> [FormattedSpan] {\n        var result: [FormattedSpan] = []\n        \n        for span in spans {\n            let normalized = normalizeWhitespace(span.text)\n            if !normalized.isEmpty {\n                if let last = result.last, last.style == span.style {\n                    // Merge with previous span\n                    result[result.count - 1] = FormattedSpan(\n                        text: last.text + \" \" + normalized,\n                        style: span.style\n                    )\n                } else {\n                    result.append(FormattedSpan(text: normalized, style: span.style))\n                }\n            }\n        }\n        \n        return result\n    }\n    \n    /// Normalize whitespace: collapse multiple spaces/newlines into single space\n    private func normalizeWhitespace(_ text: String) -> String {\n        var result = text\n        \n        // Replace all whitespace sequences (including newlines) with single space\n        result = result.replacingOccurrences(\n            of: #\"[\\s\\n\\r\\t]+\"#,\n            with: \" \",\n            options: .regularExpression\n        )\n        \n        return result.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n    \n    // MARK: - Title Extraction\n    \n    func extractTitle(from html: String) -> String? {\n        // Try h1 first, then h2, then title tag\n        let patterns = [\n            #\"<h1[^>]*>([^<]+)</h1>\"#,\n            #\"<h2[^>]*>([^<]+)</h2>\"#,\n            #\"<title[^>]*>([^<]+)</title>\"#\n        ]\n        \n        for pattern in patterns {\n            if let regex = try? NSRegularExpression(pattern: pattern, options: .caseInsensitive),\n               let match = regex.firstMatch(in: html, options: [], range: NSRange(html.startIndex..., in: html)),\n               match.numberOfRanges >= 2,\n               let range = Range(match.range(at: 1), in: html) {\n                let title = String(html[range]).trimmingCharacters(in: .whitespacesAndNewlines)\n                if !title.isEmpty {\n                    return decodeHTMLEntities(title)\n                }\n            }\n        }\n        \n        return nil\n    }\n}\n", "metadata": {"file_path": "Core/BookParser/ContentExtractor.swift", "file_extension": ".swift", "file_name": "ContentExtractor.swift", "file_size": 21723, "last_modified": 1766184032.1968997}}
{"id": "16", "text": "import Foundation\nimport CoreData\n\nclass BookStorage {\n    static let shared = BookStorage()\n    \n    private var context: NSManagedObjectContext?\n    \n    private init() {}\n    \n    func setContext(_ context: NSManagedObjectContext) {\n        self.context = context\n    }\n    \n    func getContext() throws -> NSManagedObjectContext {\n        guard let context = context else {\n            throw BookStorageError.noContext\n        }\n        return context\n    }\n    \n    // MARK: - Import\n    \n    func importBook(at url: URL) async throws -> BookItem {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        // Start accessing security-scoped resource (required for fileImporter URLs)\n        // This must be done outside of context.perform to avoid concurrency issues\n        let isAccessing = url.startAccessingSecurityScopedResource()\n        defer {\n            if isAccessing {\n                url.stopAccessingSecurityScopedResource()\n            }\n        }\n        \n        // Perform file operations outside of Core Data context\n        let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]\n        let booksURL = documentsURL.appendingPathComponent(\"Books\", isDirectory: true)\n        \n        // Create directory if needed (using async-safe operation)\n        try? FileManager.default.createDirectory(at: booksURL, withIntermediateDirectories: true)\n        \n        let fileName = url.lastPathComponent\n        let destinationURL = booksURL.appendingPathComponent(fileName)\n        \n        // Remove existing file if present\n        try? FileManager.default.removeItem(at: destinationURL)\n        \n        // Copy the file (now that we have security-scoped access)\n        try FileManager.default.copyItem(at: url, to: destinationURL)\n        \n        // Verify the file was copied successfully\n        guard FileManager.default.fileExists(atPath: destinationURL.path) else {\n            throw BookStorageError.importFailed\n        }\n        \n        // Parse metadata (basic - will be enhanced by parsers)\n        let title = url.deletingPathExtension().lastPathComponent\n        \n        // Now perform Core Data operations in the proper context\n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    // Create Core Data entity\n                    let entity = BookEntity(context: context)\n                    let bookId = UUID()\n                    entity.id = bookId\n                    entity.title = title\n                    entity.author = nil // Will be set by parser\n                    entity.filePath = destinationURL.path\n                    entity.createdAt = Date()\n                    entity.lastOpened = Date()\n                    entity.lastPosition = 0\n                    \n                    try context.save()\n                    \n                    // Validate entity was created correctly\n                    guard entity.id == bookId, let savedTitle = entity.title else {\n                        context.delete(entity)\n                        continuation.resume(throwing: BookStorageError.importFailed)\n                        return\n                    }\n                    \n                    let bookItem = BookItem(\n                        id: bookId,\n                        title: savedTitle,\n                        author: entity.author,\n                        filePath: destinationURL.path,\n                        lastOpened: entity.lastOpened,\n                        lastPosition: Int(entity.lastPosition)\n                    )\n                    \n                    continuation.resume(returning: bookItem)\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    // MARK: - Fetch\n    \n    func fetchBooks(sortBy: LibraryViewModel.SortOption, searchQuery: String?) async throws -> [BookItem] {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    \n                    if let query = searchQuery, !query.isEmpty {\n                        let titlePredicate = NSPredicate(format: \"title CONTAINS[cd] %@\", query)\n                        let authorPredicate = NSPredicate(format: \"author CONTAINS[cd] %@\", query)\n                        request.predicate = NSCompoundPredicate(orPredicateWithSubpredicates: [titlePredicate, authorPredicate])\n                    }\n                    \n                    switch sortBy {\n                    case .lastOpened:\n                        request.sortDescriptors = [NSSortDescriptor(key: \"lastOpened\", ascending: false)]\n                    case .title:\n                        request.sortDescriptors = [NSSortDescriptor(key: \"title\", ascending: true)]\n                    case .author:\n                        request.sortDescriptors = [NSSortDescriptor(key: \"author\", ascending: true)]\n                    }\n                    \n                    let entities = try context.fetch(request)\n                    let books = entities.compactMap { entity -> BookItem? in\n                        guard let id = entity.id, let title = entity.title else { return nil }\n                        return BookItem(\n                            id: id,\n                            title: title,\n                            author: entity.author,\n                            filePath: entity.filePath ?? \"\",\n                            lastOpened: entity.lastOpened,\n                            lastPosition: Int(entity.lastPosition)\n                        )\n                    }\n                    \n                    continuation.resume(returning: books)\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    // MARK: - Reading Position\n    \n    func updateReadingPosition(bookId: UUID, position: Int) async throws {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", bookId as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    if let entity = try context.fetch(request).first {\n                        entity.lastPosition = Int32(position)\n                        entity.lastOpened = Date()\n                        try context.save()\n                    }\n                    \n                    continuation.resume()\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    // MARK: - Bookmarks\n    \n    func addBookmark(bookId: UUID, position: Int, label: String, snippet: String) async throws -> Bookmark {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", bookId as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    guard let bookEntity = try context.fetch(request).first else {\n                        continuation.resume(throwing: BookStorageError.bookNotFound)\n                        return\n                    }\n                    \n                    let bookmarkEntity = BookmarkEntity(context: context)\n                    bookmarkEntity.id = UUID()\n                    bookmarkEntity.position = Int32(position)\n                    bookmarkEntity.label = label\n                    bookmarkEntity.snippet = snippet\n                    bookmarkEntity.createdAt = Date()\n                    bookmarkEntity.book = bookEntity\n                    \n                    try context.save()\n                    \n                    let bookmark = Bookmark(\n                        id: bookmarkEntity.id!,\n                        bookId: bookId,\n                        position: position,\n                        label: label,\n                        snippet: snippet,\n                        createdAt: bookmarkEntity.createdAt ?? Date()\n                    )\n                    \n                    continuation.resume(returning: bookmark)\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    func getBookmarks(bookId: UUID) async throws -> [Bookmark] {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookmarkEntity> = BookmarkEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"book.id == %@\", bookId as CVarArg)\n                    request.sortDescriptors = [NSSortDescriptor(key: \"position\", ascending: true)]\n                    \n                    let entities = try context.fetch(request)\n                    let bookmarks = entities.compactMap { entity -> Bookmark? in\n                        guard let id = entity.id else { return nil }\n                        return Bookmark(\n                            id: id,\n                            bookId: bookId,\n                            position: Int(entity.position),\n                            label: entity.label ?? \"Bookmark\",\n                            snippet: entity.snippet ?? \"\",\n                            createdAt: entity.createdAt ?? Date()\n                        )\n                    }\n                    \n                    continuation.resume(returning: bookmarks)\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    func deleteBookmark(bookmarkId: UUID) async throws {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookmarkEntity> = BookmarkEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", bookmarkId as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    if let entity = try context.fetch(request).first {\n                        context.delete(entity)\n                        try context.save()\n                    }\n                    \n                    continuation.resume()\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    // MARK: - Delete\n    \n    func deleteBook(bookId: UUID) async throws {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", bookId as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    guard let entity = try context.fetch(request).first else {\n                        continuation.resume(throwing: BookStorageError.bookNotFound)\n                        return\n                    }\n                    \n                    // Get file path before deleting entity\n                    let filePath = entity.filePath\n                    \n                    // Delete Core Data entity (bookmarks cascade automatically per model)\n                    context.delete(entity)\n                    try context.save()\n                    \n                    // Delete physical file from disk\n                    if let filePath = filePath, !filePath.isEmpty {\n                        let fileURL = URL(fileURLWithPath: filePath)\n                        try? FileManager.default.removeItem(at: fileURL)\n                    }\n                    \n                    continuation.resume()\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    // MARK: - Book Retrieval\n    \n    func getBook(byId id: UUID) async throws -> BookItem? {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", id as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    if let entity = try context.fetch(request).first,\n                       let entityId = entity.id,\n                       let title = entity.title {\n                        let book = BookItem(\n                            id: entityId,\n                            title: title,\n                            author: entity.author,\n                            filePath: entity.filePath ?? \"\",\n                            lastOpened: entity.lastOpened,\n                            lastPosition: Int(entity.lastPosition)\n                        )\n                        continuation.resume(returning: book)\n                    } else {\n                        continuation.resume(returning: nil)\n                    }\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n\nenum BookStorageError: Error {\n    case noContext\n    case bookNotFound\n    case importFailed\n}\n\n\n", "metadata": {"file_path": "Core/BookStorage/BookStorage.swift", "file_extension": ".swift", "file_name": "BookStorage.swift", "file_size": 14678, "last_modified": 1766184032.1966126}}
{"id": "17", "text": "import Foundation\nimport CoreData\n\nextension BookStorage {\n    /// Update book metadata after parsing\n    func updateBookMetadata(bookId: UUID, title: String, author: String?) async throws {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", bookId as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    if let entity = try context.fetch(request).first {\n                        entity.title = title\n                        entity.author = author\n                        try context.save()\n                    }\n                    \n                    continuation.resume()\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n    \n    /// Update book file path (useful when app is reinstalled and Documents directory changes)\n    func updateBookFilePath(bookId: UUID, newFilePath: String) async throws {\n        guard let context = try? getContext() else {\n            throw BookStorageError.noContext\n        }\n        \n        return try await withCheckedThrowingContinuation { continuation in\n            context.perform {\n                do {\n                    let request: NSFetchRequest<BookEntity> = BookEntity.fetchRequest()\n                    request.predicate = NSPredicate(format: \"id == %@\", bookId as CVarArg)\n                    request.fetchLimit = 1\n                    \n                    if let entity = try context.fetch(request).first {\n                        entity.filePath = newFilePath\n                        try context.save()\n                    }\n                    \n                    continuation.resume()\n                } catch {\n                    continuation.resume(throwing: error)\n                }\n            }\n        }\n    }\n}\n\n\n", "metadata": {"file_path": "Core/BookStorage/BookStorage+Extensions.swift", "file_extension": ".swift", "file_name": "BookStorage+Extensions.swift", "file_size": 2151, "last_modified": 1766184032.1965933}}
{"id": "18", "text": "{\n  \"images\" : [\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"dark\"\n        }\n      ],\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"appearances\" : [\n        {\n          \"appearance\" : \"luminosity\",\n          \"value\" : \"tinted\"\n        }\n      ],\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"universal\",\n      \"platform\" : \"ios\",\n      \"size\" : \"1024x1024\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"16x16\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"16x16\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"32x32\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"32x32\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"128x128\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"128x128\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"256x256\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"256x256\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"1x\",\n      \"size\" : \"512x512\"\n    },\n    {\n      \"filename\" : \"AppIcon.png\",\n      \"idiom\" : \"mac\",\n      \"scale\" : \"2x\",\n      \"size\" : \"512x512\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n", "metadata": {"file_path": "Assets.xcassets/AppIcon.appiconset/Contents.json", "file_extension": ".json", "file_name": "Contents.json", "file_size": 1871, "last_modified": 1766184032.1968298}}
{"id": "19", "text": "{\n  \"colors\" : [\n    {\n      \"idiom\" : \"universal\"\n    }\n  ],\n  \"info\" : {\n    \"author\" : \"xcode\",\n    \"version\" : 1\n  }\n}\n", "metadata": {"file_path": "Assets.xcassets/AccentColor.colorset/Contents.json", "file_extension": ".json", "file_name": "Contents.json", "file_size": 123, "last_modified": 1765400124.3876474}}
{"id": "20", "text": "import SwiftUI\n\n/// Table of Contents sheet for navigating chapters\nstruct TOCSheet: View {\n    let tableOfContents: [TOCEntry]\n    let currentChapterIndex: Int?\n    let onSelect: (TOCEntry) -> Void\n    \n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationStack {\n            Group {\n                if tableOfContents.isEmpty {\n                    ContentUnavailableView(\n                        \"No Table of Contents\",\n                        systemImage: \"list.bullet\",\n                        description: Text(\"This book doesn't have navigation data\")\n                    )\n                } else {\n                    List {\n                        ForEach(tableOfContents) { entry in\n                            TOCEntryRow(\n                                entry: entry,\n                                isCurrentChapter: entry.chapterIndex == currentChapterIndex,\n                                onSelect: {\n                                    onSelect(entry)\n                                    dismiss()\n                                }\n                            )\n                        }\n                    }\n                    .listStyle(.plain)\n                }\n            }\n            .navigationTitle(\"Contents\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\n// MARK: - TOC Entry Row\n\nprivate struct TOCEntryRow: View {\n    let entry: TOCEntry\n    let isCurrentChapter: Bool\n    let onSelect: () -> Void\n    \n    var body: some View {\n        Button(action: onSelect) {\n            HStack(spacing: 12) {\n                // Indent based on depth\n                if entry.depth > 0 {\n                    Spacer()\n                        .frame(width: CGFloat(entry.depth) * 16)\n                }\n                \n                VStack(alignment: .leading, spacing: 2) {\n                    Text(entry.title)\n                        .font(entry.depth == 0 ? .body : .subheadline)\n                        .fontWeight(isCurrentChapter ? .semibold : .regular)\n                        .foregroundColor(isCurrentChapter ? .accentColor : .primary)\n                        .lineLimit(2)\n                    \n                    if entry.chapterIndex >= 0 {\n                        Text(\"Chapter \\(entry.chapterIndex + 1)\")\n                            .font(.caption)\n                            .foregroundColor(.secondary)\n                    }\n                }\n                \n                Spacer()\n                \n                if isCurrentChapter {\n                    Image(systemName: \"bookmark.fill\")\n                        .font(.caption)\n                        .foregroundColor(.accentColor)\n                }\n            }\n            .contentShape(Rectangle())\n            .padding(.vertical, 4)\n        }\n        .buttonStyle(.plain)\n    }\n}\n\n// MARK: - Preview\n\n#Preview {\n    TOCSheet(\n        tableOfContents: [\n            TOCEntry(title: \"Introduction\", chapterIndex: 0, href: \"intro.xhtml\"),\n            TOCEntry(title: \"Chapter 1: The Beginning\", chapterIndex: 1, href: \"ch01.xhtml\"),\n            TOCEntry(title: \"Chapter 2: The Journey\", chapterIndex: 2, href: \"ch02.xhtml\"),\n            TOCEntry(title: \"Chapter 3: The End\", chapterIndex: 3, href: \"ch03.xhtml\"),\n            TOCEntry(title: \"Epilogue\", chapterIndex: 4, href: \"epilogue.xhtml\")\n        ],\n        currentChapterIndex: 1,\n        onSelect: { _ in }\n    )\n}\n\n\n\n\n", "metadata": {"file_path": "Views/Reader/TOCSheet.swift", "file_extension": ".swift", "file_name": "TOCSheet.swift", "file_size": 3655, "last_modified": 1766184032.1966577}}
{"id": "21", "text": "import SwiftUI\n\nstruct ReaderSettingsMenu: View {\n    let isSpeaking: Bool\n    let onListen: () -> Void\n    let onStop: () -> Void\n    let onBookmark: () -> Void\n    let onShowBookmarks: () -> Void\n    let onShowVoiceSelection: () -> Void\n    @Binding var fontSize: CGFloat\n    @Binding var isMenuOpen: Bool\n    @Binding var readingMode: ReadingMode\n    \n    @State private var showReadingModeSubmenu: Bool = false\n    \n    var body: some View {\n        VStack(alignment: .trailing, spacing: 8) {\n            if isMenuOpen {\n                // Settings Panel\n                VStack(spacing: 12) {\n                    // Header\n                    HStack {\n                        if showReadingModeSubmenu {\n                            Button {\n                                withAnimation(.easeInOut(duration: 0.15)) {\n                                    showReadingModeSubmenu = false\n                                }\n                            } label: {\n                                Image(systemName: \"chevron.left\")\n                                    .font(.subheadline)\n                            }\n                        }\n                        Text(showReadingModeSubmenu ? \"Reading Mode\" : \"Settings\")\n                            .font(.headline)\n                        Spacer()\n                    }\n                    .padding(.bottom, 4)\n                    \n                    Divider()\n                    \n                    if showReadingModeSubmenu {\n                        // Reading Mode Submenu\n                        ForEach(ReadingMode.allCases, id: \\.self) { mode in\n                            ReadingModeOption(\n                                mode: mode,\n                                isSelected: readingMode == mode,\n                                onSelect: {\n                                    withAnimation(.easeInOut(duration: 0.15)) {\n                                        readingMode = mode\n                                        showReadingModeSubmenu = false\n                                    }\n                                }\n                            )\n                        }\n                    } else {\n                        // Main Settings\n                        \n                        // Reading Mode\n                        SettingsButton(\n                            title: \"Reading Mode\",\n                            icon: readingMode.icon,\n                            subtitle: readingMode.displayName,\n                            action: {\n                                withAnimation(.easeInOut(duration: 0.15)) {\n                                    showReadingModeSubmenu = true\n                                }\n                            }\n                        )\n                        \n                        Divider()\n                        \n                        // TTS Controls\n                        if isSpeaking {\n                            SettingsButton(\n                                title: \"Stop Reading\",\n                                icon: \"stop.circle.fill\",\n                                action: onStop\n                            )\n                        } else {\n                            SettingsButton(\n                                title: \"Start Reading\",\n                                icon: \"play.circle.fill\",\n                                action: onListen\n                            )\n                        }\n                        \n                        // Voice Selection\n                        SettingsButton(\n                            title: \"Voice\",\n                            icon: \"speaker.wave.2\",\n                            action: onShowVoiceSelection\n                        )\n                        \n                        Divider()\n                        \n                        // Text Size\n                        HStack {\n                            Image(systemName: \"textformat.size\")\n                                .frame(width: 24)\n                            Text(\"Text Size\")\n                            Spacer()\n                            \n                            Button {\n                                fontSize = max(12, fontSize - 2)\n                            } label: {\n                                Image(systemName: \"minus.circle.fill\")\n                                    .font(.title2)\n                            }\n                            \n                            Text(\"\\(Int(fontSize))\")\n                                .frame(width: 30)\n                                .font(.subheadline.monospacedDigit())\n                            \n                            Button {\n                                fontSize = min(28, fontSize + 2)\n                            } label: {\n                                Image(systemName: \"plus.circle.fill\")\n                                    .font(.title2)\n                            }\n                        }\n                        .foregroundColor(.primary)\n                        \n                        Divider()\n                        \n                        // Bookmarks\n                        SettingsButton(\n                            title: \"Add Bookmark\",\n                            icon: \"bookmark\",\n                            action: onBookmark\n                        )\n                        \n                        SettingsButton(\n                            title: \"Manage Bookmarks\",\n                            icon: \"bookmark.fill\",\n                            action: onShowBookmarks\n                        )\n                    }\n                }\n                .padding(16)\n                .background(Color(.systemBackground))\n                .cornerRadius(16)\n                .shadow(color: .black.opacity(0.2), radius: 8, x: 0, y: 4)\n                .frame(width: 260)\n                .transition(.scale(scale: 0.9, anchor: .bottomTrailing).combined(with: .opacity))\n            }\n            \n            // Toggle Button (gear when closed, X when open)\n            Button {\n                withAnimation(.easeInOut(duration: 0.2)) {\n                    isMenuOpen.toggle()\n                    if !isMenuOpen {\n                        showReadingModeSubmenu = false\n                    }\n                }\n            } label: {\n                Image(systemName: isMenuOpen ? \"xmark\" : \"gearshape.fill\")\n                    .font(.title2)\n                    .foregroundColor(.primary)\n                    .padding(12)\n                    .background(Color(.systemBackground))\n                    .clipShape(Circle())\n                    .shadow(color: .black.opacity(0.2), radius: 4, x: 0, y: 2)\n            }\n        }\n    }\n}\n\n// MARK: - Settings Button\n\nprivate struct SettingsButton: View {\n    let title: String\n    let icon: String\n    var subtitle: String? = nil\n    let action: () -> Void\n    \n    var body: some View {\n        Button(action: action) {\n            HStack {\n                Image(systemName: icon)\n                    .frame(width: 24)\n                Text(title)\n                Spacer()\n                if let subtitle = subtitle {\n                    Text(subtitle)\n                        .font(.subheadline)\n                        .foregroundColor(.secondary)\n                }\n                Image(systemName: \"chevron.right\")\n                    .font(.caption)\n                    .foregroundColor(.secondary)\n            }\n            .foregroundColor(.primary)\n            .padding(.vertical, 6)\n        }\n        .buttonStyle(.plain)\n    }\n}\n\n// MARK: - Reading Mode Option\n\nprivate struct ReadingModeOption: View {\n    let mode: ReadingMode\n    let isSelected: Bool\n    let onSelect: () -> Void\n    \n    var body: some View {\n        Button(action: onSelect) {\n            HStack {\n                Image(systemName: mode.icon)\n                    .frame(width: 24)\n                Text(mode.displayName)\n                Spacer()\n                if isSelected {\n                    Image(systemName: \"checkmark\")\n                        .font(.subheadline.bold())\n                        .foregroundColor(.blue)\n                }\n            }\n            .foregroundColor(.primary)\n            .padding(.vertical, 8)\n        }\n        .buttonStyle(.plain)\n    }\n}\n\n#Preview {\n    ReaderSettingsMenu(\n        isSpeaking: false,\n        onListen: {},\n        onStop: {},\n        onBookmark: {},\n        onShowBookmarks: {},\n        onShowVoiceSelection: {},\n        fontSize: .constant(17),\n        isMenuOpen: .constant(true),\n        readingMode: .constant(.scroll)\n    )\n}\n", "metadata": {"file_path": "Views/Reader/ReaderSettingsMenu.swift", "file_extension": ".swift", "file_name": "ReaderSettingsMenu.swift", "file_size": 8603, "last_modified": 1766184032.196907}}
{"id": "22", "text": "import SwiftUI\n\n/// Search sheet for finding text within the document\nstruct SearchView: View {\n    let document: DocumentModel\n    let onSelect: (SearchResult) -> Void\n    \n    @Environment(\\.dismiss) private var dismiss\n    @State private var searchQuery: String = \"\"\n    @State private var results: [SearchResult] = []\n    @State private var isSearching: Bool = false\n    @State private var hasSearched: Bool = false\n    @FocusState private var isSearchFocused: Bool\n    \n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 0) {\n                // Search bar with button\n                HStack(spacing: 12) {\n                    Image(systemName: \"magnifyingglass\")\n                        .foregroundColor(.secondary)\n                    \n                    TextField(\"Search in book...\", text: $searchQuery)\n                        .textFieldStyle(.plain)\n                        .autocorrectionDisabled()\n                        .textInputAutocapitalization(.never)\n                        .focused($isSearchFocused)\n                        .onSubmit {\n                            performSearch()\n                        }\n                    \n                    if !searchQuery.isEmpty {\n                        Button {\n                            searchQuery = \"\"\n                            results = []\n                            hasSearched = false\n                        } label: {\n                            Image(systemName: \"xmark.circle.fill\")\n                                .foregroundColor(.secondary)\n                        }\n                    }\n                    \n                    // Search button\n                    Button {\n                        performSearch()\n                    } label: {\n                        Text(\"Search\")\n                            .fontWeight(.medium)\n                            .foregroundColor(.white)\n                            .padding(.horizontal, 12)\n                            .padding(.vertical, 6)\n                            .background(searchQuery.count >= 2 ? Color.blue : Color.gray)\n                            .cornerRadius(8)\n                    }\n                    .disabled(searchQuery.count < 2 || isSearching)\n                }\n                .padding(.horizontal, 16)\n                .padding(.vertical, 12)\n                .background(Color(.secondarySystemBackground))\n                .cornerRadius(12)\n                .padding(.horizontal, 16)\n                .padding(.top, 8)\n                \n                // Results count\n                if hasSearched && !isSearching {\n                    HStack {\n                        Text(\"\\(results.count) result\\(results.count == 1 ? \"\" : \"s\")\")\n                            .font(.subheadline)\n                            .foregroundColor(.secondary)\n                        Spacer()\n                    }\n                    .padding(.horizontal, 16)\n                    .padding(.top, 12)\n                    .padding(.bottom, 4)\n                }\n                \n                // Results list\n                if isSearching {\n                    Spacer()\n                    ProgressView(\"Searching...\")\n                    Spacer()\n                } else if results.isEmpty && hasSearched {\n                    Spacer()\n                    VStack(spacing: 12) {\n                        Image(systemName: \"doc.text.magnifyingglass\")\n                            .font(.system(size: 48))\n                            .foregroundColor(.secondary)\n                        Text(\"No results found\")\n                            .font(.headline)\n                            .foregroundColor(.secondary)\n                        Text(\"Try a different search term\")\n                            .font(.subheadline)\n                            .foregroundColor(.secondary.opacity(0.7))\n                    }\n                    Spacer()\n                } else if results.isEmpty {\n                    Spacer()\n                    VStack(spacing: 12) {\n                        Image(systemName: \"magnifyingglass\")\n                            .font(.system(size: 48))\n                            .foregroundColor(.secondary)\n                        Text(\"Search for text\")\n                            .font(.headline)\n                            .foregroundColor(.secondary)\n                        Text(\"Enter a word or phrase and tap Search\")\n                            .font(.subheadline)\n                            .foregroundColor(.secondary.opacity(0.7))\n                            .multilineTextAlignment(.center)\n                    }\n                    .padding(.horizontal, 32)\n                    Spacer()\n                } else {\n                    List(results) { result in\n                        SearchResultRow(result: result, query: searchQuery)\n                            .contentShape(Rectangle())\n                            .onTapGesture {\n                                onSelect(result)\n                            }\n                            .listRowInsets(EdgeInsets(top: 12, leading: 16, bottom: 12, trailing: 16))\n                    }\n                    .listStyle(.plain)\n                }\n            }\n            .navigationTitle(\"Search\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n        .onAppear {\n            isSearchFocused = true\n        }\n    }\n    \n    private func performSearch() {\n        guard searchQuery.count >= 2 else { return }\n        \n        isSearching = true\n        hasSearched = true\n        \n        // Dismiss keyboard\n        isSearchFocused = false\n        \n        // Run search on background thread to keep UI responsive\n        Task {\n            let query = searchQuery // Capture current query\n            let searchResults = await Task.detached(priority: .userInitiated) {\n                return self.document.search(query: query)\n            }.value\n            \n            await MainActor.run {\n                results = searchResults\n                isSearching = false\n            }\n        }\n    }\n}\n\n// MARK: - Search Result Row\n\nprivate struct SearchResultRow: View {\n    let result: SearchResult\n    let query: String\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 6) {\n            // Chapter title\n            Text(result.chapterTitle)\n                .font(.caption)\n                .foregroundColor(.secondary)\n                .lineLimit(1)\n            \n            // Context with highlighted match\n            highlightedText\n                .font(.subheadline)\n                .lineLimit(3)\n        }\n    }\n    \n    private var highlightedText: Text {\n        let snippet = result.contextSnippet\n        let lowercaseSnippet = snippet.lowercased()\n        let lowercaseQuery = query.lowercased()\n        \n        // Find all occurrences of the query in the snippet\n        var text = Text(\"\")\n        var currentIndex = snippet.startIndex\n        \n        while let range = lowercaseSnippet.range(of: lowercaseQuery, range: currentIndex..<snippet.endIndex) {\n            // Add text before match\n            if currentIndex < range.lowerBound {\n                let beforeText = String(snippet[currentIndex..<range.lowerBound])\n                text = text + Text(beforeText).foregroundColor(.primary)\n            }\n            \n            // Add highlighted match (use original case from snippet)\n            let matchText = String(snippet[range])\n            text = text + Text(matchText)\n                .foregroundColor(.blue)\n                .bold()\n            \n            currentIndex = range.upperBound\n        }\n        \n        // Add remaining text after last match\n        if currentIndex < snippet.endIndex {\n            let remainingText = String(snippet[currentIndex..<snippet.endIndex])\n            text = text + Text(remainingText).foregroundColor(.primary)\n        }\n        \n        return text\n    }\n}\n\n#Preview {\n    SearchView(\n        document: DocumentModel(\n            title: \"Test Book\",\n            author: \"Test Author\",\n            chapters: [\n                Chapter(\n                    title: \"Chapter 1\",\n                    paragraphs: [\n                        Paragraph(sentences: [\n                            Sentence(text: \"This is a test sentence with some searchable content.\", globalIndex: 0, chapterIndex: 0, paragraphIndex: 0, sentenceIndex: 0),\n                            Sentence(text: \"Another sentence here for testing purposes.\", globalIndex: 1, chapterIndex: 0, paragraphIndex: 0, sentenceIndex: 1)\n                        ])\n                    ]\n                )\n            ],\n            tableOfContents: []\n        ),\n        onSelect: { _ in }\n    )\n}\n", "metadata": {"file_path": "Views/Reader/SearchView.swift", "file_extension": ".swift", "file_name": "SearchView.swift", "file_size": 8929, "last_modified": 1766184032.196865}}
{"id": "23", "text": "import SwiftUI\nimport AVFoundation\n\nstruct VoiceSelectionView: View {\n    @Binding var selectedVoiceIdentifier: String?\n    @Environment(\\.dismiss) private var dismiss\n    \n    let availableVoices: [AVSpeechSynthesisVoice]\n    \n    init(selectedVoiceIdentifier: Binding<String?>) {\n        self._selectedVoiceIdentifier = selectedVoiceIdentifier\n        self.availableVoices = AVSpeechSynthesisVoice.speechVoices().sorted { voice1, voice2 in\n            // Sort by quality (premium > enhanced > default), then by name\n            let qualityOrder: [AVSpeechSynthesisVoiceQuality: Int] = [\n                .premium: 0,\n                .enhanced: 1,\n                .default: 2\n            ]\n            let quality1 = qualityOrder[voice1.quality] ?? 3\n            let quality2 = qualityOrder[voice2.quality] ?? 3\n            \n            if quality1 != quality2 {\n                return quality1 < quality2\n            }\n            return voice1.name < voice2.name\n        }\n    }\n    \n    // Group voices by language\n    private var voicesByLanguage: [String: [AVSpeechSynthesisVoice]] {\n        Dictionary(grouping: availableVoices) { voice in\n            // Extract language code (e.g., \"en\" from \"en-AU\")\n            String(voice.language.prefix(2))\n        }\n    }\n    \n    private func qualityString(for voice: AVSpeechSynthesisVoice) -> String {\n        switch voice.quality {\n        case .premium: return \"Premium\"\n        case .enhanced: return \"Enhanced\"\n        case .default: return \"Default\"\n        @unknown default: return \"Unknown\"\n        }\n    }\n    \n    private func qualityColor(for voice: AVSpeechSynthesisVoice) -> Color {\n        switch voice.quality {\n        case .premium: return .green\n        case .enhanced: return .blue\n        case .default: return .gray\n        @unknown default: return .gray\n        }\n    }\n    \n    var body: some View {\n        NavigationStack {\n            List {\n                ForEach(Array(voicesByLanguage.keys.sorted()), id: \\.self) { languageCode in\n                    Section(header: Text(languageCode.uppercased())) {\n                        ForEach(voicesByLanguage[languageCode] ?? [], id: \\.identifier) { voice in\n                            Button {\n                                selectedVoiceIdentifier = voice.identifier\n                                dismiss()\n                            } label: {\n                                HStack {\n                                    VStack(alignment: .leading, spacing: 4) {\n                                        Text(voice.name)\n                                            .foregroundColor(.primary)\n                                            .font(.headline)\n                                        \n                                        HStack(spacing: 8) {\n                                            Text(voice.language)\n                                                .font(.caption)\n                                                .foregroundColor(.secondary)\n                                            \n                                            Text(\"‚Ä¢\")\n                                                .foregroundColor(.secondary)\n                                            \n                                            Text(qualityString(for: voice))\n                                                .font(.caption)\n                                                .foregroundColor(qualityColor(for: voice))\n                                                .fontWeight(.medium)\n                                        }\n                                    }\n                                    \n                                    Spacer()\n                                    \n                                    if selectedVoiceIdentifier == voice.identifier {\n                                        Image(systemName: \"checkmark.circle.fill\")\n                                            .foregroundColor(.blue)\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"Select Voice\")\n            .navigationBarTitleDisplayMode(.inline)\n            .toolbar {\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button(\"Done\") {\n                        dismiss()\n                    }\n                }\n            }\n        }\n    }\n}\n\n#Preview {\n    VoiceSelectionView(selectedVoiceIdentifier: .constant(nil))\n}\n\n\n\n\n\n", "metadata": {"file_path": "Views/Reader/VoiceSelectionView.swift", "file_extension": ".swift", "file_name": "VoiceSelectionView.swift", "file_size": 4541, "last_modified": 1766184032.1966548}}
{"id": "24", "text": "import SwiftUI\n\n/// Page-based reader view with tap navigation and smooth fade transitions\nstruct PagedReaderView: View {\n    let document: DocumentModel\n    let currentIndex: Int\n    let ttsIndex: Int?\n    let fontSize: CGFloat\n    let showReadingIndicators: Bool\n    let bookmarks: [Bookmark]\n    let onIndexChanged: (Int) -> Void\n    var onTap: (() -> Void)? = nil\n    @Binding var scrollToIndex: Int?\n    \n    @State private var currentPage: Int = 0\n    @State private var pages: [[PageContent]] = []\n    @State private var isTransitioning: Bool = false\n    @State private var pageOpacity: Double = 1.0\n    @State private var containerSize: CGSize = .zero\n    \n    private let horizontalPadding: CGFloat = 20\n    private let verticalPadding: CGFloat = 60\n    private let lineSpacing: CGFloat = 8\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ZStack {\n                // Page content with fade transition\n                if !pages.isEmpty && currentPage < pages.count {\n                    PageContentView(\n                        content: pages[currentPage],\n                        fontSize: fontSize,\n                        ttsIndex: ttsIndex,\n                        bookmarks: bookmarks\n                    )\n                    .padding(.horizontal, horizontalPadding)\n                    .padding(.vertical, verticalPadding)\n                    .opacity(pageOpacity)\n                }\n                \n                // Tap zones overlay with safe zones at top/bottom for menu access\n                VStack(spacing: 0) {\n                    // Top safe zone - tap to show menu\n                    Color.clear\n                        .frame(height: 60)\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            onTap?()\n                        }\n                    \n                    // Page turn zones (middle area)\n                    HStack(spacing: 0) {\n                        // Left tap zone - previous page\n                        Color.clear\n                            .contentShape(Rectangle())\n                            .onTapGesture {\n                                handleTap(direction: .previous)\n                            }\n                        \n                        // Right tap zone - next page\n                        Color.clear\n                            .contentShape(Rectangle())\n                            .onTapGesture {\n                                handleTap(direction: .next)\n                            }\n                    }\n                    \n                    // Bottom safe zone - tap to show menu\n                    Color.clear\n                        .frame(height: 60)\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            onTap?()\n                        }\n                }\n                \n                // Page indicator\n                if showReadingIndicators {\n                    VStack {\n                        Spacer()\n                        HStack {\n                            Spacer()\n                            Text(\"\\(currentPage + 1) / \\(max(1, pages.count))\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                                .padding(.horizontal, 12)\n                                .padding(.vertical, 6)\n                                .background(Color(.systemBackground).opacity(0.9))\n                                .cornerRadius(12)\n                            Spacer()\n                        }\n                        .padding(.bottom, 16)\n                    }\n                }\n            }\n            .background(Color(.systemBackground))\n            .onAppear {\n                containerSize = geometry.size\n                calculatePages(for: geometry.size)\n                jumpToCurrentIndex()\n            }\n            .onChange(of: geometry.size) { _, newSize in\n                containerSize = newSize\n                calculatePages(for: newSize)\n            }\n            .onChange(of: fontSize) { _, _ in\n                calculatePages(for: containerSize)\n            }\n            .onChange(of: scrollToIndex) { _, newIndex in\n                if let index = newIndex {\n                    jumpToPage(containing: index)\n                    DispatchQueue.main.async {\n                        scrollToIndex = nil\n                    }\n                }\n            }\n            .onChange(of: ttsIndex) { _, newIndex in\n                if let index = newIndex {\n                    jumpToPage(containing: index)\n                }\n            }\n        }\n    }\n    \n    // MARK: - Page Navigation\n    \n    private enum TapDirection {\n        case previous, next\n    }\n    \n    private func handleTap(direction: TapDirection) {\n        guard !isTransitioning else { return }\n        \n        switch direction {\n        case .previous:\n            if currentPage > 0 {\n                transitionToPage(currentPage - 1)\n            } else {\n                onTap?()\n            }\n        case .next:\n            if currentPage < pages.count - 1 {\n                transitionToPage(currentPage + 1)\n            } else {\n                onTap?()\n            }\n        }\n    }\n    \n    private func transitionToPage(_ newPage: Int) {\n        guard newPage >= 0 && newPage < pages.count else { return }\n        \n        isTransitioning = true\n        \n        // Fade out\n        withAnimation(.easeOut(duration: 0.1)) {\n            pageOpacity = 0\n        }\n        \n        // Change page and fade in\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n            currentPage = newPage\n            \n            // Update reading index to first sentence on new page\n            if let firstContent = pages[newPage].first {\n                onIndexChanged(firstContent.globalIndex)\n            }\n            \n            withAnimation(.easeIn(duration: 0.1)) {\n                pageOpacity = 1\n            }\n            \n            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                isTransitioning = false\n            }\n        }\n    }\n    \n    private func jumpToPage(containing globalIndex: Int) {\n        for (pageIndex, pageContents) in pages.enumerated() {\n            for content in pageContents {\n                if content.globalIndex == globalIndex ||\n                   (content.sentenceRange.contains(globalIndex)) {\n                    if pageIndex != currentPage {\n                        transitionToPage(pageIndex)\n                    }\n                    return\n                }\n            }\n        }\n    }\n    \n    private func jumpToCurrentIndex() {\n        jumpToPage(containing: currentIndex)\n    }\n    \n    // MARK: - Page Calculation\n    \n    private func calculatePages(for size: CGSize) {\n        let availableWidth = size.width - (horizontalPadding * 2)\n        let availableHeight = size.height - (verticalPadding * 2)\n        \n        guard availableWidth > 0 && availableHeight > 0 else { return }\n        \n        var newPages: [[PageContent]] = []\n        var currentPageContent: [PageContent] = []\n        var currentHeight: CGFloat = 0\n        \n        let font = UIFont.systemFont(ofSize: fontSize)\n        let lineHeight = font.lineHeight + lineSpacing\n        \n        for chapter in document.chapters {\n            // Add chapter title if present\n            if let title = chapter.title {\n                let titleHeight = estimateTextHeight(\n                    title,\n                    width: availableWidth,\n                    font: UIFont.boldSystemFont(ofSize: fontSize + 4)\n                ) + 24 // Extra padding for chapter title\n                \n                if currentHeight + titleHeight > availableHeight && !currentPageContent.isEmpty {\n                    newPages.append(currentPageContent)\n                    currentPageContent = []\n                    currentHeight = 0\n                }\n                \n                // Chapter titles don't have a globalIndex, use -1 as marker\n                currentPageContent.append(PageContent(\n                    text: title,\n                    globalIndex: -1,\n                    sentenceRange: -1..<0,\n                    isChapterTitle: true\n                ))\n                currentHeight += titleHeight\n            }\n            \n            // Add paragraphs\n            for paragraph in chapter.paragraphs {\n                let paragraphText = paragraph.sentences.map { $0.text }.joined(separator: \" \")\n                let paragraphHeight = estimateTextHeight(paragraphText, width: availableWidth, font: font) + 16\n                \n                // Check if paragraph fits on current page\n                if currentHeight + paragraphHeight > availableHeight && !currentPageContent.isEmpty {\n                    newPages.append(currentPageContent)\n                    currentPageContent = []\n                    currentHeight = 0\n                }\n                \n                let firstIndex = paragraph.sentences.first?.globalIndex ?? 0\n                let lastIndex = paragraph.sentences.last?.globalIndex ?? firstIndex\n                \n                currentPageContent.append(PageContent(\n                    text: paragraphText,\n                    globalIndex: firstIndex,\n                    sentenceRange: firstIndex..<(lastIndex + 1),\n                    isChapterTitle: false,\n                    sentences: paragraph.sentences\n                ))\n                currentHeight += paragraphHeight\n            }\n        }\n        \n        // Add remaining content\n        if !currentPageContent.isEmpty {\n            newPages.append(currentPageContent)\n        }\n        \n        pages = newPages\n    }\n    \n    private func estimateTextHeight(_ text: String, width: CGFloat, font: UIFont) -> CGFloat {\n        let constraintRect = CGSize(width: width, height: .greatestFiniteMagnitude)\n        let boundingBox = text.boundingRect(\n            with: constraintRect,\n            options: [.usesLineFragmentOrigin, .usesFontLeading],\n            attributes: [.font: font],\n            context: nil\n        )\n        return ceil(boundingBox.height)\n    }\n}\n\n// MARK: - Page Content Model\n\nstruct PageContent: Identifiable {\n    let id = UUID()\n    let text: String\n    let globalIndex: Int\n    let sentenceRange: Range<Int>\n    let isChapterTitle: Bool\n    var sentences: [Sentence] = []\n}\n\n// MARK: - Page Content View\n\nprivate struct PageContentView: View {\n    let content: [PageContent]\n    let fontSize: CGFloat\n    let ttsIndex: Int?\n    let bookmarks: [Bookmark]\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 16) {\n            ForEach(content) { item in\n                if item.isChapterTitle {\n                    Text(item.text)\n                        .font(.system(size: fontSize + 4, weight: .bold))\n                        .padding(.top, 8)\n                        .padding(.bottom, 4)\n                } else {\n                    PageParagraphView(\n                        item: item,\n                        fontSize: fontSize,\n                        ttsIndex: ttsIndex,\n                        bookmarks: bookmarks\n                    )\n                }\n            }\n            Spacer()\n        }\n    }\n}\n\n// MARK: - Page Paragraph View\n\nprivate struct PageParagraphView: View {\n    let item: PageContent\n    let fontSize: CGFloat\n    let ttsIndex: Int?\n    let bookmarks: [Bookmark]\n    \n    var body: some View {\n        HStack(alignment: .top, spacing: 4) {\n            // Always use attributed text for consistent formatting\n            Text(attributedText)\n                .font(.system(size: fontSize))\n                .lineSpacing(8)\n            \n            Spacer(minLength: 0)\n            \n            // Bookmark indicator\n            if hasBookmark {\n                Image(systemName: \"bookmark.fill\")\n                    .font(.system(size: 12))\n                    .foregroundColor(.red)\n                    .padding(.top, 2)\n            }\n        }\n    }\n    \n    private var hasBookmark: Bool {\n        item.sentences.contains { sentence in\n            bookmarks.contains { $0.position == sentence.globalIndex }\n        }\n    }\n    \n    private var attributedText: AttributedString {\n        var result = AttributedString()\n        \n        for (index, sentence) in item.sentences.enumerated() {\n            let isTTSHighlighted = ttsIndex != nil && sentence.globalIndex == ttsIndex\n            \n            // Build attributed string from formatted spans\n            for span in sentence.formattedSpans {\n                var spanAttr = AttributedString(span.text)\n                \n                // Apply TTS highlighting\n                if isTTSHighlighted {\n                    spanAttr.foregroundColor = .white\n                    spanAttr.backgroundColor = .blue\n                } else {\n                    spanAttr.foregroundColor = .primary\n                }\n                \n                // Apply formatting styles\n                if span.style.contains(.bold) {\n                    spanAttr.font = .system(size: fontSize, weight: .bold)\n                }\n                if span.style.contains(.italic) {\n                    spanAttr.font = .system(size: fontSize).italic()\n                }\n                if span.style.contains(.bold) && span.style.contains(.italic) {\n                    spanAttr.font = .system(size: fontSize, weight: .bold).italic()\n                }\n                if span.style.contains(.underline) {\n                    spanAttr.underlineStyle = .single\n                }\n                if span.style.contains(.strikethrough) {\n                    spanAttr.strikethroughStyle = .single\n                }\n                if span.style.contains(.code) {\n                    spanAttr.font = .system(size: fontSize - 1, design: .monospaced)\n                    if !isTTSHighlighted {\n                        spanAttr.backgroundColor = Color(.secondarySystemBackground)\n                    }\n                }\n                \n                result.append(spanAttr)\n            }\n            \n            if index < item.sentences.count - 1 {\n                result.append(AttributedString(\" \"))\n            }\n        }\n        \n        return result\n    }\n}\n\n#Preview {\n    PagedReaderView(\n        document: DocumentModel(\n            title: \"Test\",\n            author: nil,\n            chapters: [\n                Chapter(\n                    title: \"Chapter 1\",\n                    paragraphs: [\n                        Paragraph(sentences: [\n                            Sentence(text: \"This is a test sentence.\", globalIndex: 0, chapterIndex: 0, paragraphIndex: 0, sentenceIndex: 0),\n                            Sentence(text: \"This is another sentence.\", globalIndex: 1, chapterIndex: 0, paragraphIndex: 0, sentenceIndex: 1)\n                        ])\n                    ]\n                )\n            ],\n            tableOfContents: []\n        ),\n        currentIndex: 0,\n        ttsIndex: nil,\n        fontSize: 17,\n        showReadingIndicators: true,\n        bookmarks: [],\n        onIndexChanged: { _ in },\n        scrollToIndex: .constant(nil)\n    )\n}\n\n", "metadata": {"file_path": "Views/Reader/PagedReaderView.swift", "file_extension": ".swift", "file_name": "PagedReaderView.swift", "file_size": 15273, "last_modified": 1766184032.1968744}}
{"id": "25", "text": "import SwiftUI\n\nstruct ReaderView: View {\n    let book: BookItem\n    @StateObject private var viewModel = ReaderViewModel()\n    @StateObject private var preferences = ReadingPreferences.shared\n    @State private var fontSize: CGFloat = 17\n    @State private var showingBookmarks = false\n    @State private var showingVoiceSelection = false\n    @State private var showingTOC = false\n    @State private var showingSearch = false\n    @State private var ttsError: String?\n    @State private var isUIVisible: Bool = true\n    @State private var hideUITask: Task<Void, Never>?\n    @State private var readingStartY: CGFloat = 0\n    @State private var isSnapping: Bool = false\n    @State private var scrollToIndex: Int? = nil\n    @State private var isSettingsMenuOpen: Bool = false\n    @State private var readingMode: ReadingMode = .scroll\n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        ZStack {\n            if viewModel.isLoading {\n                ProgressView(\"Loading book...\")\n            } else if let error = viewModel.errorMessage {\n                VStack {\n                    Text(\"Error\")\n                        .font(.headline)\n                    Text(error)\n                        .font(.subheadline)\n                        .foregroundColor(.secondary)\n                    Button(\"Go Back\") {\n                        dismiss()\n                    }\n                }\n            } else if let document = viewModel.document {\n                GeometryReader { geometry in\n                    let calculatedReadingStartY = geometry.safeAreaInsets.top + (geometry.size.height * 0.15)\n                    \n                    ZStack(alignment: .bottom) {\n                        // Conditional reader view based on reading mode\n                        if readingMode == .pages {\n                            PagedReaderView(\n                                document: document,\n                                currentIndex: viewModel.currentReadingIndex,\n                                ttsIndex: viewModel.ttsController.isSpeaking ? viewModel.ttsController.currentSpokenIndex : nil,\n                                fontSize: fontSize,\n                                showReadingIndicators: isUIVisible,\n                                bookmarks: viewModel.bookmarks,\n                                onIndexChanged: { index in\n                                    viewModel.updateReadingIndex(index)\n                                },\n                                onTap: {\n                                    toggleUI()\n                                },\n                                scrollToIndex: $scrollToIndex\n                            )\n                            .frame(width: geometry.size.width, height: geometry.size.height)\n                        } else {\n                            HighlightedTextView(\n                                document: document,\n                                currentIndex: viewModel.currentReadingIndex,\n                                ttsIndex: viewModel.ttsController.isSpeaking ? viewModel.ttsController.currentSpokenIndex : nil,\n                                fontSize: fontSize,\n                                readingStartY: readingStartY == 0 ? calculatedReadingStartY : readingStartY,\n                                showReadingIndicators: isUIVisible,\n                                bookmarks: viewModel.bookmarks,\n                                onIndexChanged: { index in\n                                    viewModel.updateReadingIndex(index)\n                                },\n                                onScrollChanged: { offset in\n                                    showUI()\n                                    scheduleHideUI(delay: 1.5)\n                                },\n                                onScrollEnded: {\n                                    // Trigger snap when scroll ends\n                                },\n                                onSnapToPosition: { index in\n                                    viewModel.updateReadingIndex(index)\n                                },\n                                onTap: {\n                                    toggleUI()\n                                },\n                                scrollToIndex: $scrollToIndex\n                            )\n                            .frame(width: geometry.size.width, height: geometry.size.height)\n                        }\n                        \n                        // Update readingStartY on appear\n                        Color.clear\n                            .frame(width: 0, height: 0)\n                            .onAppear {\n                                if readingStartY == 0 {\n                                    readingStartY = calculatedReadingStartY\n                                }\n                            }\n                        \n                        // Settings menu (bottom right) - always show when menu is open OR UI is visible\n                        if isUIVisible || isSettingsMenuOpen {\n                            VStack {\n                                Spacer()\n                                HStack {\n                                    Spacer()\n                                    ReaderSettingsMenu(\n                                        isSpeaking: viewModel.ttsController.isSpeaking,\n                                        onListen: {\n                                            viewModel.startTTS(from: 0, viewportHeight: 0)\n                                        },\n                                        onStop: {\n                                            viewModel.stopTTS()\n                                        },\n                                        onBookmark: {\n                                            viewModel.addBookmark()\n                                        },\n                                        onShowBookmarks: {\n                                            showingBookmarks = true\n                                        },\n                                        onShowVoiceSelection: {\n                                            showingVoiceSelection = true\n                                        },\n                                        fontSize: $fontSize,\n                                        isMenuOpen: $isSettingsMenuOpen,\n                                        readingMode: $readingMode\n                                    )\n                                    .padding(.trailing, 16)\n                                    .padding(.bottom, 16)\n                                }\n                            }\n                        }\n                    }\n                }\n                .ignoresSafeArea(.all, edges: .all)\n            }\n        }\n        .frame(maxWidth: .infinity, maxHeight: .infinity)\n        .ignoresSafeArea(.all, edges: .all)\n        .navigationBarTitleDisplayMode(.inline)\n        .navigationBarBackButtonHidden(true)\n        .toolbar {\n            if isUIVisible {\n                ToolbarItem(placement: .navigationBarLeading) {\n                    Button {\n                        viewModel.stopTTS()\n                        dismiss()\n                    } label: {\n                        Image(systemName: \"chevron.left\")\n                            .font(.title3)\n                    }\n                }\n                \n                ToolbarItem(placement: .navigationBarTrailing) {\n                    HStack(spacing: 16) {\n                        // Search button\n                        Button {\n                            showingSearch = true\n                        } label: {\n                            Image(systemName: \"magnifyingglass\")\n                                .font(.title3)\n                        }\n                        \n                        // TOC button\n                        Button {\n                            showingTOC = true\n                        } label: {\n                            Image(systemName: \"list.bullet\")\n                                .font(.title3)\n                        }\n                        .disabled(viewModel.document?.tableOfContents.isEmpty ?? true)\n                    }\n                }\n            }\n        }\n        .toolbarBackground(.hidden, for: .navigationBar)\n        .onAppear {\n            viewModel.loadBook(book)\n            readingMode = preferences.readingMode\n        }\n        .onDisappear {\n            viewModel.stopTTS()\n            // Final persistence on disappear\n            Task {\n                try? await viewModel.persistReadingPosition()\n            }\n        }\n        .onChange(of: readingMode) { _, newMode in\n            preferences.readingMode = newMode\n        }\n        .sheet(isPresented: $showingBookmarks) {\n            BookmarkSheet(\n                bookmarks: viewModel.bookmarks,\n                onSelect: { bookmark in\n                    viewModel.jumpToBookmark(bookmark)\n                    scrollToIndex = bookmark.position\n                    showingBookmarks = false\n                },\n                onDelete: { bookmark in\n                    viewModel.deleteBookmark(bookmark)\n                }\n            )\n        }\n        .sheet(isPresented: $showingVoiceSelection) {\n            VoiceSelectionView(selectedVoiceIdentifier: Binding(\n                get: { viewModel.ttsController.selectedVoiceIdentifier },\n                set: { viewModel.ttsController.selectedVoiceIdentifier = $0 }\n            ))\n        }\n        .sheet(isPresented: $showingTOC) {\n            if let document = viewModel.document {\n                TOCSheet(\n                    tableOfContents: document.tableOfContents,\n                    currentChapterIndex: document.chapterIndex(for: viewModel.currentReadingIndex),\n                    onSelect: { entry in\n                        // Navigate to chapter\n                        if let firstIndex = document.firstSentenceIndex(for: entry.chapterIndex) {\n                            viewModel.updateReadingIndex(firstIndex)\n                            scrollToIndex = firstIndex\n                        }\n                    }\n                )\n            }\n        }\n        .sheet(isPresented: $showingSearch) {\n            if let document = viewModel.document {\n                SearchView(\n                    document: document,\n                    onSelect: { result in\n                        viewModel.updateReadingIndex(result.globalIndex)\n                        scrollToIndex = result.globalIndex\n                        showingSearch = false\n                    }\n                )\n            }\n        }\n        .alert(\"Text-to-Speech Error\", isPresented: Binding(\n            get: { ttsError != nil },\n            set: { if !$0 { ttsError = nil } }\n        )) {\n            Button(\"OK\") {\n                ttsError = nil\n            }\n            Button(\"Open Settings\") {\n                if let settingsURL = URL(string: UIApplication.openSettingsURLString) {\n                    UIApplication.shared.open(settingsURL)\n                }\n                ttsError = nil\n            }\n        } message: {\n            if let error = ttsError {\n                Text(error)\n            }\n        }\n        .onChange(of: viewModel.errorMessage) { oldValue, newValue in\n            if let error = newValue, error.contains(\"Premium voice\") || error.contains(\"text-to-speech\") {\n                ttsError = error\n            }\n        }\n        .onAppear {\n            // Auto-hide UI after 3 seconds on appear\n            scheduleHideUI(delay: 3.0)\n        }\n    }\n    \n    private func showUI() {\n        isUIVisible = true\n        cancelHideUITask()\n    }\n    \n    private func toggleUI() {\n        isUIVisible.toggle()\n        if isUIVisible {\n            scheduleHideUI()\n        } else {\n            cancelHideUITask()\n        }\n    }\n    \n    private func scheduleHideUI(delay: Double = 2.0) {\n        // Don't auto-hide if settings menu is open\n        guard !isSettingsMenuOpen else { return }\n        \n        cancelHideUITask()\n        hideUITask = Task {\n            try? await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))\n            if !Task.isCancelled {\n                await MainActor.run {\n                    // Double-check menu isn't open before hiding\n                    if !isSettingsMenuOpen {\n                        isUIVisible = false\n                    }\n                }\n            }\n        }\n    }\n    \n    private func cancelHideUITask() {\n        hideUITask?.cancel()\n        hideUITask = nil\n    }\n}\n\n#Preview {\n    NavigationStack {\n        ReaderView(book: BookItem(\n            id: UUID(),\n            title: \"Sample Book\",\n            author: \"Sample Author\",\n            filePath: \"\",\n            lastOpened: Date(),\n            lastPosition: 0\n        ))\n    }\n}\n", "metadata": {"file_path": "Views/Reader/ReaderView.swift", "file_extension": ".swift", "file_name": "ReaderView.swift", "file_size": 12834, "last_modified": 1766184032.1967845}}
{"id": "26", "text": "import SwiftUI\n\nstruct HighlightedTextView: View {\n    let document: DocumentModel\n    let currentIndex: Int\n    let ttsIndex: Int?\n    let fontSize: CGFloat\n    let readingStartY: CGFloat\n    let showReadingIndicators: Bool\n    let bookmarks: [Bookmark]\n    let onIndexChanged: (Int) -> Void\n    var onScrollChanged: ((CGFloat) -> Void)? = nil\n    var onScrollEnded: (() -> Void)? = nil\n    var onSnapToPosition: ((Int) -> Void)? = nil\n    var onTap: (() -> Void)? = nil\n    @Binding var scrollToIndex: Int?\n    \n    @State private var visibleChapterRange: Range<Int> = 0..<1\n    @State private var scrollOffset: CGFloat = 0\n    @State private var lastScrollChangeTime: Date = Date()\n    @State private var scrollEndTask: Task<Void, Never>?\n    @State private var isSnapping: Bool = false\n    @State private var sentencePositions: [Int: CGFloat] = [:] // globalIndex -> Y position in scroll space\n    \n    private var visibleChapterIndices: Range<Int> {\n        let startChapter = max(0, visibleChapterRange.lowerBound - 2)\n        let endChapter = min(document.chapters.count, visibleChapterRange.upperBound + 3)\n        return startChapter..<endChapter\n    }\n    \n    var body: some View {\n        GeometryReader { geometry in\n            ScrollViewReader { proxy in\n                ScrollView {\n                    LazyVStack(alignment: .leading, spacing: 20) {\n                        // Scroll tracking anchor\n                        GeometryReader { scrollGeometry in\n                            Color.clear\n                                .preference(key: ScrollOffsetPreferenceKey.self, value: -scrollGeometry.frame(in: .named(\"scroll\")).minY)\n                        }\n                        .frame(height: 0)\n                        \n                        // Top spacer for safe area\n                        Color.clear\n                            .frame(height: geometry.safeAreaInsets.top + 16)\n                            .id(\"topSpacer\")\n                        \n                        // Render chapters with paragraph-based approach\n                        ForEach(visibleChapterIndices, id: \\.self) { chapterIndex in\n                            ChapterView(\n                                chapter: document.chapters[chapterIndex],\n                                chapterIndex: chapterIndex,\n                                fontSize: fontSize,\n                                ttsIndex: ttsIndex,\n                                bookmarks: bookmarks,\n                                globalIndexOffset: document.globalIndexOffset(for: chapterIndex),\n                                onParagraphAppear: { paraIndex, firstSentenceIndex in\n                                    updateVisibleChapterRange(for: chapterIndex)\n                                },\n                                onPositionUpdate: { globalIndex, yPosition in\n                                    sentencePositions[globalIndex] = yPosition\n                                }\n                            )\n                            .padding(.horizontal)\n                            .id(\"chapter-\\(chapterIndex)\")\n                        }\n                        \n                        // Bottom spacer\n                        Color.clear\n                            .frame(height: geometry.size.height - readingStartY)\n                            .id(\"bottomSpacer\")\n                    }\n                }\n                .coordinateSpace(name: \"scroll\")\n                .onPreferenceChange(ScrollOffsetPreferenceKey.self) { value in\n                    handleScrollChange(value, proxy: proxy)\n                }\n                .onPreferenceChange(SentencePositionPreferenceKey.self) { positions in\n                    // Update positions and find sentence at reading indicator\n                    for (index, yPos) in positions {\n                        sentencePositions[index] = yPos\n                    }\n                    updateCurrentIndexAtReadingIndicator()\n                }\n                .simultaneousGesture(\n                    TapGesture()\n                        .onEnded { _ in\n                            onTap?()\n                        }\n                )\n                .background(Color(.systemBackground))\n                .overlay(\n                    Group {\n                        if showReadingIndicators {\n                            ReadingIndicators(readingStartY: readingStartY, width: geometry.size.width)\n                        }\n                    }\n                )\n                .onAppear {\n                    initializeView(proxy: proxy)\n                }\n                .onChange(of: ttsIndex) { oldValue, newValue in\n                    if let index = newValue {\n                        withAnimation(.easeInOut(duration: 0.25)) {\n                            proxy.scrollTo(index, anchor: .center)\n                        }\n                    }\n                }\n                .onChange(of: scrollToIndex) { oldValue, newValue in\n                    if let index = newValue {\n                        let viewportHeight = UIScreen.main.bounds.height\n                        let anchorY = readingStartY / viewportHeight\n                        let anchor = UnitPoint(x: 0.5, y: anchorY)\n                        \n                        withAnimation(.easeOut(duration: 0.3)) {\n                            proxy.scrollTo(index, anchor: anchor)\n                        }\n                        \n                        onSnapToPosition?(index)\n                        \n                        DispatchQueue.main.async {\n                            scrollToIndex = nil\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // MARK: - Scroll Handling\n    \n    private func handleScrollChange(_ value: CGFloat, proxy: ScrollViewProxy) {\n        guard !isSnapping else { return }\n        \n        if abs(value - scrollOffset) > 15 {\n            scrollOffset = value\n            onScrollChanged?(value)\n            lastScrollChangeTime = Date()\n            \n            scrollEndTask?.cancel()\n            scrollEndTask = Task {\n                try? await Task.sleep(nanoseconds: 250_000_000)\n                if !Task.isCancelled {\n                    await MainActor.run {\n                        let timeSinceLastChange = Date().timeIntervalSince(lastScrollChangeTime)\n                        if timeSinceLastChange >= 0.25 && !isSnapping {\n                            onScrollEnded?()\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    private func initializeView(proxy: ScrollViewProxy) {\n        // Initialize visible range with larger buffer\n        if document.chapters.count <= 15 {\n            visibleChapterRange = 0..<document.chapters.count\n        } else {\n            visibleChapterRange = 0..<15\n        }\n        \n        // Scroll to current reading position after layout\n        DispatchQueue.main.asyncAfter(deadline: .now() + 0.4) {\n            if currentIndex > 0 {\n                withAnimation(.easeOut(duration: 0.3)) {\n                    proxy.scrollTo(currentIndex, anchor: .top)\n                }\n                onSnapToPosition?(currentIndex)\n            }\n        }\n    }\n    \n    private func updateVisibleChapterRange(for chapterIndex: Int) {\n        let buffer = 3\n        let newLower = max(0, chapterIndex - buffer)\n        let newUpper = min(document.chapters.count, chapterIndex + buffer + 1)\n        \n        if visibleChapterRange.lowerBound != newLower || visibleChapterRange.upperBound != newUpper {\n            visibleChapterRange = newLower..<newUpper\n        }\n    }\n    \n    private func updateCurrentIndexAtReadingIndicator() {\n        // Find sentence closest to readingStartY\n        var closestIndex: Int?\n        var closestDistance: CGFloat = .infinity\n        \n        for (index, yPos) in sentencePositions {\n            let distance = abs(yPos - readingStartY)\n            if distance < closestDistance {\n                closestDistance = distance\n                closestIndex = index\n            }\n        }\n        \n        if let idx = closestIndex, idx != currentIndex {\n            onIndexChanged(idx)\n        }\n    }\n}\n\n// MARK: - Chapter View (Paragraph-based rendering)\n\nprivate struct ChapterView: View {\n    let chapter: Chapter\n    let chapterIndex: Int\n    let fontSize: CGFloat\n    let ttsIndex: Int?\n    let bookmarks: [Bookmark]\n    let globalIndexOffset: Int\n    let onParagraphAppear: (Int, Int) -> Void\n    let onPositionUpdate: (Int, CGFloat) -> Void\n    \n    var body: some View {\n        VStack(alignment: .leading, spacing: 16) {\n            // Chapter title\n            if let title = chapter.title {\n                Text(title)\n                    .font(.title2)\n                    .fontWeight(.bold)\n                    .padding(.top, chapterIndex > 0 ? 32 : 0)\n                    .padding(.bottom, 8)\n            }\n            \n            // Paragraphs\n            ForEach(Array(chapter.paragraphs.enumerated()), id: \\.offset) { paraIndex, paragraph in\n                let firstIndex = paragraph.sentences.first?.globalIndex ?? (globalIndexOffset + paraIndex)\n                ParagraphView(\n                    paragraph: paragraph,\n                    fontSize: fontSize,\n                    ttsIndex: ttsIndex,\n                    bookmarks: bookmarks\n                )\n                .id(firstIndex)\n                .background(\n                    GeometryReader { geo in\n                        Color.clear\n                            .preference(key: SentencePositionPreferenceKey.self,\n                                       value: [firstIndex: geo.frame(in: .named(\"scroll\")).minY])\n                    }\n                )\n                .onAppear {\n                    if let firstSentence = paragraph.sentences.first {\n                        onParagraphAppear(paraIndex, firstSentence.globalIndex)\n                    }\n                }\n            }\n        }\n    }\n}\n\n// MARK: - Paragraph View (Single text block with attributed highlighting and formatting)\n\nprivate struct ParagraphView: View {\n    let paragraph: Paragraph\n    let fontSize: CGFloat\n    let ttsIndex: Int?\n    let bookmarks: [Bookmark]\n    \n    var body: some View {\n        HStack(alignment: .top, spacing: 4) {\n            // Blockquote styling\n            if paragraph.isBlockquote {\n                Rectangle()\n                    .fill(Color.secondary.opacity(0.3))\n                    .frame(width: 3)\n            }\n            \n            // Combine sentences into a single text with highlighting and formatting\n            paragraphText\n                .font(.system(size: fontSize))\n                .lineSpacing(4)\n                .fixedSize(horizontal: false, vertical: true)\n                .padding(.leading, paragraph.isBlockquote ? 8 : 0)\n                .padding(.leading, paragraph.isListItem ? CGFloat(paragraph.listItemLevel * 16) : 0)\n            \n            Spacer(minLength: 0)\n            \n            // Show bookmark indicator if any sentence in paragraph is bookmarked\n            if hasBookmark {\n                Image(systemName: \"bookmark.fill\")\n                    .font(.system(size: 12))\n                    .foregroundColor(.red)\n                    .padding(.top, 2)\n            }\n        }\n    }\n    \n    private var hasBookmark: Bool {\n        paragraph.sentences.contains { sentence in\n            bookmarks.contains { $0.position == sentence.globalIndex }\n        }\n    }\n    \n    @ViewBuilder\n    private var paragraphText: some View {\n        // Always use attributed text to support formatting\n        Text(attributedParagraphText)\n    }\n    \n    private var attributedParagraphText: AttributedString {\n        var result = AttributedString()\n        \n        for (index, sentence) in paragraph.sentences.enumerated() {\n            let isTTSHighlighted = ttsIndex != nil && sentence.globalIndex == ttsIndex\n            \n            // Build attributed string from formatted spans\n            for span in sentence.formattedSpans {\n                var spanAttr = AttributedString(span.text)\n                \n                // Apply TTS highlighting\n                if isTTSHighlighted {\n                    spanAttr.foregroundColor = .white\n                    spanAttr.backgroundColor = .blue\n                } else {\n                    spanAttr.foregroundColor = .primary\n                    \n                    // Apply blockquote styling\n                    if paragraph.isBlockquote {\n                        spanAttr.foregroundColor = .secondary\n                    }\n                }\n                \n                // Apply formatting styles\n                if span.style.contains(.bold) {\n                    spanAttr.font = .system(size: fontSize, weight: .bold)\n                }\n                if span.style.contains(.italic) {\n                    spanAttr.font = .system(size: fontSize).italic()\n                }\n                if span.style.contains(.bold) && span.style.contains(.italic) {\n                    spanAttr.font = .system(size: fontSize, weight: .bold).italic()\n                }\n                if span.style.contains(.underline) {\n                    spanAttr.underlineStyle = .single\n                }\n                if span.style.contains(.strikethrough) {\n                    spanAttr.strikethroughStyle = .single\n                }\n                if span.style.contains(.code) {\n                    spanAttr.font = .system(size: fontSize - 1, design: .monospaced)\n                    if !isTTSHighlighted {\n                        spanAttr.backgroundColor = Color(.secondarySystemBackground)\n                    }\n                }\n                \n                result.append(spanAttr)\n            }\n            \n            // Add space between sentences (except last)\n            if index < paragraph.sentences.count - 1 {\n                result.append(AttributedString(\" \"))\n            }\n        }\n        \n        return result\n    }\n}\n\n// MARK: - Reading Indicators\n\nprivate struct ReadingIndicators: View {\n    let readingStartY: CGFloat\n    let width: CGFloat\n    \n    var body: some View {\n        HStack {\n            Text(\"‚Üí\")\n                .font(.system(size: 10))\n                .foregroundColor(.green.opacity(0.8))\n                .position(x: 12, y: readingStartY)\n            \n            Spacer()\n            \n            Text(\"‚Üê\")\n                .font(.system(size: 10))\n                .foregroundColor(.green.opacity(0.8))\n                .position(x: width - 12, y: readingStartY)\n        }\n        .allowsHitTesting(false)\n    }\n}\n\n// MARK: - Preference Keys\n\nstruct ScrollOffsetPreferenceKey: PreferenceKey {\n    static var defaultValue: CGFloat = 0\n    static func reduce(value: inout CGFloat, nextValue: () -> CGFloat) {\n        value = nextValue()\n    }\n}\n\nstruct SentencePositionPreferenceKey: PreferenceKey {\n    static var defaultValue: [Int: CGFloat] = [:]\n    static func reduce(value: inout [Int: CGFloat], nextValue: () -> [Int: CGFloat]) {\n        value.merge(nextValue(), uniquingKeysWith: { _, new in new })\n    }\n}\n\n#Preview {\n    HighlightedTextView(\n        document: DocumentModel(\n            title: \"Test\",\n            author: nil,\n            chapters: [\n                Chapter(\n                    title: \"Chapter 1\",\n                    paragraphs: [\n                        Paragraph(sentences: [\n                            Sentence(text: \"This is a test sentence.\", globalIndex: 0, chapterIndex: 0, paragraphIndex: 0, sentenceIndex: 0),\n                            Sentence(text: \"This is another sentence.\", globalIndex: 1, chapterIndex: 0, paragraphIndex: 0, sentenceIndex: 1)\n                        ])\n                    ]\n                )\n            ],\n            tableOfContents: []\n        ),\n        currentIndex: 0,\n        ttsIndex: nil,\n        fontSize: 17,\n        readingStartY: 200,\n        showReadingIndicators: false,\n        bookmarks: [],\n        onIndexChanged: { _ in },\n        scrollToIndex: .constant(nil)\n    )\n}\n\n", "metadata": {"file_path": "Views/Reader/HighlightedTextView.swift", "file_extension": ".swift", "file_name": "HighlightedTextView.swift", "file_size": 16097, "last_modified": 1766184032.196839}}
{"id": "27", "text": "import SwiftUI\n\nstruct ReaderToolbar: View {\n    let isSpeaking: Bool\n    let onListen: () -> Void\n    let onStop: () -> Void\n    let onBookmark: () -> Void\n    let onShowBookmarks: () -> Void\n    let onShowVoiceSelection: () -> Void\n    @Binding var fontSize: CGFloat\n    \n    var body: some View {\n        HStack {\n            Button {\n                if isSpeaking {\n                    onStop()\n                } else {\n                    onListen()\n                }\n            } label: {\n                Image(systemName: isSpeaking ? \"stop.circle.fill\" : \"play.circle.fill\")\n                    .font(.title2)\n            }\n            \n            Button {\n                onBookmark()\n            } label: {\n                Image(systemName: \"bookmark\")\n                    .font(.title2)\n            }\n            \n            Button {\n                onShowBookmarks()\n            } label: {\n                Image(systemName: \"bookmark.fill\")\n                    .font(.title2)\n            }\n            \n            Button {\n                onShowVoiceSelection()\n            } label: {\n                Image(systemName: \"speaker.wave.2\")\n                    .font(.title2)\n            }\n            \n            Spacer()\n            \n            HStack {\n                Button {\n                    fontSize = max(12, fontSize - 2)\n                } label: {\n                    Image(systemName: \"textformat.size.smaller\")\n                }\n                \n                Text(\"\\(Int(fontSize))\")\n                    .frame(width: 30)\n                \n                Button {\n                    fontSize = min(24, fontSize + 2)\n                } label: {\n                    Image(systemName: \"textformat.size.larger\")\n                }\n            }\n        }\n        .padding()\n        .padding(.bottom, 8) // Extra padding for home indicator\n        .background(\n            Color(.systemBackground)\n                .ignoresSafeArea(.all, edges: .bottom)\n        )\n    }\n}\n\n#Preview {\n    ReaderToolbar(\n        isSpeaking: false,\n        onListen: {},\n        onStop: {},\n        onBookmark: {},\n        onShowBookmarks: {},\n        onShowVoiceSelection: {},\n        fontSize: .constant(17)\n    )\n}\n\n\n", "metadata": {"file_path": "Views/Reader/ReaderToolbar.swift", "file_extension": ".swift", "file_name": "ReaderToolbar.swift", "file_size": 2226, "last_modified": 1766184032.1965413}}
{"id": "28", "text": "import SwiftUI\n\nstruct LibraryRow: View {\n    let book: BookItem\n    var isSelected: Bool = false\n    var isDeletionMode: Bool = false\n    \n    var body: some View {\n        HStack(spacing: 12) {\n            if isDeletionMode {\n                Image(systemName: isSelected ? \"checkmark.circle.fill\" : \"circle\")\n                    .foregroundColor(isSelected ? .blue : .secondary)\n                    .font(.title3)\n            }\n            \n            VStack(alignment: .leading, spacing: 4) {\n                Text(book.title)\n                    .font(.headline)\n                \n                if let author = book.author, !author.isEmpty {\n                    Text(author)\n                        .font(.subheadline)\n                        .foregroundColor(.secondary)\n                }\n                \n                if let lastOpened = book.lastOpened {\n                    Text(\"Last opened: \\(lastOpened, style: .relative)\")\n                        .font(.caption)\n                        .foregroundColor(.secondary)\n                }\n            }\n            \n            Spacer()\n        }\n        .padding(.vertical, 4)\n        .contentShape(Rectangle())\n        .background(isSelected && isDeletionMode ? Color.blue.opacity(0.1) : Color.clear)\n    }\n}\n\n#Preview {\n    List {\n        LibraryRow(book: BookItem(\n            id: UUID(),\n            title: \"Sample Book\",\n            author: \"Sample Author\",\n            filePath: \"\",\n            lastOpened: Date(),\n            lastPosition: 0\n        ))\n    }\n}\n\n\n", "metadata": {"file_path": "Views/Library/LibraryRow.swift", "file_extension": ".swift", "file_name": "LibraryRow.swift", "file_size": 1532, "last_modified": 1766184032.196719}}
{"id": "29", "text": "import SwiftUI\nimport UniformTypeIdentifiers\nimport CoreData\n\nstruct LibraryView: View {\n    @Environment(\\.managedObjectContext) private var context\n    @StateObject private var viewModel = LibraryViewModel()\n    @State private var showingImport = false\n    @State private var showingDeleteConfirmation = false\n    @FocusState private var isSearchFieldFocused: Bool\n    \n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 0) {\n                // Search field at top (below toolbar)\n                if viewModel.isSearchActive {\n                    HStack {\n                        TextField(\"Search books...\", text: $viewModel.searchText)\n                            .textFieldStyle(.roundedBorder)\n                            .focused($isSearchFieldFocused)\n                            .submitLabel(.search)\n                            .onSubmit {\n                                viewModel.performSearch()\n                            }\n                        \n                        Button {\n                            viewModel.performSearch()\n                        } label: {\n                            Text(\"Search\")\n                                .fontWeight(.semibold)\n                        }\n                        .buttonStyle(.borderedProminent)\n                    }\n                    .padding(.horizontal)\n                    .padding(.vertical, 8)\n                    .background(Color(.systemBackground))\n                    .transition(.move(edge: .top))\n                }\n                \n                if viewModel.books.isEmpty && !viewModel.isSearchActive {\n                    ContentUnavailableView(\n                        \"No Books\",\n                        systemImage: \"book.closed\",\n                        description: Text(\"Import books to get started\")\n                    )\n                } else {\n                    GeometryReader { geometry in\n                        List {\n                            ForEach(viewModel.filteredBooks) { book in\n                                if viewModel.isDeletionMode {\n                                    Button {\n                                        if viewModel.selectedBookIds.contains(book.id) {\n                                            viewModel.selectedBookIds.remove(book.id)\n                                        } else {\n                                            viewModel.selectedBookIds.insert(book.id)\n                                        }\n                                    } label: {\n                                        LibraryRow(\n                                            book: book,\n                                            isSelected: viewModel.selectedBookIds.contains(book.id),\n                                            isDeletionMode: true\n                                        )\n                                    }\n                                    .buttonStyle(.plain)\n                                } else {\n                                    NavigationLink(value: book) {\n                                        LibraryRow(book: book)\n                                    }\n                                }\n                            }\n                        }\n                        .listStyle(.plain)\n                        .contentMargins(.top, geometry.safeAreaInsets.top + 44 + 60, for: .scrollContent)\n                    }\n                    .navigationDestination(for: BookItem.self) { book in\n                        ReaderView(book: book)\n                            .navigationBarBackButtonHidden(true)\n                            .ignoresSafeArea(.all, edges: .all)\n                    }\n                }\n            }\n            .ignoresSafeArea(.all, edges: .all)\n            .onAppear {\n                viewModel.setContext(context)\n            }\n            .toolbar {\n                // Add/Remove button (+/-) - appears rightmost\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Menu {\n                        Button {\n                            showingImport = true\n                        } label: {\n                            Label(\"Add\", systemImage: \"plus\")\n                        }\n                        \n                        Button {\n                            viewModel.isDeletionMode = true\n                            viewModel.selectedBookIds.removeAll()\n                        } label: {\n                            Label(\"Remove\", systemImage: \"minus\")\n                        }\n                    } label: {\n                        Image(systemName: \"plus.slash.minus\")\n                    }\n                }\n                \n                // Sort button - appears middle\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Menu {\n                        Picker(\"Sort By\", selection: $viewModel.sortOption) {\n                            Text(\"Last Opened\").tag(LibraryViewModel.SortOption.lastOpened)\n                            Text(\"Title\").tag(LibraryViewModel.SortOption.title)\n                            Text(\"Author\").tag(LibraryViewModel.SortOption.author)\n                        }\n                    } label: {\n                        Image(systemName: \"arrow.up.arrow.down\")\n                    }\n                }\n                \n                // Search button (magnifying glass / X) - appears leftmost\n                ToolbarItem(placement: .navigationBarTrailing) {\n                    Button {\n                        if viewModel.isSearchActive {\n                            viewModel.clearSearch()\n                            isSearchFieldFocused = false\n                        } else {\n                            viewModel.isSearchActive = true\n                            // Focus the search field after a brief delay to ensure it's rendered\n                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {\n                                isSearchFieldFocused = true\n                            }\n                        }\n                    } label: {\n                        Image(systemName: viewModel.isSearchActive ? \"xmark.circle.fill\" : \"magnifyingglass\")\n                    }\n                }\n                \n                // Delete button (only shown in deletion mode with selections)\n                if viewModel.isDeletionMode && !viewModel.selectedBookIds.isEmpty {\n                    ToolbarItem(placement: .navigationBarLeading) {\n                        Button {\n                            showingDeleteConfirmation = true\n                        } label: {\n                            Text(\"Delete\")\n                                .foregroundColor(.red)\n                        }\n                    }\n                }\n                \n                // Cancel deletion mode button\n                if viewModel.isDeletionMode {\n                    ToolbarItem(placement: .navigationBarLeading) {\n                        Button {\n                            viewModel.isDeletionMode = false\n                            viewModel.selectedBookIds.removeAll()\n                        } label: {\n                            Text(\"Cancel\")\n                        }\n                    }\n                }\n            }\n            .fileImporter(\n                isPresented: $showingImport,\n                allowedContentTypes: [.epub, .plainText],\n                allowsMultipleSelection: false\n            ) { result in\n                switch result {\n                case .success(let urls):\n                    if let url = urls.first {\n                        viewModel.importBook(from: url)\n                    }\n                case .failure(let error):\n                    print(\"Import error: \\(error)\")\n                }\n            }\n            .alert(\"Import Error\", isPresented: Binding(\n                get: { viewModel.importError != nil },\n                set: { if !$0 { viewModel.importError = nil } }\n            )) {\n                Button(\"OK\") {\n                    viewModel.importError = nil\n                }\n            } message: {\n                if let error = viewModel.importError {\n                    Text(error)\n                }\n            }\n            .alert(\"Delete Books\", isPresented: $showingDeleteConfirmation) {\n                Button(\"Cancel\", role: .cancel) { }\n                Button(\"Delete\", role: .destructive) {\n                    let idsToDelete = Array(viewModel.selectedBookIds)\n                    viewModel.deleteBooks(ids: idsToDelete)\n                }\n            } message: {\n                let count = viewModel.selectedBookIds.count\n                Text(\"Are you sure you want to delete \\(count) book\\(count == 1 ? \"\" : \"s\")? This action cannot be undone.\")\n            }\n        }\n    }\n}\n\n#Preview {\n    LibraryView()\n        .environment(\\.managedObjectContext, PersistenceController.preview.container.viewContext)\n}\n", "metadata": {"file_path": "Views/Library/LibraryView.swift", "file_extension": ".swift", "file_name": "LibraryView.swift", "file_size": 8948, "last_modified": 1766184032.1966054}}
{"id": "30", "text": "import SwiftUI\n\nstruct BookmarkSheet: View {\n    let bookmarks: [Bookmark]\n    let onSelect: (Bookmark) -> Void\n    let onDelete: (Bookmark) -> Void\n    \n    @Environment(\\.dismiss) private var dismiss\n    \n    var body: some View {\n        NavigationStack {\n            if bookmarks.isEmpty {\n                ContentUnavailableView(\n                    \"No Bookmarks\",\n                    systemImage: \"bookmark\",\n                    description: Text(\"Add bookmarks while reading\")\n                )\n            } else {\n                List {\n                    ForEach(bookmarks) { bookmark in\n                        VStack(alignment: .leading, spacing: 4) {\n                            Text(bookmark.label)\n                                .font(.headline)\n                            \n                            Text(bookmark.snippet)\n                                .font(.subheadline)\n                                .foregroundColor(.secondary)\n                                .lineLimit(2)\n                            \n                            Text(\"Position: \\(bookmark.position)\")\n                                .font(.caption)\n                                .foregroundColor(.secondary)\n                        }\n                        .contentShape(Rectangle())\n                        .onTapGesture {\n                            onSelect(bookmark)\n                        }\n                        .swipeActions(edge: .trailing, allowsFullSwipe: false) {\n                            Button(role: .destructive) {\n                                onDelete(bookmark)\n                            } label: {\n                                Label(\"Delete\", systemImage: \"trash\")\n                            }\n                        }\n                    }\n                }\n                .navigationTitle(\"Bookmarks\")\n                .navigationBarTitleDisplayMode(.inline)\n                .toolbar {\n                    ToolbarItem(placement: .navigationBarTrailing) {\n                        Button(\"Done\") {\n                            dismiss()\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\n#Preview {\n    BookmarkSheet(\n        bookmarks: [\n            Bookmark(\n                id: UUID(),\n                bookId: UUID(),\n                position: 10,\n                label: \"Bookmark 1\",\n                snippet: \"This is a sample snippet from the book...\",\n                createdAt: Date()\n            )\n        ],\n        onSelect: { _ in },\n        onDelete: { _ in }\n    )\n}\n\n\n", "metadata": {"file_path": "Views/Bookmarks/BookmarkSheet.swift", "file_extension": ".swift", "file_name": "BookmarkSheet.swift", "file_size": 2561, "last_modified": 1765400658.5703993}}
