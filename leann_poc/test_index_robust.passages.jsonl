{"id": "0", "text": "//\n//  RAGService.swift\n//  FoundationChatCore\n//\n//  Service for RAG (Retrieval-Augmented Generation) using SVDB\n//\n\nimport Foundation\nimport SVDB\n\n/// Service for managing RAG operations with SVDB vector database\n@available(macOS 26.0, iOS 26.0, *)\npublic actor RAGService {\n    /// Shared singleton instance\n    public static let shared = RAGService()\n    \n    /// SVDB instance\n    private let svdb: SVDB\n    \n    /// Embedding service\n    private let embeddingService = EmbeddingService.shared\n    \n    /// Text chunker\n    private let chunker = TextChunker.self\n    \n    /// Get chunk size from UserDefaults or use default\n    private var chunkSize: Int {\n        let value = UserDefaults.standard.integer(forKey: UserDefaultsKey.ragChunkSize)\n        return value > 0 ? value : TextChunker.defaultChunkSize\n    }\n    \n    /// Default chunk overlap (20% of chunk size)\n    private var chunkOverlap: Int {\n        return max(100, chunkSize / 5) // 20% overlap, minimum 100\n    }\n    \n    /// Get topK from UserDefaults or use default\n    private var topK: Int {\n        let value = UserDefaults.standard.integer(forKey: UserDefaultsKey.ragTopK)\n        return value > 0 ? value : 5\n    }\n    \n    /// Storage directory for SVDB\n    private let storageDirectory: URL\n    \n    /// File manager\n    private let fileManager = FileManager.default\n    \n    /// Initialize the RAG service\n    private init() {\n        // Get Application Support directory\n        let appSupport = fileManager.urls(for: .applicationSupportDirectory, in: .userDomainMask).first!\n        let appName = \"FoundationChat\"\n        let ragDir = appSupport.appendingPathComponent(appName).appendingPathComponent(\"RAG\", isDirectory: true)\n        \n        // Create directory if it doesn't exist\n        try? fileManager.createDirectory(at: ragDir, withIntermediateDirectories: true)\n        \n        self.storageDirectory = ragDir\n        self.svdb = SVDB.shared\n        \n        print(\"ðŸ” RAGService initialized. Storage: \\(ragDir.path)\")\n    }\n    \n    /// Check if a file is a PDF based on extension or MIME type\n    /// - Parameters:\n    ///   - attachment: The file attachment\n    ///   - url: The file URL\n    /// - Returns: True if the file is a PDF\n    private func isPDFFile(attachment: FileAttachment, url: URL) -> Bool {\n        // Check by file extension\n        let fileExtension = (attachment.originalName as NSString).pathExtension.lowercased()\n        if fileExtension == \"pdf\" {\n            return true\n        }\n        \n        // Check by MIME type if available\n        if let mimeType = attachment.mimeType, mimeType.lowercased() == \"application/pdf\" {\n            return true\n        }\n        \n        // Check by content type\n        if let contentType = try? url.resourceValues(forKeys: [.contentTypeKey]).contentType,\n           contentType.conforms(to: .pdf) {\n            return true\n        }\n        \n        return false\n    }\n    \n    /// Index a file for RAG retrieval\n    /// - Parameters:\n    ///   - attachment: The file attachment to index\n    ///   - conversationId: The conversation this file belongs to\n    /// - Throws: RAGError if indexing fails\n    public func indexFile(attachment: FileAttachment, conversationId: UUID) async throws {\n        // Read file content\n        let fileURL = URL(fileURLWithPath: attachment.sandboxPath)\n        guard fileManager.fileExists(atPath: fileURL.path) else {\n            throw RAGError.fileNotFound(attachment.sandboxPath)\n        }\n        \n        // Detect if file is a PDF\n        let isPDF = isPDFFile(attachment: attachment, url: fileURL)\n        \n        // Extract file content based on type\n        let fileContent: String\n        if isPDF {\n            // Extract text from PDF using PDFTextExtractor\n            do {\n                let pdfContent = try await PDFTextExtractor.extractText(from: fileURL)\n                // Format with metadata for better context\n                fileContent = pdfContent.formatted()\n                print(\"ðŸ“„ RAGService: Extracted text from PDF (\\(pdfContent.metadata.pageCount) pages): \\(attachment.originalName)\")\n            } catch PDFExtractionError.passwordProtected {\n                print(\"âš ï¸ RAGService: PDF is password-protected, skipping indexing: \\(attachment.originalName)\")\n                throw RAGError.unsupportedFileType(\"Password-protected PDF: \\(attachment.originalName)\")\n            } catch {\n                print(\"âš ï¸ RAGService: Failed to extract text from PDF: \\(attachment.originalName), error: \\(error.localizedDescription)\")\n                throw RAGError.unsupportedFileType(\"PDF extraction failed: \\(attachment.originalName)\")\n            }\n        } else {\n            // Read file content as text for non-PDF files\n            guard let textContent = try? String(contentsOf: fileURL, encoding: .utf8) else {\n                // Try other encodings or skip non-text files\n                print(\"âš ï¸ RAGService: Could not read file as UTF-8 text: \\(attachment.originalName)\")\n                throw RAGError.unsupportedFileType(attachment.originalName)\n            }\n            fileContent = textContent\n        }\n        \n        // Skip empty files\n        guard !fileContent.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {\n            print(\"âš ï¸ RAGService: File is empty: \\(attachment.originalName)\")\n            return\n        }\n        \n        // Chunk the content\n        let chunks = chunker.chunk(text: fileContent, chunkSize: chunkSize, overlap: chunkOverlap)\n        \n        guard !chunks.isEmpty else {\n            throw RAGError.chunkingFailed(\"No chunks created from file\")\n        }\n        \n        print(\"ðŸ“„ RAGService: Indexing \\(chunks.count) chunks from \\(attachment.originalName)\")\n        \n        // Generate embeddings for all chunks\n        let embeddings = try await embeddingService.embedBatch(texts: chunks)\n        \n        guard embeddings.count == chunks.count else {\n            throw RAGError.embeddingMismatch(\"Generated \\(embeddings.count) embeddings for \\(chunks.count) chunks\")\n        }\n        \n        // Get or create collection for this conversation\n        let collectionName = \"conversation_\\(conversationId.uuidString)\"\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"RAGService.swift:indexFile\",\n            message: \"indexFile: Getting or creating collection\",\n            hypothesisId: \"D\",\n            data: [\"collectionName\": collectionName, \"conversationId\": conversationId.uuidString, \"fileName\": attachment.originalName]\n        )\n        // #endregion\n        \n        let collection: Collection\n        do {\n            // Try to get existing collection first\n            if let existingCollection = svdb.getCollection(collectionName) {\n                collection = existingCollection\n                // #region debug log\n                await DebugLogger.shared.log(\n                    location: \"RAGService.swift:indexFile\",\n                    message: \"Found existing collection\",\n                    hypothesisId: \"D\",\n                    data: [\"collectionName\": collectionName]\n                )\n                // #endregion\n            } else {\n                // Create new collection if it doesn't exist\n                collection = try svdb.collection(collectionName)\n                // #region debug log\n                await DebugLogger.shared.log(\n                    location: \"RAGService.swift:indexFile\",\n                    message: \"Created new collection\",\n                    hypothesisId: \"D\",\n                    data: [\"collectionName\": collectionName]\n                )\n                // #endregion\n            }\n        } catch {\n            // If collection already exists, get it\n            if let existingCollection = svdb.getCollection(collectionName) {\n                collection = existingCollection\n            } else {\n                throw RAGError.indexingFailed(\"Failed to get or create collection: \\(error.localizedDescription)\")\n            }\n        }\n        \n        // Store each chunk in SVDB\n        for (index, (chunk, embedding)) in zip(chunks, embeddings).enumerated() {\n            // Convert Float array to Double array for SVDB\n            let doubleEmbedding = embedding.map { Double($0) }\n            \n            // Encode metadata in the document text prefix\n            // Format: [file:{fileId}|chunk:{index}|conversation:{conversationId}]\n            let metadataPrefix = \"[file:\\(attachment.id.uuidString)|chunk:\\(index)|conversation:\\(conversationId.uuidString)]\"\n            let documentWithMetadata = \"\\(metadataPrefix)\\n\\(chunk)\"\n            \n            // Add document to SVDB collection\n            collection.addDocument(\n                id: UUID(), // Generate unique ID for this chunk\n                text: documentWithMetadata,\n                embedding: doubleEmbedding\n            )\n        }\n        \n        print(\"âœ… RAGService: Successfully indexed \\(chunks.count) chunks from \\(attachment.originalName)\")\n    }\n    \n    /// Search for relevant chunks based on query\n    /// - Parameters:\n    ///   - query: The search query\n    ///   - fileIds: Optional array of file IDs to limit search to\n    ///   - conversationId: The conversation to search within\n    ///   - topK: Number of results to return (default: uses instance topK)\n    /// - Returns: Array of relevant document chunks sorted by relevance\n    /// - Throws: RAGError if search fails\n    public func searchRelevantChunks(\n        query: String,\n        fileIds: [UUID]? = nil,\n        conversationId: UUID,\n        topK: Int? = nil\n    ) async throws -> [DocumentChunk] {\n        // #region debug log\n        let collectionName = \"conversation_\\(conversationId.uuidString)\"\n        await DebugLogger.shared.log(\n            location: \"RAGService.swift:searchRelevantChunks\",\n            message: \"searchRelevantChunks called\",\n            hypothesisId: \"B,E\",\n            data: [\"query\": String(query.prefix(50)), \"conversationId\": conversationId.uuidString, \"collectionName\": collectionName]\n        )\n        // #endregion\n        \n        let k = topK ?? self.topK\n        \n        // Generate embedding for query\n        let queryEmbedding = try await embeddingService.embed(text: query)\n        let doubleQueryEmbedding = queryEmbedding.map { Double($0) }\n        \n        // Get collection for this conversation\n        guard let collection = svdb.getCollection(collectionName) else {\n            // #region debug log\n            await DebugLogger.shared.log(\n                location: \"RAGService.swift:searchRelevantChunks\",\n                message: \"Collection not found, returning empty\",\n                hypothesisId: \"D,E\",\n                data: [\"collectionName\": collectionName]\n            )\n            // #endregion\n            // Collection doesn't exist, return empty results\n            return []\n        }\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"RAGService.swift:searchRelevantChunks\",\n            message: \"Collection found, performing search\",\n            hypothesisId: \"D\",\n            data: [\"collectionName\": collectionName, \"topK\": k]\n        )\n        // #endregion\n        \n        // Search SVDB - returns [SearchResult] with id, text, and score\n        let searchResults = collection.search(\n            query: doubleQueryEmbedding,\n            num_results: k\n        )\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"RAGService.swift:searchRelevantChunks\",\n            message: \"Search completed\",\n            hypothesisId: \"E\",\n            data: [\"resultsCount\": searchResults.count]\n        )\n        // #endregion\n        \n        // Convert SearchResult objects to DocumentChunk objects\n        // Filter out message chunks - only return document chunks (those with [file: prefix)\n        var chunks: [DocumentChunk] = []\n        \n        for result in searchResults {\n            var resultText = result.text\n            \n            // Skip message chunks - only process document chunks\n            if resultText.hasPrefix(\"[message:\") {\n                continue\n            }\n            \n            var fileId = UUID()\n            var chunkIndex = 0\n            \n            // Parse metadata from text prefix if present\n            if resultText.hasPrefix(\"[file:\") {\n                let lines = resultText.components(separatedBy: \"\\n\")\n                if let metadataLine = lines.first {\n                    // Parse metadata: [file:{fileId}|chunk:{index}|conversation:{conversationId}]\n                    let components = metadataLine\n                        .replacingOccurrences(of: \"[file:\", with: \"\")\n                        .replacingOccurrences(of: \"]\", with: \"\")\n                        .components(separatedBy: \"|\")\n                    \n                    for component in components {\n                        if component.hasPrefix(\"file:\") {\n                            let fileIdString = String(component.dropFirst(5))\n                            if let uuid = UUID(uuidString: fileIdString) {\n                                fileId = uuid\n                            }\n                        } else if component.hasPrefix(\"chunk:\") {\n                            let chunkIndexString = String(component.dropFirst(6))\n                            chunkIndex = Int(chunkIndexString) ?? 0\n                        }\n                    }\n                }\n                \n                // Remove metadata line from content\n                if lines.count > 1 {\n                    resultText = lines.dropFirst().joined(separator: \"\\n\")\n                } else {\n                    resultText = \"\"\n                }\n            }\n            \n            // Filter by fileIds if specified\n            if let fileIds = fileIds, !fileIds.contains(fileId) {\n                continue\n            }\n            \n            let chunk = DocumentChunk(\n                id: result.id,\n                fileId: fileId,\n                conversationId: conversationId,\n                chunkIndex: chunkIndex,\n                content: resultText,\n                embedding: queryEmbedding, // We don't store the original embedding, use query as placeholder\n                metadata: [\n                    \"fileId\": fileId.uuidString,\n                    \"chunkIndex\": String(chunkIndex),\n                    \"score\": String(result.score)\n                ]\n            )\n            \n            chunks.append(chunk)\n        }\n        \n        return chunks\n    }\n    \n    /// Delete all indexes for a specific file\n    /// - Parameters:\n    ///   - attachmentId: The file attachment ID\n    ///   - conversationId: The conversation ID to search within\n    /// - Throws: RAGError if deletion fails\n    public func deleteFileIndex(attachmentId: UUID, conversationId: UUID) async throws {\n        let collectionName = \"conversation_\\(conversationId.uuidString)\"\n        \n        guard let collection = svdb.getCollection(collectionName) else {\n            // Collection doesn't exist, nothing to delete\n            return\n        }\n        \n        // Search for all documents with this file ID in their metadata\n        // We need to search through all documents to find ones matching this file\n        // Since SVDB doesn't support metadata filtering, we'll need to:\n        // 1. Get all documents (by searching with a dummy query that returns all)\n        // 2. Filter by parsing metadata\n        // 3. Remove matching documents\n        \n        // For now, we'll use a broad search to get documents, then filter\n        // Note: This is inefficient but SVDB doesn't support metadata queries\n        let dimension = embeddingService.embeddingDimension()\n        let dummyQuery = Array(repeating: 0.0, count: dimension)\n        let allResults = collection.search(query: dummyQuery, num_results: 1000)\n        \n        var documentsToRemove: [UUID] = []\n        \n        for result in allResults {\n            // Parse metadata from text prefix\n            if result.text.hasPrefix(\"[file:\") {\n                let lines = result.text.components(separatedBy: \"\\n\")\n                if let metadataLine = lines.first {\n                    let components = metadataLine\n                        .replacingOccurrences(of: \"[file:\", with: \"\")\n                        .replacingOccurrences(of: \"]\", with: \"\")\n                        .components(separatedBy: \"|\")\n                    \n                    for component in components {\n                        if component.hasPrefix(\"file:\") {\n                            let fileIdString = String(component.dropFirst(5))\n                            if let fileId = UUID(uuidString: fileIdString),\n                               fileId == attachmentId {\n                                documentsToRemove.append(result.id)\n                                break\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Remove all matching documents\n        for documentId in documentsToRemove {\n            collection.removeDocument(byId: documentId)\n        }\n        \n        print(\"ðŸ—‘ï¸ RAGService: Deleted \\(documentsToRemove.count) chunks for file \\(attachmentId.uuidString)\")\n    }\n    \n    /// Delete all indexes for a conversation\n    /// - Parameter conversationId: The conversation ID\n    /// - Throws: RAGError if deletion fails\n    public func deleteConversationIndexes(conversationId: UUID) async throws {\n        let collectionName = \"conversation_\\(conversationId.uuidString)\"\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"RAGService.swift:deleteConversationIndexes\",\n            message: \"deleteConversationIndexes called\",\n            hypothesisId: \"C\",\n            data: [\"conversationId\": conversationId.uuidString, \"collectionName\": collectionName]\n        )\n        // #endregion\n        \n        // Get collection if it exists\n        if let collection = svdb.getCollection(collectionName) {\n            // Clear all documents from the collection\n            collection.clear()\n            print(\"ðŸ—‘ï¸ RAGService: Cleared all documents from collection \\(collectionName)\")\n        }\n        \n        // Release the collection from SVDB\n        svdb.releaseCollection(collectionName)\n        print(\"ðŸ—‘ï¸ RAGService: Released collection \\(collectionName)\")\n    }\n    \n    /// Clear all SVDB data (all collections and storage)\n    /// This is a nuclear option that deletes everything\n    /// - Throws: Error if clearing fails\n    public func clearAllData() async throws {\n        // Delete the entire SVDB storage directory\n        if fileManager.fileExists(atPath: storageDirectory.path) {\n            try fileManager.removeItem(at: storageDirectory)\n            // Recreate empty directory\n            try fileManager.createDirectory(at: storageDirectory, withIntermediateDirectories: true)\n            print(\"ðŸ—‘ï¸ RAGService: Cleared all SVDB storage data\")\n        }\n    }\n    \n    /// Index a single message for RAG retrieval\n    /// - Parameters:\n    ///   - message: The message to index\n    ///   - conversationId: The conversation this message belongs to\n    /// - Throws: RAGError if indexing fails\n    public func indexMessage(_ message: Message, conversationId: UUID) async throws {\n        // Skip empty messages\n        guard !message.content.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {\n            print(\"âš ï¸ RAGService: Skipping empty message \\(message.id)\")\n            return\n        }\n        \n        // Get or create collection for this conversation\n        let collectionName = \"conversation_\\(conversationId.uuidString)\"\n        let collection: Collection\n        \n        do {\n            if let existingCollection = svdb.getCollection(collectionName) {\n                collection = existingCollection\n            } else {\n                collection = try svdb.collection(collectionName)\n            }\n        } catch {\n            if let existingCollection = svdb.getCollection(collectionName) {\n                collection = existingCollection\n            } else {\n                throw RAGError.indexingFailed(\"Failed to get or create collection: \\(error.localizedDescription)\")\n            }\n        }\n        \n        // Prepare message text: include role and content\n        let messageText = \"\\(message.role.rawValue.capitalized): \\(message.content)\"\n        \n        // Check if message needs chunking (if it exceeds chunk size)\n        let messageTokens = messageText.count / 4 // Rough token estimate\n        let needsChunking = messageTokens > chunkSize\n        \n        if needsChunking {\n            // Chunk the message content\n            let chunks = chunker.chunk(text: message.content, chunkSize: chunkSize, overlap: chunkOverlap)\n            \n            guard !chunks.isEmpty else {\n                throw RAGError.chunkingFailed(\"No chunks created from message\")\n            }\n            \n            // Generate embeddings for all chunks\n            let embeddings = try await embeddingService.embedBatch(texts: chunks)\n            \n            guard embeddings.count == chunks.count else {\n                throw RAGError.embeddingMismatch(\"Generated \\(embeddings.count) embeddings for \\(chunks.count) chunks\")\n            }\n            \n            // Store each chunk in SVDB\n            for (index, (chunk, embedding)) in zip(chunks, embeddings).enumerated() {\n                let doubleEmbedding = embedding.map { Double($0) }\n                \n                // Encode metadata in the document text prefix\n                // Format: [message:{messageId}|role:{role}|chunk:{index}|timestamp:{timestamp}|conversation:{conversationId}]\n                let timestampString = ISO8601DateFormatter().string(from: message.timestamp)\n                let metadataPrefix = \"[message:\\(message.id.uuidString)|role:\\(message.role.rawValue)|chunk:\\(index)|timestamp:\\(timestampString)|conversation:\\(conversationId.uuidString)]\"\n                let documentWithMetadata = \"\\(metadataPrefix)\\n\\(chunk)\"\n                \n                collection.addDocument(\n                    id: UUID(),\n                    text: documentWithMetadata,\n                    embedding: doubleEmbedding\n                )\n            }\n            \n            print(\"âœ… RAGService: Successfully indexed message \\(message.id) as \\(chunks.count) chunks\")\n        } else {\n            // Message fits in one chunk, index as-is\n            // Embed the full message text (including role) for better semantic matching\n            let embedding = try await embeddingService.embed(text: messageText)\n            let doubleEmbedding = embedding.map { Double($0) }\n            \n            // Encode metadata in the document text prefix\n            let timestampString = ISO8601DateFormatter().string(from: message.timestamp)\n            let metadataPrefix = \"[message:\\(message.id.uuidString)|role:\\(message.role.rawValue)|chunk:0|timestamp:\\(timestampString)|conversation:\\(conversationId.uuidString)]\"\n            let documentWithMetadata = \"\\(metadataPrefix)\\n\\(messageText)\"\n            \n            collection.addDocument(\n                id: UUID(),\n                text: documentWithMetadata,\n                embedding: doubleEmbedding\n            )\n            \n            print(\"âœ… RAGService: Successfully indexed message \\(message.id)\")\n        }\n    }\n    \n    /// Index all messages in a conversation's history\n    /// - Parameters:\n    ///   - messages: Array of messages to index\n    ///   - conversationId: The conversation ID\n    /// - Throws: RAGError if indexing fails\n    public func indexConversationHistory(_ messages: [Message], conversationId: UUID) async throws {\n        guard !messages.isEmpty else {\n            print(\"â„¹ï¸ RAGService: No messages to index for conversation \\(conversationId)\")\n            return\n        }\n        \n        print(\"ðŸ“ RAGService: Indexing \\(messages.count) messages for conversation \\(conversationId)\")\n        \n        var indexedCount = 0\n        var errorCount = 0\n        \n        for message in messages {\n            do {\n                try await indexMessage(message, conversationId: conversationId)\n                indexedCount += 1\n            } catch {\n                errorCount += 1\n                print(\"âš ï¸ RAGService: Failed to index message \\(message.id): \\(error.localizedDescription)\")\n                // Continue with other messages even if one fails\n            }\n        }\n        \n        print(\"âœ… RAGService: Indexed \\(indexedCount)/\\(messages.count) messages (\\(errorCount) errors)\")\n    }\n    \n    /// Search for relevant messages based on query\n    /// - Parameters:\n    ///   - query: The search query\n    ///   - conversationId: The conversation to search within\n    ///   - topK: Number of results to return (default: uses instance topK)\n    /// - Returns: Array of relevant message chunks sorted by relevance\n    /// - Throws: RAGError if search fails\n    public func searchRelevantMessages(\n        query: String,\n        conversationId: UUID,\n        topK: Int? = nil\n    ) async throws -> [MessageChunk] {\n        let k = topK ?? self.topK\n        let collectionName = \"conversation_\\(conversationId.uuidString)\"\n        \n        // Generate embedding for query\n        let queryEmbedding = try await embeddingService.embed(text: query)\n        let doubleQueryEmbedding = queryEmbedding.map { Double($0) }\n        \n        // Get collection for this conversation\n        guard let collection = svdb.getCollection(collectionName) else {\n            // Collection doesn't exist, return empty results\n            return []\n        }\n        \n        // Search SVDB\n        let searchResults = collection.search(\n            query: doubleQueryEmbedding,\n            num_results: k * 2 // Get more results to filter for messages only\n        )\n        \n        // Convert SearchResult objects to MessageChunk objects\n        var messageChunks: [MessageChunk] = []\n        \n        for result in searchResults {\n            var resultText = result.text\n            var messageId = UUID()\n            var role = MessageRole.user\n            var timestamp = Date()\n            var chunkIndex = 0\n            \n            // Parse metadata from text prefix if present\n            if resultText.hasPrefix(\"[message:\") {\n                let lines = resultText.components(separatedBy: \"\\n\")\n                if let metadataLine = lines.first {\n                    // Parse metadata: [message:{messageId}|role:{role}|chunk:{index}|timestamp:{timestamp}|conversation:{conversationId}]\n                    let components = metadataLine\n                        .replacingOccurrences(of: \"[message:\", with: \"\")\n                        .replacingOccurrences(of: \"]\", with: \"\")\n                        .components(separatedBy: \"|\")\n                    \n                    for component in components {\n                        if component.hasPrefix(\"message:\") {\n                            let messageIdString = String(component.dropFirst(8))\n                            if let uuid = UUID(uuidString: messageIdString) {\n                                messageId = uuid\n                            }\n                        } else if component.hasPrefix(\"role:\") {\n                            let roleString = String(component.dropFirst(5))\n                            role = MessageRole(rawValue: roleString) ?? .user\n                        } else if component.hasPrefix(\"chunk:\") {\n                            let chunkIndexString = String(component.dropFirst(6))\n                            chunkIndex = Int(chunkIndexString) ?? 0\n                        } else if component.hasPrefix(\"timestamp:\") {\n                            let timestampString = String(component.dropFirst(11))\n                            if let date = ISO8601DateFormatter().date(from: timestampString) {\n                                timestamp = date\n                            }\n                        }\n                    }\n                }\n                \n                // Remove metadata line from content\n                if lines.count > 1 {\n                    resultText = lines.dropFirst().joined(separator: \"\\n\")\n                } else {\n                    resultText = \"\"\n                }\n            } else {\n                // Not a message chunk, skip it (might be a file chunk)\n                continue\n            }\n            \n            let chunk = MessageChunk(\n                id: result.id,\n                messageId: messageId,\n                conversationId: conversationId,\n                chunkIndex: chunkIndex,\n                role: role,\n                content: resultText,\n                timestamp: timestamp,\n                embedding: queryEmbedding,\n                metadata: [\n                    \"messageId\": messageId.uuidString,\n                    \"role\": role.rawValue,\n                    \"chunkIndex\": String(chunkIndex),\n                    \"score\": String(result.score)\n                ]\n            )\n            \n            messageChunks.append(chunk)\n        }\n        \n        // Limit to topK and sort by score (highest first)\n        messageChunks.sort { chunk1, chunk2 in\n            let score1 = Double(chunk1.metadata[\"score\"] ?? \"0\") ?? 0\n            let score2 = Double(chunk2.metadata[\"score\"] ?? \"0\") ?? 0\n            return score1 > score2\n        }\n        \n        return Array(messageChunks.prefix(k))\n    }\n    \n    /// Index all existing conversations in the database\n    /// This is a migration method to retroactively index conversation history\n    /// - Parameter conversationService: The conversation service to load conversations from\n    /// - Returns: Migration result with counts of indexed conversations and messages\n    public func indexExistingConversations(conversationService: ConversationService) async throws -> (conversationsIndexed: Int, messagesIndexed: Int, errors: Int) {\n        print(\"ðŸ”„ RAGService: Starting migration to index existing conversations...\")\n        \n        var conversationsIndexed = 0\n        var messagesIndexed = 0\n        var errors = 0\n        \n        do {\n            let conversations = try conversationService.loadConversations()\n            print(\"ðŸ“ RAGService: Found \\(conversations.count) conversations to index\")\n            \n            for conversation in conversations {\n                guard !conversation.isEphemeral else {\n                    continue\n                }\n                \n                guard !conversation.messages.isEmpty else {\n                    continue\n                }\n                \n                do {\n                    try await indexConversationHistory(conversation.messages, conversationId: conversation.id)\n                    conversationsIndexed += 1\n                    messagesIndexed += conversation.messages.count\n                    print(\"âœ… RAGService: Indexed conversation \\(conversation.id) (\\(conversation.messages.count) messages)\")\n                } catch {\n                    errors += 1\n                    print(\"âš ï¸ RAGService: Failed to index conversation \\(conversation.id): \\(error.localizedDescription)\")\n                }\n            }\n            \n            print(\"âœ… RAGService: Migration complete - \\(conversationsIndexed) conversations, \\(messagesIndexed) messages indexed, \\(errors) errors\")\n        } catch {\n            print(\"âŒ RAGService: Migration failed: \\(error.localizedDescription)\")\n            throw RAGError.indexingFailed(\"Failed to load conversations: \\(error.localizedDescription)\")\n        }\n        \n        return (conversationsIndexed: conversationsIndexed, messagesIndexed: messagesIndexed, errors: errors)\n    }\n}\n\n/// Errors for RAG operations\n@available(macOS 26.0, iOS 26.0, *)\npublic enum RAGError: Error, LocalizedError, Sendable {\n    case fileNotFound(String)\n    case unsupportedFileType(String)\n    case chunkingFailed(String)\n    case embeddingMismatch(String)\n    case searchFailed(String)\n    case indexingFailed(String)\n    \n    public var errorDescription: String? {\n        switch self {\n        case .fileNotFound(let path):\n            return \"File not found: \\(path)\"\n        case .unsupportedFileType(let filename):\n            return \"Unsupported file type: \\(filename)\"\n        case .chunkingFailed(let reason):\n            return \"Chunking failed: \\(reason)\"\n        case .embeddingMismatch(let reason):\n            return \"Embedding mismatch: \\(reason)\"\n        case .searchFailed(let reason):\n            return \"Search failed: \\(reason)\"\n        case .indexingFailed(let reason):\n            return \"Indexing failed: \\(reason)\"\n        }\n    }\n}\n", "metadata": {"file_path": "RAGService.swift", "file_extension": ".swift", "file_name": "RAGService.swift", "file_size": 32871, "last_modified": 1766491017.637481}}
{"id": "1", "text": "//\n//  ContextOptimizer.swift\n//  FoundationChatCore\n//\n//  Main orchestrator for context management and optimization\n//\n\nimport Foundation\nimport FoundationModels\n\n/// Configuration for context optimization\n@available(macOS 26.0, iOS 26.0, *)\npublic struct ContextOptimizerConfig: Sendable {\n    /// Maximum context tokens (default: 4096)\n    public let maxContextTokens: Int\n    \n    /// Tokens to reserve for output (default: 500)\n    public let outputReserveTokens: Int\n    \n    /// Threshold to start compacting (default: 3500, 85% of max)\n    public let compactionThreshold: Int\n    \n    /// Number of recent messages to keep full (default: 5)\n    public let recentMessagesCount: Int\n    \n    public init(\n        maxContextTokens: Int = 4096,\n        outputReserveTokens: Int = 500,\n        compactionThreshold: Int = 3500,\n        recentMessagesCount: Int = 5\n    ) {\n        self.maxContextTokens = maxContextTokens\n        self.outputReserveTokens = outputReserveTokens\n        self.compactionThreshold = compactionThreshold\n        self.recentMessagesCount = recentMessagesCount\n    }\n}\n\n/// Optimized context result\n@available(macOS 26.0, iOS 26.0, *)\npublic struct OptimizedContext: Sendable {\n    /// Optimized messages\n    public let messages: [Message]\n    \n    /// Token usage breakdown\n    public let tokenUsage: TokenUsage\n    \n    /// Number of messages truncated/summarized\n    public let messagesTruncated: Int\n    \n    public init(\n        messages: [Message],\n        tokenUsage: TokenUsage,\n        messagesTruncated: Int\n    ) {\n        self.messages = messages\n        self.tokenUsage = tokenUsage\n        self.messagesTruncated = messagesTruncated\n    }\n}\n\n/// Token usage breakdown\n@available(macOS 26.0, iOS 26.0, *)\npublic struct TokenUsage: Sendable {\n    /// Tokens used by system prompt\n    public let systemTokens: Int\n    \n    /// Tokens used by tool definitions\n    public let toolTokens: Int\n    \n    /// Tokens used by messages\n    public let messageTokens: Int\n    \n    /// Total tokens used\n    public let totalTokens: Int\n    \n    /// Available tokens remaining\n    public let availableTokens: Int\n    \n    public init(\n        systemTokens: Int = 0,\n        toolTokens: Int = 0,\n        messageTokens: Int = 0,\n        totalTokens: Int = 0,\n        availableTokens: Int = 0\n    ) {\n        self.systemTokens = systemTokens\n        self.toolTokens = toolTokens\n        self.messageTokens = messageTokens\n        self.totalTokens = totalTokens\n        self.availableTokens = availableTokens\n    }\n}\n\n/// Main context optimizer\n@available(macOS 26.0, iOS 26.0, *)\npublic actor ContextOptimizer {\n    /// Configuration\n    private let config: ContextOptimizerConfig\n    \n    /// Token counter\n    private let tokenCounter = TokenCounter()\n    \n    /// Message compactor\n    private let compactor: MessageCompactor\n    \n    public init(config: ContextOptimizerConfig = ContextOptimizerConfig()) {\n        self.config = config\n        self.compactor = MessageCompactor(recentMessagesCount: config.recentMessagesCount)\n    }\n    \n    /// Optimize context using SVDB semantic retrieval\n    /// - Parameters:\n    ///   - messages: Full conversation messages\n    ///   - query: Current user message to use as search query\n    ///   - conversationId: The conversation ID for SVDB lookup\n    ///   - systemPrompt: Optional system prompt\n    ///   - tools: Available tools\n    /// - Returns: Optimized context with relevant messages retrieved from SVDB\n    public func optimizeContextWithSVDB(\n        messages: [Message],\n        query: String,\n        conversationId: UUID,\n        systemPrompt: String? = nil,\n        tools: [any Tool] = []\n    ) async throws -> OptimizedContext {\n        // Check if SVDB optimization is enabled\n        let useSVDB = UserDefaults.standard.object(forKey: UserDefaultsKey.useSVDBForContextOptimization) as? Bool ?? true\n        \n        guard useSVDB else {\n            // Fall back to standard optimization\n            return try await optimizeContext(messages: messages, systemPrompt: systemPrompt, tools: tools)\n        }\n        \n        // Calculate token usage for system prompt and tools\n        let systemTokens = systemPrompt != nil ? await tokenCounter.countTokens(systemPrompt!) : 0\n        let toolTokens = estimateToolTokens(tools)\n        \n        // Calculate available tokens for messages\n        let reservedTokens = systemTokens + toolTokens + config.outputReserveTokens\n        let availableForMessages = config.maxContextTokens - reservedTokens\n        \n        // Count original message tokens (for savings calculation)\n        let originalMessageTokens = await tokenCounter.countTokens(messages)\n        \n        // Get configuration for SVDB retrieval\n        let svdbTopK = UserDefaults.standard.integer(forKey: UserDefaultsKey.svdbContextTopK)\n        let topK = svdbTopK > 0 ? svdbTopK : AppConstants.defaultSVDBContextTopK\n        \n        let svdbRecentMessages = UserDefaults.standard.integer(forKey: UserDefaultsKey.svdbContextRecentMessages)\n        let recentMessagesCount = svdbRecentMessages > 0 ? svdbRecentMessages : AppConstants.defaultSVDBContextRecentMessages\n        \n        // Always include recent messages (last N messages)\n        let recentMessages = Array(messages.suffix(recentMessagesCount))\n        let recentMessageIds = Set(recentMessages.map { $0.id })\n        \n        // Always include the most recent user message (current query) if it exists\n        // This ensures the current message is in context even if not yet indexed\n        var currentUserMessage: Message? = nil\n        if let lastMessage = messages.last, lastMessage.role == .user {\n            currentUserMessage = lastMessage\n        }\n        \n        // Try to retrieve relevant messages from SVDB\n        var retrievedMessages: [Message] = []\n        var svdbAvailable = false\n        \n        do {\n            let messageChunks = try await RAGService.shared.searchRelevantMessages(\n                query: query,\n                conversationId: conversationId,\n                topK: topK\n            )\n            \n            if !messageChunks.isEmpty {\n                svdbAvailable = true\n                \n                // Group chunks by message ID and reconstruct messages\n                var messageMap: [UUID: (chunks: [MessageChunk], role: MessageRole, timestamp: Date)] = [:]\n                \n                for chunk in messageChunks {\n                    if let existing = messageMap[chunk.messageId] {\n                        var chunks = existing.chunks\n                        chunks.append(chunk)\n                        messageMap[chunk.messageId] = (chunks: chunks, role: chunk.role, timestamp: chunk.timestamp)\n                    } else {\n                        messageMap[chunk.messageId] = (chunks: [chunk], role: chunk.role, timestamp: chunk.timestamp)\n                    }\n                }\n                \n                // Reconstruct messages from chunks (sorted by timestamp)\n                for (messageId, data) in messageMap.sorted(by: { $0.value.timestamp < $1.value.timestamp }) {\n                    // Skip if already in recent messages\n                    if recentMessageIds.contains(messageId) {\n                        continue\n                    }\n                    \n                    // Combine chunks into full message content\n                    let chunks = data.chunks.sorted { $0.chunkIndex < $1.chunkIndex }\n                    // Remove role prefix if present (format: \"Role: content\")\n                    let content = chunks.map { chunk in\n                        let text = chunk.content\n                        // Remove role prefix if it exists (e.g., \"User: \" or \"Assistant: \")\n                        if let colonIndex = text.firstIndex(of: \":\") {\n                            let afterColon = text.index(after: colonIndex)\n                            if afterColon < text.endIndex {\n                                return String(text[afterColon...]).trimmingCharacters(in: .whitespaces)\n                            }\n                        }\n                        return text\n                    }.joined(separator: \" \")\n                    \n                    // Find original message to preserve other properties (toolCalls, attachments, etc.)\n                    if let originalMessage = messages.first(where: { $0.id == messageId }) {\n                        // Create a copy with updated content to preserve immutability semantics\n                        let reconstructedMessage = Message(\n                            id: originalMessage.id,\n                            role: originalMessage.role,\n                            content: content,\n                            timestamp: originalMessage.timestamp,\n                            toolCalls: originalMessage.toolCalls,\n                            responseTime: originalMessage.responseTime,\n                            attachments: originalMessage.attachments\n                        )\n                        retrievedMessages.append(reconstructedMessage)\n                    } else {\n                        // Create new message from chunk data (shouldn't happen in normal flow)\n                        let message = Message(\n                            id: messageId,\n                            role: data.role,\n                            content: content,\n                            timestamp: data.timestamp\n                        )\n                        retrievedMessages.append(message)\n                    }\n                }\n            }\n        } catch {\n            // SVDB not available or error occurred, fall back to summarization\n            print(\"âš ï¸ ContextOptimizer: SVDB retrieval failed, falling back to summarization: \\(error.localizedDescription)\")\n        }\n        \n        // Combine recent messages with retrieved messages\n        // Remove duplicates (in case a recent message was also retrieved)\n        let retrievedMessageIds = Set(retrievedMessages.map { $0.id })\n        let uniqueRecentMessages = recentMessages.filter { !retrievedMessageIds.contains($0.id) }\n        \n        // Always include current user message if it exists and isn't already included\n        var messagesToInclude = retrievedMessages + uniqueRecentMessages\n        if let currentMessage = currentUserMessage, !retrievedMessageIds.contains(currentMessage.id) {\n            let isInRecent = recentMessageIds.contains(currentMessage.id)\n            if !isInRecent {\n                messagesToInclude.append(currentMessage)\n            }\n        }\n        \n        // Combine all messages and sort by timestamp to maintain chronological order\n        var optimizedMessages = messagesToInclude\n        optimizedMessages.sort { $0.timestamp < $1.timestamp }\n        \n        // If SVDB wasn't available or returned no results, fall back to standard optimization\n        if !svdbAvailable || optimizedMessages.isEmpty {\n            return try await optimizeContext(messages: messages, systemPrompt: systemPrompt, tools: tools)\n        }\n        \n        // Count optimized message tokens\n        var optimizedMessageTokens = await tokenCounter.countTokens(optimizedMessages)\n        \n        // If messages still exceed budget, truncate long messages first, then compact if needed\n        if optimizedMessageTokens > availableForMessages {\n            // First, truncate individual messages that are too long\n            var truncatedMessages: [Message] = []\n            var currentTokens = 0\n            let maxTokensPerMessage = availableForMessages / max(1, optimizedMessages.count) // Rough per-message limit\n            \n            for message in optimizedMessages.reversed() { // Process from most recent\n                let messageTokens = await tokenCounter.countTokens(message)\n                \n                if messageTokens > maxTokensPerMessage {\n                    // Truncate long message\n                    let maxChars = maxTokensPerMessage * 4 // Rough char-to-token conversion\n                    let truncatedContent = String(message.content.prefix(maxChars))\n                    let truncatedMessage = Message(\n                        id: message.id,\n                        role: message.role,\n                        content: truncatedContent + \"... [truncated]\",\n                        timestamp: message.timestamp,\n                        toolCalls: message.toolCalls,\n                        responseTime: message.responseTime,\n                        attachments: message.attachments\n                    )\n                    truncatedMessages.insert(truncatedMessage, at: 0)\n                    currentTokens += await tokenCounter.countTokens(truncatedMessage)\n                } else if currentTokens + messageTokens <= availableForMessages {\n                    truncatedMessages.insert(message, at: 0)\n                    currentTokens += messageTokens\n                } else {\n                    // Message doesn't fit, skip it (we'll keep more recent messages)\n                    break\n                }\n            }\n            \n            optimizedMessages = truncatedMessages\n            optimizedMessageTokens = currentTokens\n        }\n        \n        // If optimized messages still exceed budget after truncation, apply compaction\n        if optimizedMessageTokens > availableForMessages {\n            let compactedMessages = try await compactor.compact(\n                messages: optimizedMessages,\n                maxTokens: availableForMessages\n            )\n            \n            let compactedTokens = await tokenCounter.countTokens(compactedMessages)\n            let totalTokens = systemTokens + toolTokens + compactedTokens\n            let messagesTruncated = messages.count - compactedMessages.count\n            \n            return OptimizedContext(\n                messages: compactedMessages,\n                tokenUsage: TokenUsage(\n                    systemTokens: systemTokens,\n                    toolTokens: toolTokens,\n                    messageTokens: compactedTokens,\n                    totalTokens: totalTokens,\n                    availableTokens: config.maxContextTokens - totalTokens\n                ),\n                messagesTruncated: messagesTruncated\n            )\n        }\n        \n        // Optimized messages fit within budget\n        let totalTokens = systemTokens + toolTokens + optimizedMessageTokens\n        let messagesTruncated = messages.count - optimizedMessages.count\n        \n        print(\"ðŸ“Š ContextOptimizer: SVDB optimization - Original: \\(originalMessageTokens) tokens, Optimized: \\(optimizedMessageTokens) tokens, Saved: \\(originalMessageTokens - optimizedMessageTokens) tokens\")\n        \n        return OptimizedContext(\n            messages: optimizedMessages,\n            tokenUsage: TokenUsage(\n                systemTokens: systemTokens,\n                toolTokens: toolTokens,\n                messageTokens: optimizedMessageTokens,\n                totalTokens: totalTokens,\n                availableTokens: config.maxContextTokens - totalTokens\n            ),\n            messagesTruncated: messagesTruncated\n        )\n    }\n    \n    /// Optimize context for a conversation\n    /// - Parameters:\n    ///   - messages: Conversation messages\n    ///   - systemPrompt: Optional system prompt\n    ///   - tools: Available tools\n    /// - Returns: Optimized context\n    public func optimizeContext(\n        messages: [Message],\n        systemPrompt: String? = nil,\n        tools: [any Tool] = []\n    ) async throws -> OptimizedContext {\n        // Calculate token usage for system prompt and tools\n        let systemTokens = systemPrompt != nil ? await tokenCounter.countTokens(systemPrompt!) : 0\n        let toolTokens = estimateToolTokens(tools)\n        \n        // Calculate available tokens for messages\n        let reservedTokens = systemTokens + toolTokens + config.outputReserveTokens\n        let availableForMessages = config.maxContextTokens - reservedTokens\n        \n        // Count current message tokens\n        let currentMessageTokens = await tokenCounter.countTokens(messages)\n        \n        // If messages fit within budget, return as-is\n        if currentMessageTokens <= availableForMessages {\n            let totalTokens = systemTokens + toolTokens + currentMessageTokens\n            return OptimizedContext(\n                messages: messages,\n                tokenUsage: TokenUsage(\n                    systemTokens: systemTokens,\n                    toolTokens: toolTokens,\n                    messageTokens: currentMessageTokens,\n                    totalTokens: totalTokens,\n                    availableTokens: config.maxContextTokens - totalTokens\n                ),\n                messagesTruncated: 0\n            )\n        }\n        \n        // Need to compact messages\n        let compactedMessages = try await compactor.compact(\n            messages: messages,\n            maxTokens: availableForMessages\n        )\n        \n        let compactedTokens = await tokenCounter.countTokens(compactedMessages)\n        let totalTokens = systemTokens + toolTokens + compactedTokens\n        let messagesTruncated = messages.count - compactedMessages.count\n        \n        return OptimizedContext(\n            messages: compactedMessages,\n            tokenUsage: TokenUsage(\n                systemTokens: systemTokens,\n                toolTokens: toolTokens,\n                messageTokens: compactedTokens,\n                totalTokens: totalTokens,\n                availableTokens: config.maxContextTokens - totalTokens\n            ),\n            messagesTruncated: messagesTruncated\n        )\n    }\n    \n    /// Optimize context for a transcript\n    /// - Parameters:\n    ///   - transcript: Conversation transcript\n    ///   - systemPrompt: Optional system prompt\n    ///   - tools: Available tools\n    /// - Returns: Optimized transcript\n    /// Note: This method may need adjustment based on actual Transcript API structure\n    public func optimizeTranscript(\n        transcript: Transcript,\n        systemPrompt: String? = nil,\n        tools: [any Tool] = []\n    ) async throws -> Transcript {\n        // For now, return transcript as-is\n        // Full implementation would require access to transcript internals\n        return transcript\n    }\n    \n    /// Estimate tokens used by tool definitions\n    /// - Parameter tools: Tools to estimate\n    /// - Returns: Estimated token count\n    private func estimateToolTokens(_ tools: [any Tool]) -> Int {\n        // Rough estimate: each tool description + name + parameters â‰ˆ 50-100 tokens\n        // We'll use 75 tokens per tool as a conservative estimate\n        return tools.count * 75\n    }\n    \n    /// Convert transcript to messages\n    /// Note: Transcript API structure may vary - this is a simplified conversion\n    private func transcriptToMessages(_ transcript: Transcript) -> [Message] {\n        // Since we can't directly access transcript entries, we'll need to work with\n        // the transcript as provided by FoundationModels API\n        // For now, return empty array - this method may need adjustment based on actual API\n        return []\n    }\n    \n    /// Convert messages to transcript\n    private func messagesToTranscript(_ messages: [Message]) -> Transcript {\n        var entries: [Transcript.Entry] = []\n        \n        for message in messages {\n            switch message.role {\n            case .user, .system:\n                let textSegment = Transcript.TextSegment(content: message.content)\n                let prompt = Transcript.Prompt(segments: [.text(textSegment)])\n                entries.append(.prompt(prompt))\n            case .assistant:\n                let textSegment = Transcript.TextSegment(content: message.content)\n                let response = Transcript.Response(assetIDs: [], segments: [.text(textSegment)])\n                entries.append(.response(response))\n            }\n        }\n        \n        return Transcript(entries: entries)\n    }\n    \n    /// Extract text from prompt\n    private func extractTextFromPrompt(_ prompt: Transcript.Prompt) -> String {\n        return prompt.segments.compactMap { segment in\n            if case .text(let textSegment) = segment {\n                return textSegment.content\n            }\n            return nil\n        }.joined(separator: \" \")\n    }\n    \n    /// Extract text from response\n    private func extractTextFromResponse(_ response: Transcript.Response) -> String {\n        return response.segments.compactMap { segment in\n            if case .text(let textSegment) = segment {\n                return textSegment.content\n            }\n            return nil\n        }.joined(separator: \" \")\n    }\n}\n\n", "metadata": {"file_path": "ContextOptimizer.swift", "file_extension": ".swift", "file_name": "ContextOptimizer.swift", "file_size": 20715, "last_modified": 1766491017.6370275}}
{"id": "2", "text": "//\n//  ConversationService.swift\n//  FoundationChatCore\n//\n//  High-level service for managing conversations\n//\n\nimport Foundation\n\n/// Service for managing conversations and messages\n@available(macOS 26.0, iOS 26.0, *)\npublic class ConversationService {\n    /// The database manager\n    private let dbManager: DatabaseManager\n    \n    /// Initialize the conversation service\n    /// - Parameter dbPath: Optional custom database path\n    public init(dbPath: String? = nil) throws {\n        print(\"ðŸ’¬ ConversationService init() called\")\n        print(\"ðŸ’¬ Thread: \\(Thread.isMainThread ? \"Main\" : \"Background\")\")\n        print(\"ðŸ’¬ About to create DatabaseManager...\")\n        self.dbManager = try DatabaseManager(dbPath: dbPath)\n        print(\"âœ… ConversationService init() complete\")\n    }\n    \n    /// Create a new conversation\n    /// - Parameters:\n    ///   - title: Optional title (will be auto-generated if nil)\n    ///   - isEphemeral: Whether this conversation should be stored\n    /// - Returns: The created conversation\n    public func createConversation(title: String? = nil, isEphemeral: Bool = false) throws -> Conversation {\n        let conversation = Conversation(\n            title: title ?? \"New Conversation\",\n            isEphemeral: isEphemeral\n        )\n        \n        // Only save if not ephemeral\n        if !isEphemeral {\n            try dbManager.saveConversation(conversation)\n        }\n        \n        return conversation\n    }\n    \n    /// Load all conversations\n    /// - Returns: Array of conversations sorted by updated date\n    public func loadConversations() throws -> [Conversation] {\n        return try dbManager.loadConversations()\n    }\n    \n    /// Load a specific conversation\n    /// - Parameter id: The conversation ID\n    /// - Returns: The conversation if found\n    public func loadConversation(id: UUID) throws -> Conversation? {\n        return try dbManager.loadConversation(id: id)\n    }\n    \n    /// Update a conversation\n    /// - Parameter conversation: The conversation to update\n    public func updateConversation(_ conversation: Conversation) throws {\n        // Only save if not ephemeral\n        if !conversation.isEphemeral {\n            try dbManager.saveConversation(conversation)\n        }\n    }\n    \n    /// Delete a conversation\n    /// - Parameter id: The conversation ID\n    nonisolated public func deleteConversation(id: UUID) async throws {\n        // Delete all files associated with this conversation\n        // This will also delete RAG indexes via FileManagerService\n        let fileManagerService = FileManagerService.shared\n        do {\n            try await fileManagerService.deleteFilesForConversation(conversationId: id)\n        } catch {\n            // Log error but don't fail deletion - we still want to delete from database\n            print(\"âš ï¸ Error deleting files for conversation \\(id): \\(error)\")\n        }\n        \n        // Delete from database\n        // Capture dbManager to avoid isolation issues\n        let db = self.dbManager\n        try db.deleteConversation(id: id)\n    }\n    \n    /// Add a message to a conversation\n    /// - Parameters:\n    ///   - message: The message to add\n    ///   - conversationId: The conversation ID\n    ///   - indexImmediately: If true, wait for indexing to complete (for current message). If false, index asynchronously (for assistant responses)\n    nonisolated public func addMessage(_ message: Message, to conversationId: UUID, indexImmediately: Bool = false) async throws {\n        // Load conversation to check if it's ephemeral\n        if let conversation = try dbManager.loadConversation(id: conversationId), !conversation.isEphemeral {\n            try dbManager.saveMessage(message, conversationId: conversationId)\n            \n            if indexImmediately {\n                // Index synchronously for current user message (needed for immediate context building)\n                do {\n                    try await RAGService.shared.indexMessage(message, conversationId: conversationId)\n                    print(\"âœ… ConversationService: Indexed message \\(message.id) immediately\")\n                } catch {\n                    // Log error but don't fail message save\n                    print(\"âš ï¸ ConversationService: Failed to index message \\(message.id) in SVDB: \\(error.localizedDescription)\")\n                }\n            } else {\n                // Index asynchronously for assistant responses (don't block)\n                Task {\n                    do {\n                        try await RAGService.shared.indexMessage(message, conversationId: conversationId)\n                    } catch {\n                        // Log error but don't fail message save\n                        print(\"âš ï¸ ConversationService: Failed to index message \\(message.id) in SVDB: \\(error.localizedDescription)\")\n                    }\n                }\n            }\n        }\n    }\n    \n    /// Index existing conversation history in SVDB\n    /// - Parameter conversationId: The conversation ID\n    /// - Throws: RAGError if indexing fails\n    public func indexExistingConversationHistory(_ conversationId: UUID) async throws {\n        guard let conversation = try dbManager.loadConversation(id: conversationId) else {\n            throw NSError(domain: \"ConversationService\", code: 404, userInfo: [NSLocalizedDescriptionKey: \"Conversation not found\"])\n        }\n        \n        guard !conversation.isEphemeral else {\n            print(\"â„¹ï¸ ConversationService: Skipping ephemeral conversation \\(conversationId)\")\n            return\n        }\n        \n        let messages = conversation.messages\n        guard !messages.isEmpty else {\n            print(\"â„¹ï¸ ConversationService: No messages to index for conversation \\(conversationId)\")\n            return\n        }\n        \n        print(\"ðŸ“ ConversationService: Indexing \\(messages.count) messages for conversation \\(conversationId)\")\n        try await RAGService.shared.indexConversationHistory(messages, conversationId: conversationId)\n    }\n    \n    /// Update a message in a conversation\n    /// - Parameters:\n    ///   - message: The updated message\n    ///   - conversationId: The conversation ID\n    public func updateMessage(_ message: Message, in conversationId: UUID) throws {\n        if let conversation = try dbManager.loadConversation(id: conversationId), !conversation.isEphemeral {\n            try dbManager.saveMessage(message, conversationId: conversationId)\n        }\n    }\n    \n    /// Save orchestration state for a message\n    /// - Parameters:\n    ///   - state: The orchestration state\n    ///   - messageId: The message ID\n    public func saveOrchestrationState(_ state: OrchestrationState, for messageId: UUID) throws {\n        try dbManager.saveOrchestrationState(state, for: messageId)\n    }\n    \n    /// Load orchestration states for a conversation\n    /// - Parameter conversationId: The conversation ID\n    /// - Returns: Dictionary mapping message ID to orchestration state\n    public func loadOrchestrationStates(for conversationId: UUID) throws -> [UUID: OrchestrationState] {\n        return try dbManager.loadOrchestrationStates(for: conversationId)\n    }\n    \n    /// Save a workflow checkpoint\n    /// - Parameter checkpoint: The checkpoint to save\n    public func saveWorkflowCheckpoint(_ checkpoint: WorkflowCheckpoint) throws {\n        try dbManager.saveWorkflowCheckpoint(checkpoint)\n    }\n    \n    /// Load a workflow checkpoint by ID\n    /// - Parameter id: The checkpoint ID\n    /// - Returns: The checkpoint if found\n    public func loadWorkflowCheckpoint(id: UUID) throws -> WorkflowCheckpoint? {\n        return try dbManager.loadWorkflowCheckpoint(id: id)\n    }\n    \n    /// Load all checkpoints for a conversation\n    /// - Parameter conversationId: The conversation ID\n    /// - Returns: Array of checkpoints sorted by creation date\n    public func loadWorkflowCheckpoints(for conversationId: UUID) throws -> [WorkflowCheckpoint] {\n        return try dbManager.loadWorkflowCheckpoints(for: conversationId)\n    }\n    \n    /// Load all checkpoints for a message\n    /// - Parameter messageId: The message ID\n    /// - Returns: Array of checkpoints sorted by creation date\n    public func loadWorkflowCheckpoints(forMessage messageId: UUID) throws -> [WorkflowCheckpoint] {\n        return try dbManager.loadWorkflowCheckpoints(forMessage: messageId)\n    }\n    \n    /// Search conversations by title\n    /// - Parameter query: Search query\n    /// - Returns: Matching conversations\n    public func searchConversations(query: String) throws -> [Conversation] {\n        let allConversations = try loadConversations()\n        let lowerQuery = query.lowercased()\n        return allConversations.filter { conversation in\n            conversation.title.lowercased().contains(lowerQuery)\n        }\n    }\n}\n\n", "metadata": {"file_path": "ConversationService.swift", "file_extension": ".swift", "file_name": "ConversationService.swift", "file_size": 8846, "last_modified": 1766491017.6370604}}
{"id": "3", "text": "//\n//  LEANNBridgeService.swift\n//  FoundationChatCore\n//\n//  Bridge to LEANN Python vector database for code analysis\n//\n\nimport Foundation\n\n/// Service for interfacing with LEANN vector database via Python\n@available(macOS 26.0, iOS 26.0, *)\npublic actor LEANNBridgeService {\n    /// Shared singleton instance\n    public static let shared = LEANNBridgeService()\n    \n    /// Path to Python venv\n    private let pythonPath: URL\n    \n    /// Path to LEANN bridge script\n    private let bridgeScriptPath: URL\n    \n    /// Current index path\n    private var currentIndexPath: URL?\n    \n    /// Indexing state\n    public enum IndexingState: Sendable, Equatable {\n        case notIndexed\n        case indexing(progress: String)\n        case indexed(fileCount: Int, path: String)\n        case error(String)\n    }\n    \n    /// Current indexing state\n    public private(set) var indexingState: IndexingState = .notIndexed\n    \n    /// UserDefaults keys\n    private enum Keys {\n        static let indexedCodebasePath = \"leannIndexedCodebasePath\"\n        static let indexPath = \"leannIndexPath\"\n        static let indexedFileCount = \"leannIndexedFileCount\"\n    }\n    \n    private init() {\n        // Hardcoded path to the leann_poc directory in the user's project\n        // NOTE: Update this path if the project moves to a different location\n        let projectRoot = URL(fileURLWithPath: \"/Users/owenperry/dev/llm\")\n        \n        self.pythonPath = projectRoot\n            .appendingPathComponent(\"leann_poc\")\n            .appendingPathComponent(\"venv\")\n            .appendingPathComponent(\"bin\")\n            .appendingPathComponent(\"python\")\n        \n        self.bridgeScriptPath = projectRoot\n            .appendingPathComponent(\"leann_poc\")\n            .appendingPathComponent(\"leann_bridge.py\")\n        \n        // Debug: print paths\n        print(\"ðŸ LEANN Python path: \\(pythonPath.path)\")\n        print(\"ðŸ“œ LEANN Bridge script: \\(bridgeScriptPath.path)\")\n        \n        // Load saved index state\n        if let savedPath = UserDefaults.standard.string(forKey: Keys.indexedCodebasePath),\n           let indexPath = UserDefaults.standard.string(forKey: Keys.indexPath) {\n            let fileCount = UserDefaults.standard.integer(forKey: Keys.indexedFileCount)\n            self.currentIndexPath = URL(fileURLWithPath: indexPath)\n            self.indexingState = .indexed(fileCount: fileCount, path: savedPath)\n        }\n    }\n    \n    /// Index a codebase directory\n    /// - Parameter path: Path to the codebase root directory\n    /// - Returns: Result with file count or error\n    public func indexCodebase(path: String) async throws -> Int {\n        indexingState = .indexing(progress: \"Starting indexing...\")\n        \n        // Create index path in the leann_poc directory\n        let projectRoot = pythonPath\n            .deletingLastPathComponent() // bin\n            .deletingLastPathComponent() // venv\n        let indexPath = projectRoot.appendingPathComponent(\"code_index\")\n        \n        // Run Python indexing\n        let result = try await runPythonCommand(\n            command: \"index\",\n            arguments: [path, \"--extensions\", \".swift\", \".py\", \".js\", \".ts\", \".md\", \".json\", \"--index-path\", indexPath.path]\n        )\n        \n        // Parse result\n        guard let data = result.data(using: .utf8),\n              let json = try? JSONSerialization.jsonObject(with: data) as? [String: Any] else {\n            indexingState = .error(\"Failed to parse indexing result\")\n            throw LEANNError.parsingFailed(\"Invalid JSON response\")\n        }\n        \n        if let error = json[\"error\"] as? String {\n            indexingState = .error(error)\n            throw LEANNError.indexingFailed(error)\n        }\n        \n        guard let success = json[\"success\"] as? Bool, success,\n              let fileCount = json[\"indexed_files\"] as? Int else {\n            indexingState = .error(\"Indexing failed\")\n            throw LEANNError.indexingFailed(\"Unknown error\")\n        }\n        \n        // Save state\n        self.currentIndexPath = indexPath\n        UserDefaults.standard.set(path, forKey: Keys.indexedCodebasePath)\n        UserDefaults.standard.set(indexPath.path, forKey: Keys.indexPath)\n        UserDefaults.standard.set(fileCount, forKey: Keys.indexedFileCount)\n        \n        indexingState = .indexed(fileCount: fileCount, path: path)\n        \n        print(\"âœ… LEANNBridgeService: Indexed \\(fileCount) files from \\(path)\")\n        return fileCount\n    }\n    \n    /// Search the indexed codebase\n    /// - Parameters:\n    ///   - query: Search query\n    ///   - topK: Number of results to return\n    /// - Returns: Array of search results\n    public func search(query: String, topK: Int = 5) async throws -> [CodeSearchResult] {\n        guard let indexPath = currentIndexPath else {\n            throw LEANNError.notIndexed\n        }\n        \n        let result = try await runPythonCommand(\n            command: \"search\",\n            arguments: [query, \"--top-k\", String(topK), \"--index-path\", indexPath.path]\n        )\n        \n        // Parse results\n        guard let data = result.data(using: .utf8),\n              let jsonArray = try? JSONSerialization.jsonObject(with: data) as? [[String: Any]] else {\n            throw LEANNError.parsingFailed(\"Invalid JSON response\")\n        }\n        \n        // Check for error in first result\n        if let firstResult = jsonArray.first,\n           let error = firstResult[\"error\"] as? String {\n            throw LEANNError.searchFailed(error)\n        }\n        \n        var results: [CodeSearchResult] = []\n        for item in jsonArray {\n            guard let content = item[\"content\"] as? String,\n                  let score = item[\"score\"] as? Double,\n                  let metadata = item[\"metadata\"] as? [String: Any] else {\n                continue\n            }\n            \n            let filePath = metadata[\"file_path\"] as? String ?? \"unknown\"\n            let fileName = metadata[\"file_name\"] as? String ?? \"unknown\"\n            let fileExtension = metadata[\"file_extension\"] as? String ?? \"\"\n            \n            results.append(CodeSearchResult(\n                content: content,\n                filePath: filePath,\n                fileName: fileName,\n                fileExtension: fileExtension,\n                score: score\n            ))\n        }\n        \n        return results\n    }\n    \n    /// Get the current indexed codebase path\n    public func getIndexedPath() -> String? {\n        if case .indexed(_, let path) = indexingState {\n            return path\n        }\n        return nil\n    }\n    \n    /// Clear the index\n    public func clearIndex() {\n        currentIndexPath = nil\n        indexingState = .notIndexed\n        UserDefaults.standard.removeObject(forKey: Keys.indexedCodebasePath)\n        UserDefaults.standard.removeObject(forKey: Keys.indexPath)\n        UserDefaults.standard.removeObject(forKey: Keys.indexedFileCount)\n    }\n    \n    // MARK: - Private\n    \n    private func runPythonCommand(command: String, arguments: [String]) async throws -> String {\n        return try await withCheckedThrowingContinuation { continuation in\n            let process = Process()\n            process.executableURL = pythonPath\n            process.arguments = [bridgeScriptPath.path, command] + arguments\n            \n            let outputPipe = Pipe()\n            let errorPipe = Pipe()\n            process.standardOutput = outputPipe\n            process.standardError = errorPipe\n            \n            do {\n                try process.run()\n                process.waitUntilExit()\n                \n                let outputData = outputPipe.fileHandleForReading.readDataToEndOfFile()\n                let errorData = errorPipe.fileHandleForReading.readDataToEndOfFile()\n                \n                if process.terminationStatus != 0 {\n                    let errorOutput = String(data: errorData, encoding: .utf8) ?? \"Unknown error\"\n                    continuation.resume(throwing: LEANNError.processError(errorOutput))\n                    return\n                }\n                \n                let output = String(data: outputData, encoding: .utf8) ?? \"\"\n                continuation.resume(returning: output)\n            } catch {\n                continuation.resume(throwing: LEANNError.processError(error.localizedDescription))\n            }\n        }\n    }\n}\n\n/// Result from code search\n@available(macOS 26.0, iOS 26.0, *)\npublic struct CodeSearchResult: Sendable {\n    public let content: String\n    public let filePath: String\n    public let fileName: String\n    public let fileExtension: String\n    public let score: Double\n}\n\n/// Errors for LEANN operations\n@available(macOS 26.0, iOS 26.0, *)\npublic enum LEANNError: Error, LocalizedError, Sendable {\n    case notIndexed\n    case indexingFailed(String)\n    case searchFailed(String)\n    case parsingFailed(String)\n    case processError(String)\n    \n    public var errorDescription: String? {\n        switch self {\n        case .notIndexed:\n            return \"No codebase has been indexed. Please select a codebase directory in Settings.\"\n        case .indexingFailed(let reason):\n            return \"Indexing failed: \\(reason)\"\n        case .searchFailed(let reason):\n            return \"Search failed: \\(reason)\"\n        case .parsingFailed(let reason):\n            return \"Failed to parse response: \\(reason)\"\n        case .processError(let reason):\n            return \"Process error: \\(reason)\"\n        }\n    }\n}\n", "metadata": {"file_path": "LEANNBridgeService.swift", "file_extension": ".swift", "file_name": "LEANNBridgeService.swift", "file_size": 9508, "last_modified": 1766495332.476351}}
{"id": "4", "text": "//\n//  EmbeddingService.swift\n//  FoundationChatCore\n//\n//  Service for generating text embeddings using NaturalLanguage framework\n//\n\nimport Foundation\nimport NaturalLanguage\n\n/// Service for generating text embeddings using NaturalLanguage framework\n@available(macOS 26.0, iOS 26.0, *)\npublic actor EmbeddingService {\n    /// Shared singleton instance\n    public static let shared = EmbeddingService()\n    \n    /// NaturalLanguage embedding model\n    private var embedding: NLEmbedding?\n    \n    /// Cache for embeddings to avoid recomputation\n    private var embeddingCache: [String: [Float]] = [:]\n    \n    /// Maximum cache size\n    private let maxCacheSize = 1000\n    \n    /// Initialize the embedding service\n    private init() {\n        // Try to load the multilingual embedding model\n        // This provides better support for various languages\n        self.embedding = NLEmbedding.wordEmbedding(for: .english)\n        \n        // If English model fails, try multilingual\n        if self.embedding == nil {\n            // Note: NLEmbedding.sentenceEmbedding is available on newer iOS/macOS versions\n            // For now, we'll use word embeddings which are more widely available\n            print(\"âš ï¸ EmbeddingService: Could not load English embedding model\")\n        }\n    }\n    \n    /// Generate embedding for a single text\n    /// - Parameter text: The text to embed\n    /// - Returns: Vector embedding as Float array\n    /// - Throws: EmbeddingError if embedding generation fails\n    public func embed(text: String) async throws -> [Float] {\n        // Check cache first\n        if let cached = embeddingCache[text] {\n            return cached\n        }\n        \n        guard let embedding = embedding else {\n            throw EmbeddingError.modelNotAvailable\n        }\n        \n        // For word embeddings, we need to process the text differently\n        // NLEmbedding.wordEmbedding works on individual words, not sentences\n        // We'll use a sentence-level approach by averaging word embeddings\n        \n        let words = text.components(separatedBy: .whitespacesAndNewlines)\n            .filter { !$0.isEmpty }\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"EmbeddingService.swift:embed\",\n            message: \"Processing text for embedding\",\n            hypothesisId: \"A,B,C\",\n            data: [\n                \"textLength\": text.count,\n                \"textPreview\": String(text.prefix(100)),\n                \"wordCount\": words.count,\n                \"wordsPreview\": Array(words.prefix(10))\n            ]\n        )\n        // #endregion\n        \n        guard !words.isEmpty else {\n            // #region debug log\n            await DebugLogger.shared.log(\n                location: \"EmbeddingService.swift:embed\",\n                message: \"Empty words array, returning zero vector\",\n                hypothesisId: \"B\",\n                data: [\n                    \"textLength\": text.count,\n                    \"textPreview\": String(text.prefix(100))\n                ]\n            )\n            // #endregion\n            // Return zero vector for empty text\n            return Array(repeating: 0.0, count: 300) // Default dimension\n        }\n        \n        var embeddingVectors: [[Double]] = []\n        var wordsWithEmbeddings: [String] = []\n        var wordsWithoutEmbeddings: [String] = []\n        \n        for word in words {\n            // Get embedding for each word\n            if let vector = embedding.vector(for: word.lowercased()) {\n                embeddingVectors.append(vector)\n                wordsWithEmbeddings.append(word)\n            } else {\n                wordsWithoutEmbeddings.append(word)\n            }\n        }\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"EmbeddingService.swift:embed\",\n            message: \"Word embedding results\",\n            hypothesisId: \"A,B,C\",\n            data: [\n                \"totalWords\": words.count,\n                \"wordsWithEmbeddings\": wordsWithEmbeddings.count,\n                \"wordsWithoutEmbeddings\": wordsWithoutEmbeddings.count,\n                \"wordsWithoutEmbeddingsPreview\": Array(wordsWithoutEmbeddings.prefix(20)),\n                \"embeddingVectorsCount\": embeddingVectors.count\n            ]\n        )\n        // #endregion\n        \n        guard !embeddingVectors.isEmpty else {\n            // #region debug log\n            await DebugLogger.shared.log(\n                location: \"EmbeddingService.swift:embed\",\n                message: \"No embeddings generated - throwing error\",\n                hypothesisId: \"A,B,C\",\n                data: [\n                    \"textLength\": text.count,\n                    \"textPreview\": String(text.prefix(200)),\n                    \"wordCount\": words.count,\n                    \"wordsWithoutEmbeddings\": Array(wordsWithoutEmbeddings.prefix(50))\n                ]\n            )\n            // #endregion\n            throw EmbeddingError.embeddingGenerationFailed(\"No embeddings generated for text\")\n        }\n        \n        // Average the word embeddings to get a sentence-level embedding\n        let dimension = embeddingVectors[0].count\n        var averagedVector = [Double](repeating: 0.0, count: dimension)\n        \n        for vector in embeddingVectors {\n            for (index, value) in vector.enumerated() {\n                averagedVector[index] += value\n            }\n        }\n        \n        // Divide by count to get average\n        let count = Double(embeddingVectors.count)\n        for index in 0..<averagedVector.count {\n            averagedVector[index] /= count\n        }\n        \n        // Convert to Float array\n        let floatVector = averagedVector.map { Float($0) }\n        \n        // Cache the result\n        cacheEmbedding(text: text, embedding: floatVector)\n        \n        return floatVector\n    }\n    \n    /// Generate embeddings for multiple texts in batch\n    /// - Parameter texts: Array of texts to embed\n    /// - Returns: Array of embeddings\n    /// - Throws: EmbeddingError if embedding generation fails\n    public func embedBatch(texts: [String]) async throws -> [[Float]] {\n        var results: [[Float]] = []\n        \n        for text in texts {\n            let embedding = try await embed(text: text)\n            results.append(embedding)\n        }\n        \n        return results\n    }\n    \n    /// Cache an embedding result\n    /// - Parameters:\n    ///   - text: The original text\n    ///   - embedding: The generated embedding\n    private func cacheEmbedding(text: String, embedding: [Float]) {\n        // If cache is full, remove oldest entries (simple FIFO)\n        if embeddingCache.count >= maxCacheSize {\n            // Remove first 10% of cache\n            let keysToRemove = Array(embeddingCache.keys.prefix(maxCacheSize / 10))\n            for key in keysToRemove {\n                embeddingCache.removeValue(forKey: key)\n            }\n        }\n        \n        embeddingCache[text] = embedding\n    }\n    \n    /// Clear the embedding cache\n    public func clearCache() {\n        embeddingCache.removeAll()\n    }\n    \n    /// Get the dimension of embeddings\n    /// - Returns: Embedding dimension (default: 300 for word embeddings)\n    public nonisolated func embeddingDimension() -> Int {\n        // NaturalLanguage word embeddings typically have 300 dimensions\n        // This may vary by model, but 300 is a safe default\n        return 300\n    }\n}\n\n/// Errors for embedding operations\n@available(macOS 26.0, iOS 26.0, *)\npublic enum EmbeddingError: Error, LocalizedError, Sendable {\n    case modelNotAvailable\n    case embeddingGenerationFailed(String)\n    \n    public var errorDescription: String? {\n        switch self {\n        case .modelNotAvailable:\n            return \"NaturalLanguage embedding model is not available\"\n        case .embeddingGenerationFailed(let reason):\n            return \"Failed to generate embedding: \\(reason)\"\n        }\n    }\n}\n", "metadata": {"file_path": "EmbeddingService.swift", "file_extension": ".swift", "file_name": "EmbeddingService.swift", "file_size": 7975, "last_modified": 1766491017.6374438}}
{"id": "5", "text": "//\n//  FileManagerService.swift\n//  FoundationChatCore\n//\n//  Service for managing file operations in the app sandbox\n//\n\nimport Foundation\nimport UniformTypeIdentifiers\n\n/// Service for managing file operations in the app sandbox\n@available(macOS 26.0, iOS 26.0, *)\npublic actor FileManagerService {\n    /// Shared singleton instance\n    public static let shared = FileManagerService()\n    \n    /// File manager instance\n    private let fileManager: FileManager\n    \n    /// Base directory for file storage\n    private let baseDirectory: URL\n    \n    /// Initialize the file manager service\n    public init() {\n        self.fileManager = FileManager.default\n        \n        // Get Application Support directory\n        let appSupport = try! fileManager.url(\n            for: .applicationSupportDirectory,\n            in: .userDomainMask,\n            appropriateFor: nil,\n            create: true\n        )\n        \n        // Create FoundationChat/Files subdirectory\n        self.baseDirectory = appSupport.appendingPathComponent(\"FoundationChat\", isDirectory: true)\n            .appendingPathComponent(\"Files\", isDirectory: true)\n        \n        // Create base directory if it doesn't exist\n        try? fileManager.createDirectory(at: baseDirectory, withIntermediateDirectories: true)\n    }\n    \n    /// Get the sandbox directory for file storage\n    /// - Returns: Base directory URL\n    public func getSandboxDirectory() -> URL {\n        return baseDirectory\n    }\n    \n    /// Copy a file to the sandbox\n    /// - Parameters:\n    ///   - fileURL: Source file URL\n    ///   - conversationId: Conversation ID to organize files\n    /// - Returns: FileAttachment with sandbox path\n    /// - Throws: Error if copy fails\n    public func copyToSandbox(fileURL: URL, conversationId: UUID) async throws -> FileAttachment {\n        // Get file attributes\n        let attributes = try fileManager.attributesOfItem(atPath: fileURL.path)\n        let fileSize = attributes[.size] as? Int64 ?? 0\n        \n        // Get original filename\n        let originalName = fileURL.lastPathComponent\n        \n        // Get MIME type if available\n        let mimeType = getMimeType(for: fileURL)\n        \n        // Create conversation directory\n        let conversationDir = baseDirectory.appendingPathComponent(conversationId.uuidString, isDirectory: true)\n        try fileManager.createDirectory(at: conversationDir, withIntermediateDirectories: true)\n        \n        // Generate unique file ID\n        let fileId = UUID()\n        \n        // Create file directory\n        let fileDir = conversationDir.appendingPathComponent(fileId.uuidString, isDirectory: true)\n        try fileManager.createDirectory(at: fileDir, withIntermediateDirectories: true)\n        \n        // Destination file path\n        let destinationURL = fileDir.appendingPathComponent(originalName)\n        \n        // Copy file\n        try fileManager.copyItem(at: fileURL, to: destinationURL)\n        \n        // Create attachment\n        let attachment = FileAttachment(\n            id: fileId,\n            originalName: originalName,\n            sandboxPath: destinationURL.path,\n            fileSize: fileSize,\n            mimeType: mimeType\n        )\n        \n        // Trigger RAG indexing in background (don't block file copy if indexing fails)\n        Task {\n            do {\n                let ragService = RAGService.shared\n                try await ragService.indexFile(attachment: attachment, conversationId: conversationId)\n                print(\"âœ… RAGService: Successfully indexed file \\(originalName)\")\n            } catch {\n                // Log error but don't fail file copy\n                print(\"âš ï¸ RAGService: Failed to index file \\(originalName): \\(error.localizedDescription)\")\n            }\n        }\n        \n        // Return attachment\n        return attachment\n    }\n    \n    /// Delete a single file from sandbox\n    /// - Parameter attachment: File attachment to delete\n    /// - Throws: Error if deletion fails\n    public func deleteFile(attachment: FileAttachment) async throws {\n        let fileURL = URL(fileURLWithPath: attachment.sandboxPath)\n        \n        // Delete the file\n        if fileManager.fileExists(atPath: fileURL.path) {\n            try fileManager.removeItem(at: fileURL)\n        }\n        \n        // Try to delete parent directory if empty\n        let parentDir = fileURL.deletingLastPathComponent()\n        try? fileManager.removeItem(at: parentDir)\n    }\n    \n    /// Delete all files for a conversation\n    /// - Parameter conversationId: Conversation ID\n    /// - Throws: Error if deletion fails\n    public func deleteFilesForConversation(conversationId: UUID) async throws {\n        let conversationDir = baseDirectory.appendingPathComponent(conversationId.uuidString, isDirectory: true)\n        \n        // Check if directory exists\n        guard fileManager.fileExists(atPath: conversationDir.path) else {\n            return // Nothing to delete\n        }\n        \n        // Delete RAG indexes for this conversation\n        do {\n            let ragService = RAGService.shared\n            try await ragService.deleteConversationIndexes(conversationId: conversationId)\n        } catch {\n            // Log error but continue with file deletion\n            print(\"âš ï¸ FileManagerService: Failed to delete RAG indexes for conversation \\(conversationId): \\(error.localizedDescription)\")\n        }\n        \n        // Delete entire conversation directory\n        try fileManager.removeItem(at: conversationDir)\n    }\n    \n    /// Read file data from sandbox\n    /// - Parameter attachment: File attachment to read\n    /// - Returns: File data\n    /// - Throws: Error if read fails\n    public func readFile(attachment: FileAttachment) async throws -> Data {\n        let fileURL = URL(fileURLWithPath: attachment.sandboxPath)\n        return try Data(contentsOf: fileURL)\n    }\n    \n    /// Get MIME type for a file URL\n    /// - Parameter url: File URL\n    /// - Returns: MIME type string if available\n    private func getMimeType(for url: URL) -> String? {\n        if let resourceValues = try? url.resourceValues(forKeys: [.typeIdentifierKey]),\n           let typeIdentifier = resourceValues.typeIdentifier,\n           let mimeType = UTType(typeIdentifier)?.preferredMIMEType {\n            return mimeType\n        }\n        \n        // Fallback: use file extension\n        let pathExtension = url.pathExtension\n        if !pathExtension.isEmpty,\n           let type = UTType(filenameExtension: pathExtension),\n           let mimeType = type.preferredMIMEType {\n            return mimeType\n        }\n        \n        return nil\n    }\n}\n\n", "metadata": {"file_path": "FileManagerService.swift", "file_extension": ".swift", "file_name": "FileManagerService.swift", "file_size": 6662, "last_modified": 1766491017.6332607}}
{"id": "6", "text": "//\n//  TokenCounter.swift\n//  FoundationChatCore\n//\n//  Service for estimating token counts in text\n//\n\nimport Foundation\nimport FoundationModels\n\n/// Service for counting tokens in text\n/// Uses rough estimation: 4 characters â‰ˆ 1 token for English text\n@available(macOS 26.0, iOS 26.0, *)\npublic actor TokenCounter {\n    /// Cache for token counts to avoid recalculation\n    private var cache: [String: Int] = [:]\n    \n    /// Maximum cache size to prevent memory issues\n    private let maxCacheSize = 1000\n    \n    public init() {}\n    \n    /// Estimate token count for a string\n    /// - Parameter text: The text to count tokens for\n    /// - Returns: Estimated token count\n    public func countTokens(_ text: String) -> Int {\n        // Check cache first\n        if let cached = cache[text] {\n            return cached\n        }\n        \n        // Rough estimation: 4 characters â‰ˆ 1 token for English\n        // More accurate for code: 3 characters â‰ˆ 1 token\n        // We'll use 4 as a conservative estimate\n        let charCount = text.count\n        let estimatedTokens = (charCount + 3) / 4\n        \n        // Cache the result\n        cacheResult(text, count: estimatedTokens)\n        \n        return estimatedTokens\n    }\n    \n    /// Count tokens for a message\n    /// - Parameter message: The message to count tokens for\n    /// - Returns: Estimated token count\n    public func countTokens(_ message: Message) -> Int {\n        var total = 0\n        \n        // Count content\n        total += countTokens(message.content)\n        \n        // Count role (small overhead)\n        total += 2 // \"user\" or \"assistant\" â‰ˆ 2 tokens\n        \n        // Count tool calls if present\n        for toolCall in message.toolCalls {\n            total += countTokens(toolCall.toolName)\n            total += countTokens(toolCall.arguments)\n            if let result = toolCall.result {\n                total += countTokens(result)\n            }\n        }\n        \n        return total\n    }\n    \n    /// Count tokens for multiple messages\n    /// - Parameter messages: Array of messages\n    /// - Returns: Total estimated token count\n    public func countTokens(_ messages: [Message]) -> Int {\n        return messages.reduce(0) { $0 + countTokens($1) }\n    }\n    \n    /// Count tokens for a transcript entry\n    /// - Parameter entry: Transcript entry\n    /// - Returns: Estimated token count\n    public func countTokens(_ entry: Transcript.Entry) -> Int {\n        // Handle known cases from FoundationModels\n        if case .prompt(let prompt) = entry {\n            return countTokensForPrompt(prompt)\n        } else if case .response(let response) = entry {\n            return countTokensForResponse(response)\n        } else if case .toolOutput(let toolOutput) = entry {\n            return countTokensForToolOutput(toolOutput)\n        }\n        \n        // Fallback for any other cases\n        return 0\n    }\n    \n    /// Count tokens for tool output\n    private func countTokensForToolOutput(_ toolOutput: Transcript.ToolOutput) -> Int {\n        var total = 0\n        for segment in toolOutput.segments {\n            if case .text(let textSegment) = segment {\n                total += countTokens(textSegment.content)\n            }\n        }\n        return total\n    }\n    \n    /// Count tokens for a full transcript\n    /// - Parameter transcript: The transcript\n    /// - Returns: Total estimated token count\n    /// Note: Transcript API structure may vary - this is a simplified implementation\n    public func countTokens(_ transcript: Transcript) -> Int {\n        // Since Transcript structure is not directly accessible,\n        // we'll estimate based on a rough approximation\n        // This method may need adjustment based on actual API\n        return 0\n    }\n    \n    /// Count tokens for a prompt\n    private func countTokensForPrompt(_ prompt: Transcript.Prompt) -> Int {\n        var total = 0\n        for segment in prompt.segments {\n            if case .text(let textSegment) = segment {\n                total += countTokens(textSegment.content)\n            }\n            // Assets don't contribute to token count in text context\n        }\n        return total\n    }\n    \n    /// Count tokens for a response\n    private func countTokensForResponse(_ response: Transcript.Response) -> Int {\n        var total = 0\n        for segment in response.segments {\n            if case .text(let textSegment) = segment {\n                total += countTokens(textSegment.content)\n            }\n            // Assets don't contribute to token count in text context\n        }\n        return total\n    }\n    \n    /// Cache a result, evicting oldest entries if cache is full\n    private func cacheResult(_ text: String, count: Int) {\n        // Simple cache eviction: if cache is full, clear it\n        // In a production system, you might use LRU eviction\n        if cache.count >= maxCacheSize {\n            cache.removeAll()\n        }\n        cache[text] = count\n    }\n    \n    /// Clear the cache\n    public func clearCache() {\n        cache.removeAll()\n    }\n}\n\n", "metadata": {"file_path": "TokenCounter.swift", "file_extension": ".swift", "file_name": "TokenCounter.swift", "file_size": 5069, "last_modified": 1766491017.4832575}}
{"id": "7", "text": "//\n//  MessageCompactor.swift\n//  FoundationChatCore\n//\n//  Service for compacting message history to fit within token limits\n//\n\nimport Foundation\n\n/// Service for compacting message history\n@available(macOS 26.0, iOS 26.0, *)\npublic actor MessageCompactor {\n    /// Token counter\n    private let tokenCounter = TokenCounter()\n    \n    /// Context summarizer\n    private let summarizer = ContextSummarizer()\n    \n    /// Number of recent messages to keep full (default: 5)\n    public var recentMessagesCount: Int = 5\n    \n    public init(recentMessagesCount: Int = 5) {\n        self.recentMessagesCount = recentMessagesCount\n    }\n    \n    /// Compact messages to fit within token budget\n    /// - Parameters:\n    ///   - messages: Messages to compact\n    ///   - maxTokens: Maximum token budget\n    /// - Returns: Compacted messages (recent messages + summary of older ones)\n    public func compact(messages: [Message], maxTokens: Int) async throws -> [Message] {\n        guard !messages.isEmpty else {\n            return []\n        }\n        \n        // If messages fit within budget, return as-is\n        let totalTokens = await tokenCounter.countTokens(messages)\n        if totalTokens <= maxTokens {\n            return messages\n        }\n        \n        // Split messages into recent and old\n        let recentMessages = Array(messages.suffix(recentMessagesCount))\n        let oldMessages = Array(messages.dropLast(recentMessagesCount))\n        \n        guard !oldMessages.isEmpty else {\n            // All messages are recent, but still over budget\n            // Truncate oldest recent messages\n            return try await truncateMessages(messages, maxTokens: maxTokens)\n        }\n        \n        // Count tokens for recent messages\n        let recentTokens = await tokenCounter.countTokens(recentMessages)\n        \n        // Calculate available tokens for summary\n        let availableForSummary = maxTokens - recentTokens - AppConstants.tokenReserveOverhead\n        \n        guard availableForSummary > AppConstants.minimumTokensForSummary else {\n            // Not enough space for summary, just keep recent messages\n            return recentMessages\n        }\n        \n        // Summarize old messages\n        let summary = try await summarizer.summarize(oldMessages, level: .heavy)\n        \n        // Create summary message\n        let summaryMessage = Message(\n            role: .system,\n            content: \"Previous conversation summary: \\(summary)\"\n        )\n        \n        // Combine summary + recent messages\n        return [summaryMessage] + recentMessages\n    }\n    \n    /// Compact messages using sliding window strategy\n    /// - Parameters:\n    ///   - messages: Messages to compact\n    ///   - maxTokens: Maximum token budget\n    /// - Returns: Compacted messages\n    public func compactSlidingWindow(messages: [Message], maxTokens: Int) async throws -> [Message] {\n        guard !messages.isEmpty else {\n            return []\n        }\n        \n        // Start from most recent and work backwards\n        var result: [Message] = []\n        var currentTokens = 0\n        \n        // Reserve tokens for potential summary\n        let availableTokens = maxTokens - 100\n        \n        for message in messages.reversed() {\n            let messageTokens = await tokenCounter.countTokens(message)\n            \n            if currentTokens + messageTokens <= availableTokens {\n                result.insert(message, at: 0)\n                currentTokens += messageTokens\n            } else {\n                // Remaining messages need to be summarized\n                let remainingMessages = Array(messages.prefix(messages.count - result.count))\n                if !remainingMessages.isEmpty {\n                    let summary = try await summarizer.summarize(remainingMessages, level: .heavy)\n                    let summaryMessage = Message(\n                        role: .system,\n                        content: \"Previous conversation summary: \\(summary)\"\n                    )\n                    result.insert(summaryMessage, at: 0)\n                }\n                break\n            }\n        }\n        \n        return result\n    }\n    \n    /// Compact messages with selective summarization\n    /// - Parameters:\n    ///   - messages: Messages to compact\n    ///   - maxTokens: Maximum token budget\n    ///   - recentCount: Number of recent messages to keep full\n    /// - Returns: Compacted messages\n    public func compactSelective(\n        messages: [Message],\n        maxTokens: Int,\n        recentCount: Int = 5\n    ) async throws -> [Message] {\n        guard !messages.isEmpty else {\n            return []\n        }\n        \n        // Keep recent messages full\n        let recentMessages = Array(messages.suffix(recentCount))\n        let oldMessages = Array(messages.dropLast(recentCount))\n        \n        guard !oldMessages.isEmpty else {\n            return recentMessages\n        }\n        \n        // Calculate available tokens\n        let recentTokens = await tokenCounter.countTokens(recentMessages)\n        let availableForOld = maxTokens - recentTokens - AppConstants.tokenReserveOverhead\n        \n        guard availableForOld > AppConstants.minimumTokensForSummary else {\n            return recentMessages\n        }\n        \n        // Group old messages by time or topic (simple: by position)\n        let chunkSize = max(1, oldMessages.count / 3)\n        var compactedOld: [Message] = []\n        \n        for i in stride(from: 0, to: oldMessages.count, by: chunkSize) {\n            let chunk = Array(oldMessages[i..<min(i + chunkSize, oldMessages.count)])\n            let summary = try await summarizer.summarize(chunk, level: .medium)\n            let summaryMessage = Message(\n                role: .system,\n                content: \"Summary: \\(summary)\"\n            )\n            compactedOld.append(summaryMessage)\n        }\n        \n        // Check if compacted old messages fit\n        let compactedTokens = await tokenCounter.countTokens(compactedOld)\n        if recentTokens + compactedTokens <= maxTokens {\n            return compactedOld + recentMessages\n        } else {\n            // Still too large, summarize all old messages together\n            let fullSummary = try await summarizer.summarize(oldMessages, level: .heavy)\n            let summaryMessage = Message(\n                role: .system,\n                content: \"Previous conversation summary: \\(fullSummary)\"\n            )\n            return [summaryMessage] + recentMessages\n        }\n    }\n    \n    /// Truncate messages if they exceed token budget\n    /// - Parameters:\n    ///   - messages: Messages to truncate\n    ///   - maxTokens: Maximum token budget\n    /// - Returns: Truncated messages\n    private func truncateMessages(_ messages: [Message], maxTokens: Int) async throws -> [Message] {\n        var result: [Message] = []\n        var currentTokens = 0\n        \n        // Keep messages from most recent\n        for message in messages.reversed() {\n            let messageTokens = await tokenCounter.countTokens(message)\n            if currentTokens + messageTokens <= maxTokens {\n                result.insert(message, at: 0)\n                currentTokens += messageTokens\n            } else {\n                break\n            }\n        }\n        \n        return result\n    }\n}\n\n\n\n", "metadata": {"file_path": "MessageCompactor.swift", "file_extension": ".swift", "file_name": "MessageCompactor.swift", "file_size": 7324, "last_modified": 1766491017.6333525}}
{"id": "8", "text": "//\n//  AgentService.swift\n//  FoundationChatCore\n//\n//  High-level service for agent operations and lifecycle management\n//\n\nimport Foundation\n\n/// Service for managing agent operations\n@available(macOS 26.0, iOS 26.0, *)\npublic actor AgentService {\n    /// Shared singleton instance\n    public static let shared = AgentService()\n    \n    /// Agent registry\n    private let registry: AgentRegistry\n    \n    /// Agent orchestrator\n    private let orchestrator: AgentOrchestrator\n    \n    /// Active agent contexts per conversation\n    private var conversationContexts: [UUID: AgentContext] = [:]\n    \n    /// Track initialization state to prevent race conditions\n    private var isInitializing = false\n    private var initializationTask: Task<Void, Never>?\n    \n    /// Initialize the agent service\n    /// - Parameters:\n    ///   - registry: Agent registry (defaults to shared)\n    ///   - orchestrator: Agent orchestrator\n    public init(\n        registry: AgentRegistry = .shared,\n        orchestrator: AgentOrchestrator? = nil\n    ) {\n        print(\"ðŸ¤– AgentService init() starting...\")\n        self.registry = registry\n        self.orchestrator = orchestrator ?? AgentOrchestrator(registry: registry)\n        print(\"âœ… AgentService init() complete (agents will be initialized lazily via ensureAgentsInitialized())\")\n    }\n    \n    /// Initialize default agents\n    private func initializeDefaultAgents() async {\n        print(\"ðŸ¤– Registering FileReaderAgent...\")\n        await registry.register(FileReaderAgent())\n        print(\"âœ… FileReaderAgent registered\")\n        \n        print(\"ðŸ¤– Registering WebSearchAgent...\")\n        await registry.register(WebSearchAgent())\n        print(\"âœ… WebSearchAgent registered\")\n        \n        print(\"ðŸ¤– Registering CodeAnalysisAgent...\")\n        await registry.register(CodeAnalysisAgent())\n        print(\"âœ… CodeAnalysisAgent registered\")\n        \n        print(\"ðŸ¤– Registering DataAnalysisAgent...\")\n        await registry.register(DataAnalysisAgent())\n        print(\"âœ… DataAnalysisAgent registered\")\n        \n        print(\"ðŸ¤– Registering VisionAgent...\")\n        await registry.register(VisionAgent())\n        print(\"âœ… VisionAgent registered\")\n        \n        // Create a coordinator agent\n        // **Status**: âš ï¸ Basic Agent - No special tools, just general reasoning\n        // Used for orchestrating multi-agent workflows\n        print(\"ðŸ¤– Creating coordinator agent...\")\n        let coordinator = BaseAgent(\n            id: AgentId.coordinator,\n            name: AgentName.coordinator,\n            description: \"Coordinates tasks and delegates to specialized agents\",\n            capabilities: [.generalReasoning]\n        )\n        print(\"âœ… Coordinator agent created, registering...\")\n        await registry.register(coordinator)\n        print(\"âœ… Coordinator registered\")\n        \n        // Set default pattern\n        print(\"ðŸ¤– Setting default orchestration pattern...\")\n        if let coordinatorAgent = await registry.getAgent(byId: coordinator.id) {\n            await orchestrator.setPattern(OrchestratorPattern(coordinator: coordinatorAgent))\n            print(\"âœ… Orchestration pattern set\")\n        }\n        print(\"âœ… All default agents initialized\")\n    }\n    \n    /// Process a message in an agent conversation\n    /// - Parameters:\n    ///   - message: User message\n    ///   - conversationId: Conversation ID\n    ///   - conversation: The conversation\n    ///   - tokenBudget: Optional token budget constraint\n    ///   - progressTracker: Optional progress tracker for visualization\n    /// - Returns: Agent result\n    public func processMessage(\n        _ message: String,\n        conversationId: UUID,\n        conversation: Conversation,\n        tokenBudget: Int? = nil,\n        progressTracker: OrchestrationProgressTracker? = nil\n    ) async throws -> AgentResult {\n        print(\"ðŸ¤– AgentService.processMessage() called with message: \\(message.prefix(50))...\")\n        \n        let baseContext = conversationContexts[conversationId] ?? AgentContext()\n        let context = await ContextAssemblyService.shared.assemble(\n            baseContext: baseContext,\n            conversationId: conversationId,\n            conversation: conversation,\n            currentMessage: message\n        )\n        \n        print(\"ðŸ¤– Conversation history updated (\\(context.conversationHistory.count) messages from \\(conversation.messages.count) total)\")\n        print(\"ðŸ¤– File references: \\(context.fileReferences.count) files\")\n        \n        // Create task\n        let task = AgentTask(\n            description: message,\n            requiredCapabilities: extractRequiredCapabilities(from: message),\n            parameters: [:]\n        )\n        print(\"ðŸ¤– Task created with capabilities: \\(task.requiredCapabilities)\")\n        \n        // Get agent configuration\n        guard let config = conversation.agentConfiguration else {\n            print(\"âŒ No agent configuration found\")\n            throw AgentServiceError.noAgentConfiguration\n        }\n        print(\"ðŸ¤– Agent configuration found: \\(config.selectedAgents.count) agents selected\")\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"AgentService.swift:processMessage\",\n            message: \"About to call orchestrator.execute()\",\n            hypothesisId: \"A,D\",\n            data: [\n                \"selectedAgentCount\": config.selectedAgents.count,\n                \"selectedAgentIds\": config.selectedAgents.map { $0.uuidString },\n                \"willPassAgentIds\": config.selectedAgents.isEmpty ? \"nil\" : \"array\"\n            ]\n        )\n        // #endregion\n        \n        // Execute task\n        print(\"ðŸ¤– Calling orchestrator.execute()...\")\n        let result = try await orchestrator.execute(\n            task: task,\n            context: context,\n            agentIds: config.selectedAgents.isEmpty ? nil : config.selectedAgents,\n            progressTracker: progressTracker\n        )\n        print(\"âœ… Orchestrator.execute() completed\")\n        \n        // Extract and log token usage from result\n        if let updated = result.updatedContext {\n            // Log detailed token breakdown\n            if let coordinatorInput = updated.metadata[\"tokens_\\(result.agentId.uuidString.prefix(8))_input\"],\n               let coordinatorOutput = updated.metadata[\"tokens_\\(result.agentId.uuidString.prefix(8))_output\"],\n               let totalTokens = updated.metadata[\"tokens_total_task\"],\n               let savings = updated.metadata[\"tokens_saved_vs_single_agent\"] {\n                print(\"ðŸ“Š AgentService: Token breakdown:\")\n                print(\"  - Coordinator input: \\(coordinatorInput) tokens\")\n                print(\"  - Coordinator output: \\(coordinatorOutput) tokens\")\n                print(\"  - Total tokens: \\(totalTokens)\")\n                print(\"  - Token savings: \\(savings)%\")\n            }\n            \n            // Check budget if provided\n            if let budget = tokenBudget,\n               let totalStr = updated.metadata[\"tokens_total_task\"],\n               let total = Int(totalStr) {\n                if total > budget {\n                    print(\"âš ï¸ AgentService: Token usage (\\(total)) exceeds budget (\\(budget))\")\n                } else if Double(total) >= Double(budget) * 0.8 {\n                    print(\"âš ï¸ AgentService: Approaching token budget (\\(total)/\\(budget))\")\n                }\n            }\n            \n            conversationContexts[conversationId] = updated\n            \n            // Store total token usage in conversation metadata (if conversation supports it)\n            // Note: This would require updating Conversation model to support metadata\n        }\n        \n        return result\n    }\n    \n    /// Process a message with a single agent (no orchestrator)\n    /// This is used when orchestrator mode is disabled - direct single-agent processing\n    /// - Parameters:\n    ///   - message: User message\n    ///   - agentId: Selected agent ID\n    ///   - conversationId: Conversation ID\n    ///   - conversation: The conversation\n    /// - Returns: Agent result\n    public func processSingleAgentMessage(\n        _ message: String,\n        agentId: UUID,\n        conversationId: UUID,\n        conversation: Conversation,\n        fileReferences: [String] = []\n    ) async throws -> AgentResult {\n        print(\"ðŸ¤– AgentService.processSingleAgentMessage() called for agent: \\(agentId)\")\n        \n        // Resolve agent (with fallback logic for ID mismatches)\n        let resolvedAgent = try await resolveAgent(byId: agentId)\n        \n        print(\"âœ… Agent found: \\(resolvedAgent.name)\")\n        \n        let baseContext = conversationContexts[conversationId] ?? AgentContext()\n        let context = await ContextAssemblyService.shared.assemble(\n            baseContext: baseContext,\n            conversationId: conversationId,\n            conversation: conversation,\n            fileReferences: fileReferences,\n            currentMessage: message\n        )\n        \n        print(\"ðŸ¤– Conversation history updated (\\(context.conversationHistory.count) messages from \\(conversation.messages.count) total)\")\n        print(\"ðŸ¤– File references: \\(context.fileReferences.count) files\")\n        \n        // #region debug log\n        await DebugLogger.shared.log(\n            location: \"AgentService.swift:processSingleAgentMessage\",\n            message: \"Context built for agent\",\n            hypothesisId: \"A\",\n            data: [\n                \"agentId\": agentId.uuidString,\n                \"agentName\": resolvedAgent.name,\n                \"fileReferencesCount\": context.fileReferences.count,\n                \"fileReferences\": context.fileReferences,\n                \"message\": message\n            ]\n        )\n        // #endregion\n        \n        // Create a simple task for the agent\n        let task = AgentTask(\n            description: message,\n            requiredCapabilities: [],\n            parameters: [:]\n        )\n        \n        // Process the task directly with the agent (no orchestration)\n        print(\"ðŸ¤– Processing task directly with agent: \\(resolvedAgent.name)...\")\n        \n        // Debug logging\n        await logAgentProcessing(agent: resolvedAgent, task: task, context: context)\n        \n        let result = try await resolvedAgent.process(task: task, context: context)\n        print(\"âœ… Agent processing completed\")\n        \n        // Debug logging for result\n        await logAgentResult(agent: resolvedAgent, result: result)\n        \n        // Update conversation context\n        if let updated = result.updatedContext {\n            conversationContexts[conversationId] = updated\n        }\n        \n        return result\n    }\n    \n    /// Get available agents\n    /// - Returns: Array of all registered agents\n    public func getAvailableAgents() async -> [any Agent] {\n        print(\"ðŸ”§ getAvailableAgents() called...\")\n        // Ensure agents are initialized (idempotent)\n        await ensureAgentsInitialized()\n        let agents = await registry.listAll()\n        print(\"ðŸ”§ Returning \\(agents.count) agents\")\n        return agents\n    }\n    \n    /// Check if all default agents are registered\n    private func hasAllDefaultAgents() async -> Bool {\n        let expectedAgentNames: Set<String> = [\n            AgentName.fileReader,\n            AgentName.webSearch,\n            AgentName.codeAnalysis,\n            AgentName.dataAnalysis,\n            AgentName.visionAgent,\n            AgentName.coordinator\n        ]\n        \n        let existing = await registry.listAll()\n        let existingNames = Set(existing.map { $0.name })\n        \n        let hasAll = expectedAgentNames.isSubset(of: existingNames)\n        if !hasAll {\n            let missing = expectedAgentNames.subtracting(existingNames)\n            print(\"âš ï¸ Missing agents: \\(missing.joined(separator: \", \"))\")\n        }\n        return hasAll\n    }\n    \n    /// Ensure agents are initialized (idempotent)\n    private func ensureAgentsInitialized() async {\n        // Check if all expected agents are already initialized\n        if await hasAllDefaultAgents() {\n            let existing = await registry.listAll()\n            print(\"ðŸ”§ All default agents already initialized (\\(existing.count) found)\")\n            return\n        }\n        \n        // Check if initialization is in progress\n        if isInitializing {\n            print(\"ðŸ”§ Agent initialization already in progress, waiting...\")\n            // Wait for the existing initialization task to complete\n            if let task = initializationTask {\n                await task.value\n            }\n            // After waiting, check again if all agents are present\n            if await hasAllDefaultAgents() {\n                return\n            }\n            // If still missing, continue to initialize\n        }\n        \n        // Start initialization\n        isInitializing = true\n        let existing = await registry.listAll()\n        print(\"ðŸ”§ Initializing default agents (currently \\(existing.count) agents found)...\")\n        \n        let task = Task {\n            await initializeDefaultAgents()\n            isInitializing = false\n        }\n        \n        initializationTask = task\n        await task.value\n        \n        // Verify all agents were registered\n        if await hasAllDefaultAgents() {\n            let final = await registry.listAll()\n            print(\"âœ… All default agents initialized (\\(final.count) agents)\")\n        } else {\n            print(\"âš ï¸ Warning: Some agents may not have been initialized\")\n        }\n    }\n    \n    /// Get agents by capability\n    /// - Parameter capability: The capability\n    /// - Returns: Array of agents with that capability\n    public func getAgents(byCapability capability: AgentCapability) async -> [any Agent] {\n        return await registry.getAgents(byCapability: capability)\n    }\n    \n    /// Create a new agent conversation configuration\n    /// - Parameters:\n    ///   - agentIds: Selected agent IDs\n    ///   - pattern: Orchestration pattern\n    /// - Returns: Agent configuration\n    public func createAgentConfiguration(\n        agentIds: [UUID],\n        pattern: OrchestrationPatternType = .orchestrator\n    ) async -> AgentConfiguration {\n        // Validate agent IDs\n        let validIds = await validateAgentIds(agentIds)\n        \n        return AgentConfiguration(\n            selectedAgents: validIds,\n            orchestrationPattern: pattern,\n            agentSettings: [:]\n        )\n    }\n    \n    /// Validate agent IDs\n    /// - Parameter ids: Agent IDs to validate\n    /// - Returns: Valid agent IDs\n    private func validateAgentIds(_ ids: [UUID]) async -> [UUID] {\n        var validIds: [UUID] = []\n        \n        for id in ids {\n            if await registry.getAgent(byId: id) != nil {\n                validIds.append(id)\n            }\n        }\n        \n        return validIds\n    }\n    \n    /// Clear context for a conversation\n    /// - Parameter conversationId: Conversation ID\n    public func clearContext(for conversationId: UUID) {\n        conversationContexts.removeValue(forKey: conversationId)\n    }\n    \n    /// Extract required capabilities from a message\n    /// - Parameter message: The message\n    /// - Returns: Set of required capabilities\n    private func extractRequiredCapabilities(from message: String) -> Set<AgentCapability> {\n        let lowercased = message.lowercased()\n        var capabilities: Set<AgentCapability> = []\n        \n        // Simple keyword-based detection\n        if lowercased.contains(\"file\") || lowercased.contains(\"read\") || lowercased.contains(\"document\") {\n            capabilities.insert(.fileReading)\n        }\n        \n        if lowercased.contains(\"search\") || lowercased.contains(\"look up\") || lowercased.contains(\"find\") {\n            capabilities.insert(.webSearch)\n        }\n        \n        if lowercased.contains(\"code\") || lowercased.contains(\"analyze\") || lowercased.contains(\"swift\") {\n            capabilities.insert(.codeAnalysis)\n        }\n        \n        if lowercased.contains(\"data\") || lowercased.contains(\"calculate\") || lowercased.contains(\"statistics\") {\n            capabilities.insert(.dataAnalysis)\n        }\n        \n        return capabilities\n    }\n    \n    // MARK: - Helper Methods\n    \n    // Context assembly is handled by ContextAssemblyService.\n    \n    /// Resolve agent by ID with fallback logic\n    /// - Parameter agentId: Agent ID to resolve\n    /// - Returns: Resolved agent\n    /// - Throws: AgentServiceError if agent cannot be resolved\n    private func resolveAgent(byId agentId: UUID) async throws -> any Agent {\n        let allAgents = await registry.listAll()\n        \n        // Debug logging for agent lookup\n        await logAgentLookup(agentId: agentId, availableAgents: allAgents)\n        \n        // Get the agent from registry\n        // Note: Agent IDs may change on app restart, so we need to handle ID mismatches\n        var agent = await registry.getAgent(byId: agentId)\n        \n        // If agent not found by ID, this likely means agent IDs changed on app restart.\n        // In single-agent mode with exactly one selected agent, we can safely use the first\n        // available specialized agent (excluding Coordinator) as a fallback.\n        if agent == nil {\n            print(\"âš ï¸ Agent not found by ID: \\(agentId) - IDs may have changed on app restart\")\n            print(\"âš ï¸ Attempting fallback resolution for single-agent mode...\")\n            \n            // Get all available agents (excluding Coordinator for single-agent mode)\n            let availableAgents = allAgents.filter { $0.name != AgentName.coordinator }\n            \n            // For single-agent mode, if there's exactly one specialized agent available,\n            // use it as a fallback. This handles the common case where only one agent is enabled.\n            if availableAgents.count == 1, let fallbackAgent = availableAgents.first {\n                agent = fallbackAgent\n                print(\"âœ… Resolved to single available agent: \\(fallbackAgent.name)\")\n            } else if !availableAgents.isEmpty {\n                // Multiple agents available - try to match by checking which agent was likely intended\n                // Check if conversation config has hints about which agent to use\n                // For now, prefer WebSearchAgent if available (common use case)\n                agent = availableAgents.first { $0.capabilities.contains(.webSearch) }\n                if agent == nil {\n                    // Fallback to first available agent\n                    agent = availableAgents.first\n                }\n                if let resolvedAgent = agent {\n                    print(\"âš ï¸ Using fallback agent resolution: \\(resolvedAgent.name)\")\n                }\n            }\n        }\n        \n        guard let resolvedAgent = agent else {\n            print(\"âŒ Agent not found: \\(agentId) and could not resolve to any available agent\")\n            \n            // Debug logging for failed lookup\n            await logAgentLookupFailed(agentId: agentId, availableAgents: allAgents)\n            \n            throw AgentServiceError.agentNotFound(agentId)\n        }\n        \n        return resolvedAgent\n    }\n    \n    /// Log agent lookup for debugging\n    /// - Parameters:\n    ///   - agentId: Requested agent ID\n    ///   - availableAgents: Available agents\n    private func logAgentLookup(agentId: UUID, availableAgents: [any Agent]) async {\n        let agentInfo = availableAgents.map { [\"id\": $0.id.uuidString, \"name\": $0.name] }\n        await DebugLogger.shared.log(\n            location: \"AgentService.swift:processSingleAgentMessage\",\n            message: \"Looking up agent by ID\",\n            hypothesisId: \"A\",\n            data: [\n                \"requestedAgentId\": agentId.uuidString,\n                \"availableAgents\": agentInfo,\n                \"availableAgentIds\": availableAgents.map { $0.id.uuidString },\n                \"agentCount\": availableAgents.count\n            ]\n        )\n    }\n    \n    /// Log failed agent lookup for debugging\n    /// - Parameters:\n    ///   - agentId: Requested agent ID\n    ///   - availableAgents: Available agents\n    private func logAgentLookupFailed(agentId: UUID, availableAgents: [any Agent]) async {\n        await DebugLogger.shared.log(\n            location: \"AgentService.swift:processSingleAgentMessage\",\n            message: \"Agent lookup failed and resolution failed\",\n            hypothesisId: \"A\",\n            data: [\n                \"requestedAgentId\": agentId.uuidString,\n                \"availableAgentIds\": availableAgents.map { $0.id.uuidString },\n                \"availableAgentNames\": availableAgents.map { $0.name },\n                \"matchFound\": false\n            ]\n        )\n    }\n    \n    /// Log agent processing for debugging\n    /// - Parameters:\n    ///   - agent: The agent being processed\n    ///   - task: The task being processed\n    ///   - context: The context being used\n    private func logAgentProcessing(agent: any Agent, task: AgentTask, context: AgentContext) async {\n        await DebugLogger.shared.log(\n            location: \"AgentService.swift:processSingleAgentMessage\",\n            message: \"About to call agent.process()\",\n            hypothesisId: \"E\",\n            data: [\n                \"agentId\": agent.id.uuidString,\n                \"agentName\": agent.name,\n                \"taskDescription\": task.description,\n                \"taskParameters\": task.parameters,\n                \"contextHistoryCount\": context.conversationHistory.count\n            ]\n        )\n    }\n    \n    /// Log agent result for debugging\n    /// - Parameters:\n    ///   - agent: The agent that processed\n    ///   - result: The result\n    private func logAgentResult(agent: any Agent, result: AgentResult) async {\n        await DebugLogger.shared.log(\n            location: \"AgentService.swift:processSingleAgentMessage\",\n            message: \"Agent.process() completed\",\n            hypothesisId: \"E\",\n            data: [\n                \"agentId\": agent.id.uuidString,\n                \"agentName\": agent.name,\n                \"resultSuccess\": result.success,\n                \"resultContentLength\": result.content.count,\n                \"resultToolCallsCount\": result.toolCalls.count,\n                \"resultToolCalls\": result.toolCalls.map { [\"toolName\": $0.toolName, \"arguments\": $0.arguments] }\n            ]\n        )\n    }\n}\n\n/// Errors for agent service\n@available(macOS 26.0, iOS 26.0, *)\npublic enum AgentServiceError: Error, Sendable {\n    case noAgentConfiguration\n    case agentNotFound(UUID)\n    case invalidConfiguration\n    case executionFailed(String)\n}\n\n", "metadata": {"file_path": "AgentService.swift", "file_extension": ".swift", "file_name": "AgentService.swift", "file_size": 22743, "last_modified": 1766491017.63747}}
{"id": "9", "text": "//\n//  VisionAnalysisService.swift\n//  FoundationChatCore\n//\n//  Lightweight on-device image analysis (OCR + basic detections) for VisionAgent.\n//\n\nimport Foundation\nimport CoreGraphics\nimport ImageIO\nimport Vision\n\n@available(macOS 26.0, iOS 26.0, *)\npublic struct VisionAnalysisResult: Sendable {\n    public let fileName: String\n    public let fileSizeBytes: Int\n    public let pixelWidth: Int?\n    public let pixelHeight: Int?\n    public let classifications: [String]\n    public let recognizedText: String?\n    public let barcodePayloads: [String]\n    public let faceCount: Int\n    \n    public init(\n        fileName: String,\n        fileSizeBytes: Int,\n        pixelWidth: Int?,\n        pixelHeight: Int?,\n        classifications: [String],\n        recognizedText: String?,\n        barcodePayloads: [String],\n        faceCount: Int\n    ) {\n        self.fileName = fileName\n        self.fileSizeBytes = fileSizeBytes\n        self.pixelWidth = pixelWidth\n        self.pixelHeight = pixelHeight\n        self.classifications = classifications\n        self.recognizedText = recognizedText\n        self.barcodePayloads = barcodePayloads\n        self.faceCount = faceCount\n    }\n}\n\n@available(macOS 26.0, iOS 26.0, *)\npublic enum VisionAnalysisService {\n    /// Max image size to fully process with Vision requests (bytes).\n    /// Above this, we still return basic metadata but skip OCR/detections.\n    public static let maxProcessableImageBytes = 15 * 1024 * 1024\n    \n    public static func analyzeImage(atPath path: String) async -> VisionAnalysisResult {\n        await analyzeImage(url: URL(fileURLWithPath: path))\n    }\n    \n    public static func analyzeImage(url: URL) async -> VisionAnalysisResult {\n        await Task.detached(priority: .userInitiated) {\n            let fileName = url.lastPathComponent\n            let fileSizeBytes = (try? url.resourceValues(forKeys: [.fileSizeKey]).fileSize) ?? 0\n            \n            let (pixelWidth, pixelHeight) = imageDimensions(url: url)\n            \n            guard fileSizeBytes <= maxProcessableImageBytes else {\n                return VisionAnalysisResult(\n                    fileName: fileName,\n                    fileSizeBytes: fileSizeBytes,\n                    pixelWidth: pixelWidth,\n                    pixelHeight: pixelHeight,\n                    classifications: [],\n                    recognizedText: nil,\n                    barcodePayloads: [],\n                    faceCount: 0\n                )\n            }\n            \n            guard let cgImage = loadCGImage(url: url) else {\n                return VisionAnalysisResult(\n                    fileName: fileName,\n                    fileSizeBytes: fileSizeBytes,\n                    pixelWidth: pixelWidth,\n                    pixelHeight: pixelHeight,\n                    classifications: [],\n                    recognizedText: nil,\n                    barcodePayloads: [],\n                    faceCount: 0\n                )\n            }\n            \n            let handler = VNImageRequestHandler(cgImage: cgImage, options: [:])\n            \n            let textRequest = VNRecognizeTextRequest()\n            textRequest.recognitionLevel = .accurate\n            textRequest.usesLanguageCorrection = true\n            \n            let barcodeRequest = VNDetectBarcodesRequest()\n            let facesRequest = VNDetectFaceRectanglesRequest()\n            let classifyRequest = VNClassifyImageRequest()\n            \n            do {\n                try handler.perform([textRequest, barcodeRequest, facesRequest, classifyRequest])\n            } catch {\n                return VisionAnalysisResult(\n                    fileName: fileName,\n                    fileSizeBytes: fileSizeBytes,\n                    pixelWidth: pixelWidth,\n                    pixelHeight: pixelHeight,\n                    classifications: [],\n                    recognizedText: nil,\n                    barcodePayloads: [],\n                    faceCount: 0\n                )\n            }\n            \n            let recognizedText = textRequest.results?\n                .compactMap { $0.topCandidates(1).first?.string }\n                .joined(separator: \"\\n\")\n                .trimmingCharacters(in: .whitespacesAndNewlines)\n            \n            let barcodePayloads = barcodeRequest.results?\n                .compactMap { $0.payloadStringValue }\n                .filter { !$0.isEmpty } ?? []\n            \n            let faceCount = facesRequest.results?.count ?? 0\n            \n            let classifications = (classifyRequest.results ?? [])\n                .prefix(8)\n                .map { obs in\n                    let pct = Int((obs.confidence * 100.0).rounded())\n                    return \"\\(obs.identifier) (\\(pct)%)\"\n                }\n            \n            return VisionAnalysisResult(\n                fileName: fileName,\n                fileSizeBytes: fileSizeBytes,\n                pixelWidth: pixelWidth,\n                pixelHeight: pixelHeight,\n                classifications: classifications,\n                recognizedText: recognizedText?.isEmpty == true ? nil : recognizedText,\n                barcodePayloads: barcodePayloads,\n                faceCount: faceCount\n            )\n        }.value\n    }\n    \n    private static func imageDimensions(url: URL) -> (Int?, Int?) {\n        guard let source = CGImageSourceCreateWithURL(url as CFURL, nil),\n              let properties = CGImageSourceCopyPropertiesAtIndex(source, 0, nil) as? [CFString: Any]\n        else { return (nil, nil) }\n        \n        let width = properties[kCGImagePropertyPixelWidth] as? Int\n        let height = properties[kCGImagePropertyPixelHeight] as? Int\n        return (width, height)\n    }\n    \n    private static func loadCGImage(url: URL) -> CGImage? {\n        guard let source = CGImageSourceCreateWithURL(url as CFURL, nil) else { return nil }\n        return CGImageSourceCreateImageAtIndex(source, 0, nil)\n    }\n}\n", "metadata": {"file_path": "VisionAnalysisService.swift", "file_extension": ".swift", "file_name": "VisionAnalysisService.swift", "file_size": 5935, "last_modified": 1766432555.4998922}}
{"id": "10", "text": "//\n//  ContextAssemblyService.swift\n//  FoundationChatCore\n//\n//  Centralized context assembly for agent execution\n//\n\nimport Foundation\n\n/// Assembles agent context from conversation state, attachments, and optimization services.\n@available(macOS 26.0, iOS 26.0, *)\npublic actor ContextAssemblyService {\n    public static let shared = ContextAssemblyService()\n\n    private let tokenCounter = TokenCounter()\n\n    private init() {}\n\n    /// Build a context for a conversation.\n    public func assemble(\n        baseContext: AgentContext,\n        conversationId: UUID,\n        conversation: Conversation,\n        fileReferences: [String] = [],\n        currentMessage: String? = nil\n    ) async -> AgentContext {\n        var context = baseContext\n\n        context.fileReferences = collectFileReferences(from: conversation, additionalFiles: fileReferences)\n        context.metadata[\"conversationId\"] = conversationId.uuidString\n\n        if let lastMessage = conversation.messages.last {\n            let currentAttachments = lastMessage.attachments.map { $0.sandboxPath }\n            if !currentAttachments.isEmpty {\n                context.metadata[\"currentFileReferences\"] = currentAttachments.joined(separator: \"\\n\")\n            }\n        }\n\n        let useSVDB = UserDefaults.standard.object(forKey: UserDefaultsKey.useSVDBForContextOptimization) as? Bool ?? true\n        if useSVDB, let query = currentMessage, !conversation.messages.isEmpty {\n            do {\n                let contextOptimizer = ContextOptimizer()\n                let optimized = try await contextOptimizer.optimizeContextWithSVDB(\n                    messages: conversation.messages,\n                    query: query,\n                    conversationId: conversationId\n                )\n\n                context.conversationHistory = optimized.messages\n\n                let originalTokens = await tokenCounter.countTokens(conversation.messages)\n                let optimizedTokens = optimized.tokenUsage.messageTokens\n                if originalTokens > optimizedTokens {\n                    context.metadata[\"tokens_original_context\"] = String(originalTokens)\n                    context.metadata[\"tokens_optimized_context\"] = String(optimizedTokens)\n                    context.metadata[\"tokens_svdb_saved_context\"] = String(originalTokens - optimizedTokens)\n                }\n\n                print(\"ðŸ“Š AgentService: SVDB optimization - Original: \\(originalTokens) tokens, Optimized: \\(optimizedTokens) tokens\")\n            } catch {\n                print(\"âš ï¸ AgentService: SVDB optimization failed, using full history: \\(error.localizedDescription)\")\n                context.conversationHistory = conversation.messages\n            }\n        } else {\n            context.conversationHistory = conversation.messages\n        }\n\n        if !context.fileReferences.isEmpty, let query = currentMessage {\n            do {\n                let ragService = RAGService.shared\n                let topK = UserDefaults.standard.integer(forKey: \"ragTopK\") > 0\n                    ? UserDefaults.standard.integer(forKey: \"ragTopK\")\n                    : 5\n\n                var enhancedQuery = query\n                if let sectionMatch = query.range(of: #\"\\d+\\.\\d+\\.\\d+\"#, options: .regularExpression) {\n                    let sectionNumber = String(query[sectionMatch])\n                    enhancedQuery = \"section \\(sectionNumber) \\(query)\"\n                }\n\n                await DebugLogger.shared.log(\n                    location: \"ContextAssemblyService.swift:assemble\",\n                    message: \"Attempting RAG retrieval\",\n                    hypothesisId: \"B\",\n                    data: [\n                        \"originalQuery\": String(query.prefix(100)),\n                        \"enhancedQuery\": String(enhancedQuery.prefix(100)),\n                        \"fileReferencesCount\": context.fileReferences.count,\n                        \"topK\": topK,\n                        \"conversationId\": conversationId.uuidString\n                    ]\n                )\n\n                let chunks = try await ragService.searchRelevantChunks(\n                    query: enhancedQuery,\n                    fileIds: nil,\n                    conversationId: conversationId,\n                    topK: topK\n                )\n\n                context.ragChunks = chunks\n\n                await DebugLogger.shared.log(\n                    location: \"ContextAssemblyService.swift:assemble\",\n                    message: \"RAG retrieval completed\",\n                    hypothesisId: \"B\",\n                    data: [\n                        \"chunksRetrieved\": chunks.count,\n                        \"chunkPreviews\": chunks.prefix(3).map { String($0.content.prefix(100)) }\n                    ]\n                )\n            } catch {\n                await DebugLogger.shared.log(\n                    location: \"ContextAssemblyService.swift:assemble\",\n                    message: \"RAG retrieval failed\",\n                    hypothesisId: \"B\",\n                    data: [\"error\": error.localizedDescription]\n                )\n                print(\"âš ï¸ AgentService: RAG retrieval failed: \\(error.localizedDescription)\")\n            }\n        } else {\n            await DebugLogger.shared.log(\n                location: \"ContextAssemblyService.swift:assemble\",\n                message: \"Skipping RAG retrieval\",\n                hypothesisId: \"B\",\n                data: [\n                    \"hasFileReferences\": !context.fileReferences.isEmpty,\n                    \"hasCurrentMessage\": currentMessage != nil\n                ]\n            )\n        }\n\n        let ragChunksCount = context.ragChunks.count\n        let fileReferencesCount = context.fileReferences.count\n        let messageCount = context.conversationHistory.count\n        await DebugLogger.shared.log(\n            location: \"ContextAssemblyService.swift:assemble\",\n            message: \"Context assembly completed\",\n            hypothesisId: \"B\",\n            data: [\n                \"ragChunksCount\": ragChunksCount,\n                \"fileReferencesCount\": fileReferencesCount,\n                \"messageCount\": messageCount\n            ]\n        )\n\n        return context\n    }\n\n    private func collectFileReferences(\n        from conversation: Conversation,\n        additionalFiles: [String] = []\n    ) -> [String] {\n        var allFileReferences = additionalFiles\n\n        for message in conversation.messages.suffix(AppConstants.recentMessagesCount) {\n            for attachment in message.attachments {\n                if FileManager.default.fileExists(atPath: attachment.sandboxPath) {\n                    allFileReferences.append(attachment.sandboxPath)\n                }\n            }\n        }\n\n        var seen = Set<String>()\n        return allFileReferences.filter { seen.insert($0).inserted }\n    }\n}\n", "metadata": {"file_path": "ContextAssemblyService.swift", "file_extension": ".swift", "file_name": "ContextAssemblyService.swift", "file_size": 6832, "last_modified": 1766435870.632211}}
{"id": "11", "text": "//\n//  ToolUsageInference.swift\n//  FoundationChatCore\n//\n//  Fallback mechanism to infer tool usage from response content\n//\n\nimport Foundation\n\n/// Infers tool usage from response content when direct tracking fails\n@available(macOS 26.0, iOS 26.0, *)\npublic struct ToolUsageInference {\n    /// Infer which tools were used based on response content\n    /// - Parameters:\n    ///   - content: The model's response content\n    ///   - availableTools: List of available tool names\n    /// - Returns: Array of tool names that were likely used\n    public static func inferToolUsage(from content: String, availableTools: [String]) -> [String] {\n        var inferredTools: [String] = []\n        let contentLower = content.lowercased()\n        \n        // Check for DuckDuckGo usage\n        if availableTools.contains(\"duckduckgo_search\") {\n            let duckduckgoIndicators = [\n                \"duckduckgo\",\n                \"duckduckgo instant answers\",\n                \"duckduckgo api\",\n                \"couldn't find any information\",\n                \"couldn't find any current information\",\n                \"couldn't find any online information\",\n                \"does not have an instant answer\",\n                \"doesn't have an instant answer\",\n                \"instant answers api\"\n            ]\n            \n            for indicator in duckduckgoIndicators {\n                if contentLower.contains(indicator) {\n                    inferredTools.append(\"duckduckgo_search\")\n                    break\n                }\n            }\n        }\n        \n        // Add more tool inference logic here as needed\n        \n        return inferredTools\n    }\n}\n\n\n\n\n\n\n\n\n", "metadata": {"file_path": "ToolUsageInference.swift", "file_extension": ".swift", "file_name": "ToolUsageInference.swift", "file_size": 1668, "last_modified": 1766491017.4580834}}
{"id": "12", "text": "//\n//  ContextSummarizer.swift\n//  FoundationChatCore\n//\n//  Service for summarizing conversation history using Foundation Models\n//\n\nimport Foundation\nimport FoundationModels\n\n/// Service for summarizing conversation context\n@available(macOS 26.0, iOS 26.0, *)\npublic actor ContextSummarizer {\n    /// Model service for summarization (lazy initialization to avoid blocking)\n    private var _modelService: ModelService?\n    private var modelService: ModelService {\n        get async {\n            if _modelService == nil {\n                // Create ModelService in a detached task to avoid blocking\n                _modelService = await Task.detached(priority: .userInitiated) {\n                    ModelService()\n                }.value\n            }\n            return _modelService!\n        }\n    }\n    \n    /// Token counter for estimating costs\n    private let tokenCounter = TokenCounter()\n    \n    public init() {\n        // ModelService will be created lazily when first accessed\n    }\n    \n    /// Summarize a conversation in 2-3 sentences\n    /// - Parameter messages: Messages to summarize\n    /// - Returns: Summary string\n    public func summarize(_ messages: [Message]) async throws -> String {\n        guard !messages.isEmpty else {\n            return \"\"\n        }\n        \n        // Format messages for summarization\n        let conversationText = formatMessagesForSummarization(messages)\n        \n        // Create compact summarization prompt\n        let prompt = \"\"\"\n        Summarize the following conversation in 2-3 sentences, focusing on key questions, answers, and decisions made.\n        \n        Conversation:\n        \\(conversationText)\n        \"\"\"\n        \n        // Use model service to generate summary\n        let service = await modelService\n        let response = try await service.respond(to: prompt)\n        return response.content.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n    \n    /// Summarize messages with different levels of detail\n    /// - Parameters:\n    ///   - messages: Messages to summarize\n    ///   - level: Summarization level (light, medium, heavy)\n    /// - Returns: Summary string\n    public func summarize(_ messages: [Message], level: SummarizationLevel) async throws -> String {\n        guard !messages.isEmpty else {\n            return \"\"\n        }\n        \n        let conversationText = formatMessagesForSummarization(messages)\n        \n        let instruction: String\n        switch level {\n        case .light:\n            instruction = \"Summarize the key points in 1-2 sentences.\"\n        case .medium:\n            instruction = \"Summarize the main topics and outcomes in 2-3 sentences.\"\n        case .heavy:\n            instruction = \"Provide a concise summary of the essential information in 3-4 sentences, focusing only on the most important facts and decisions.\"\n        }\n        \n        let prompt = \"\"\"\n        \\(instruction)\n        \n        Conversation:\n        \\(conversationText)\n        \"\"\"\n        \n        let service = await modelService\n        let response = try await service.respond(to: prompt)\n        return response.content.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n    \n    /// Summarize a single message or text block\n    /// - Parameter text: Text to summarize\n    /// - Returns: Summary string\n    public func summarize(_ text: String) async throws -> String {\n        guard !text.isEmpty else {\n            return \"\"\n        }\n        \n        let prompt = \"\"\"\n        Summarize the following text in 2-3 sentences, focusing on key information:\n        \n        \\(text)\n        \"\"\"\n        \n        let service = await modelService\n        let response = try await service.respond(to: prompt)\n        return response.content.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n    \n    /// Format messages for summarization\n    /// - Parameter messages: Messages to format\n    /// - Returns: Formatted string\n    private func formatMessagesForSummarization(_ messages: [Message]) -> String {\n        return messages.map { message in\n            let role = message.role.rawValue.capitalized\n            let content = message.content\n            return \"\\(role): \\(content)\"\n        }.joined(separator: \"\\n\\n\")\n    }\n}\n\n/// Summarization level\n@available(macOS 26.0, iOS 26.0, *)\npublic enum SummarizationLevel: Sendable {\n    case light    // 1-2 sentences\n    case medium   // 2-3 sentences\n    case heavy    // 3-4 sentences, very concise\n}\n\n\n\n", "metadata": {"file_path": "ContextSummarizer.swift", "file_extension": ".swift", "file_name": "ContextSummarizer.swift", "file_size": 4465, "last_modified": 1766491017.4832819}}
{"id": "13", "text": "//\n//  WebSearchService.swift\n//  FoundationChatCore\n//\n//  Service for orchestrating web searches in isolated conversations\n//\n\nimport Foundation\nimport FoundationModels\n\n/// Service for managing web search operations\n@available(macOS 26.0, iOS 26.0, *)\npublic actor WebSearchService {\n    /// Model service for search conversations (lazy initialization to avoid blocking)\n    private var _modelService: ModelService?\n    private var modelService: ModelService {\n        get async {\n            if _modelService == nil {\n                // Create ModelService in a detached task to avoid blocking\n                _modelService = await Task.detached(priority: .userInitiated) {\n                    ModelService()\n                }.value\n            }\n            return _modelService!\n        }\n    }\n    \n    /// Context summarizer for query summarization\n    private let summarizer = ContextSummarizer()\n    \n    /// Web search tool\n    private let webSearchTool = WebSearchFoundationTool()\n    \n    public init() {\n        // ModelService will be created lazily when first accessed\n    }\n    \n    /// Perform a web search in an isolated conversation\n    /// - Parameters:\n    ///   - query: Original search query\n    ///   - context: Optional context from main conversation\n    /// - Returns: Formatted search results\n    public func performSearch(query: String, context: String? = nil) async throws -> String {\n        // Summarize query and context if provided\n        let searchQuery = try await summarizeQuery(query: query, context: context)\n        \n        // Register web search tool\n        let service = await modelService\n        await service.updateTools([webSearchTool])\n        \n        // Perform search using the tool\n        // The model will automatically use the tool when it sees the search request\n        let searchPrompt = \"\"\"\n        Search the web for: \\(searchQuery)\n        Use the web_search tool to find current information.\n        \"\"\"\n        \n        let response = try await service.respond(to: searchPrompt)\n        \n        // Return the response content (which should include tool results)\n        return response.content\n    }\n    \n    /// Summarize query and context for web search\n    private func summarizeQuery(query: String, context: String?) async throws -> String {\n        if let context = context, !context.isEmpty {\n            // Combine query and context, then summarize\n            let combined = \"\"\"\n            User query: \\(query)\n            \n            Conversation context: \\(context)\n            \"\"\"\n            return try await summarizer.summarize(combined)\n        } else {\n            // Just return the query, possibly normalized\n            return normalizeQuery(query)\n        }\n    }\n    \n    /// Normalize query for better search results\n    private func normalizeQuery(_ query: String) -> String {\n        var normalized = query.trimmingCharacters(in: .whitespacesAndNewlines)\n        \n        // Remove common question prefixes\n        let questionPrefixes = [\n            \"what is \", \"what are \", \"who is \", \"where is \",\n            \"when is \", \"why is \", \"how is \", \"search for \",\n            \"look up \", \"find \", \"search \"\n        ]\n        \n        let lowercased = normalized.lowercased()\n        for prefix in questionPrefixes {\n            if lowercased.hasPrefix(prefix) {\n                normalized = String(normalized.dropFirst(prefix.count))\n                break\n            }\n        }\n        \n        return normalized.trimmingCharacters(in: .whitespacesAndNewlines)\n    }\n}\n\n\n\n", "metadata": {"file_path": "WebSearchService.swift", "file_extension": ".swift", "file_name": "WebSearchService.swift", "file_size": 3564, "last_modified": 1766491017.4832108}}
{"id": "14", "text": "//\n//  TextChunker.swift\n//  FoundationChatCore\n//\n//  Service for intelligent text chunking with overlap\n//\n\nimport Foundation\n\n/// Service for splitting text into chunks with intelligent boundary detection\n@available(macOS 26.0, iOS 26.0, *)\npublic struct TextChunker {\n    /// Default chunk size in characters\n    public static let defaultChunkSize: Int = 1000\n    \n    /// Default overlap in characters (20% of chunk size)\n    public static let defaultOverlap: Int = 200\n    \n    /// Chunk text into smaller pieces with overlap\n    /// - Parameters:\n    ///   - text: The text to chunk\n    ///   - chunkSize: Maximum characters per chunk (default: 1000)\n    ///   - overlap: Number of characters to overlap between chunks (default: 200)\n    /// - Returns: Array of text chunks\n    public static func chunk(\n        text: String,\n        chunkSize: Int = defaultChunkSize,\n        overlap: Int = defaultOverlap\n    ) -> [String] {\n        guard !text.isEmpty else { return [] }\n        guard text.count > chunkSize else { return [text] }\n        \n        var chunks: [String] = []\n        var startIndex = text.startIndex\n        var chunkIndex = 0\n        \n        while startIndex < text.endIndex {\n            // Calculate end position for this chunk\n            let endPosition = text.index(startIndex, offsetBy: chunkSize, limitedBy: text.endIndex) ?? text.endIndex\n            \n            // Try to find a good breaking point (sentence or paragraph boundary)\n            let chunkEnd = findBestBreakPoint(\n                text: text,\n                start: startIndex,\n                preferredEnd: endPosition,\n                maxEnd: min(text.index(endPosition, offsetBy: overlap, limitedBy: text.endIndex) ?? text.endIndex, text.endIndex)\n            )\n            \n            // Extract chunk\n            let chunk = String(text[startIndex..<chunkEnd])\n            chunks.append(chunk)\n            \n            // Move start position for next chunk (with overlap)\n            if chunkEnd < text.endIndex {\n                let overlapStart = text.index(chunkEnd, offsetBy: -overlap, limitedBy: startIndex) ?? startIndex\n                startIndex = max(overlapStart, text.index(startIndex, offsetBy: chunkSize - overlap, limitedBy: text.endIndex) ?? text.endIndex)\n            } else {\n                break\n            }\n            \n            chunkIndex += 1\n        }\n        \n        return chunks\n    }\n    \n    /// Find the best break point for chunking (prefer sentence/paragraph boundaries)\n    /// - Parameters:\n    ///   - text: The full text\n    ///   - start: Start index of current chunk\n    ///   - preferredEnd: Preferred end position (chunk size)\n    ///   - maxEnd: Maximum end position (chunk size + overlap)\n    /// - Returns: Best break point index\n    private static func findBestBreakPoint(\n        text: String,\n        start: String.Index,\n        preferredEnd: String.Index,\n        maxEnd: String.Index\n    ) -> String.Index {\n        // If we're at the end, return it\n        guard preferredEnd < text.endIndex else {\n            return text.endIndex\n        }\n        \n        // Look for paragraph break (double newline) first\n        if let paragraphBreak = findLastOccurrence(\n            of: \"\\n\\n\",\n            in: text,\n            range: start..<maxEnd\n        ) {\n            return text.index(paragraphBreak, offsetBy: 2)\n        }\n        \n        // Look for sentence endings (., !, ?) followed by space or newline\n        let sentenceEndings = [\". \", \"! \", \"? \", \".\\n\", \"!\\n\", \"?\\n\"]\n        for ending in sentenceEndings {\n            if let sentenceBreak = findLastOccurrence(\n                of: ending,\n                in: text,\n                range: start..<maxEnd\n            ) {\n                return text.index(sentenceBreak, offsetBy: ending.count)\n            }\n        }\n        \n        // Look for single newline\n        if let newlineBreak = findLastOccurrence(\n            of: \"\\n\",\n            in: text,\n            range: start..<maxEnd\n        ) {\n            return text.index(newlineBreak, offsetBy: 1)\n        }\n        \n        // Look for space\n        if let spaceBreak = findLastOccurrence(\n            of: \" \",\n            in: text,\n            range: start..<maxEnd\n        ) {\n            return text.index(spaceBreak, offsetBy: 1)\n        }\n        \n        // Fallback: use preferred end or max end\n        return min(preferredEnd, maxEnd)\n    }\n    \n    /// Find the last occurrence of a substring in a range\n    /// - Parameters:\n    ///   - substring: Substring to find\n    ///   - text: Text to search in\n    ///   - range: Range to search within\n    /// - Returns: Index of last occurrence, or nil if not found\n    private static func findLastOccurrence(\n        of substring: String,\n        in text: String,\n        range: Range<String.Index>\n    ) -> String.Index? {\n        var searchRange = range\n        var lastFound: String.Index?\n        \n        while searchRange.lowerBound < searchRange.upperBound {\n            if let found = text.range(of: substring, range: searchRange)?.lowerBound {\n                lastFound = found\n                // Continue searching after this occurrence\n                searchRange = text.index(found, offsetBy: substring.count)..<searchRange.upperBound\n            } else {\n                break\n            }\n        }\n        \n        return lastFound\n    }\n    \n    /// Chunk code/text with special handling for code blocks\n    /// - Parameters:\n    ///   - text: The text to chunk\n    ///   - chunkSize: Maximum characters per chunk\n    ///   - overlap: Overlap between chunks\n    ///   - isCode: Whether this is code (preserves structure better)\n    /// - Returns: Array of text chunks\n    public static func chunkCode(\n        text: String,\n        chunkSize: Int = defaultChunkSize,\n        overlap: Int = defaultOverlap,\n        isCode: Bool = false\n    ) -> [String] {\n        if isCode {\n            // For code, prefer breaking at function/class boundaries\n            // Look for common patterns: function definitions, class definitions, etc.\n            let codePatterns = [\n                \"\\nfunc \", \"\\nclass \", \"\\nstruct \", \"\\nenum \", \"\\nextension \",\n                \"\\nprivate \", \"\\npublic \", \"\\ninternal \", \"\\nfileprivate \",\n                \"\\n    func \", \"\\n    class \", \"\\n    struct \"\n            ]\n            \n            var chunks: [String] = []\n            var startIndex = text.startIndex\n            var chunkIndex = 0\n            \n            while startIndex < text.endIndex {\n                let endPosition = text.index(startIndex, offsetBy: chunkSize, limitedBy: text.endIndex) ?? text.endIndex\n                let maxEnd = min(text.index(endPosition, offsetBy: overlap, limitedBy: text.endIndex) ?? text.endIndex, text.endIndex)\n                \n                // Look for code structure boundaries\n                var bestBreak: String.Index? = nil\n                for pattern in codePatterns {\n                    if let breakPoint = findLastOccurrence(\n                        of: pattern,\n                        in: text,\n                        range: startIndex..<maxEnd\n                    ) {\n                        if bestBreak == nil || breakPoint > (bestBreak ?? text.startIndex) {\n                            bestBreak = breakPoint\n                        }\n                    }\n                }\n                \n                let chunkEnd = bestBreak ?? min(endPosition, maxEnd)\n                let chunk = String(text[startIndex..<chunkEnd])\n                chunks.append(chunk)\n                \n                if chunkEnd < text.endIndex {\n                    let overlapStart = text.index(chunkEnd, offsetBy: -overlap, limitedBy: startIndex) ?? startIndex\n                    startIndex = max(overlapStart, text.index(startIndex, offsetBy: chunkSize - overlap, limitedBy: text.endIndex) ?? text.endIndex)\n                } else {\n                    break\n                }\n                \n                chunkIndex += 1\n            }\n            \n            return chunks\n        } else {\n            // Use regular chunking for non-code\n            return chunk(text: text, chunkSize: chunkSize, overlap: overlap)\n        }\n    }\n}\n\n\n", "metadata": {"file_path": "TextChunker.swift", "file_extension": ".swift", "file_name": "TextChunker.swift", "file_size": 8230, "last_modified": 1766491017.4914465}}
{"id": "15", "text": "//\n//  ModelService.swift\n//  FoundationChatCore\n//\n//  Service for interacting with Apple's SystemLanguageModel\n//\n\nimport Foundation\nimport FoundationModels\nimport UniformTypeIdentifiers\n\n/// Availability status of the language model\n@available(macOS 26.0, iOS 26.0, *)\npublic enum ModelAvailability: Sendable {\n    case available\n    case unavailable(UnavailabilityReason)\n    \n    public enum UnavailabilityReason: Sendable {\n        case deviceNotEligible\n        case appleIntelligenceNotEnabled\n        case modelNotReady\n        case other(String)\n    }\n}\n\n/// Response from the model with streaming support\n@available(macOS 26.0, iOS 26.0, *)\npublic struct ModelResponse: Sendable {\n    /// Full content of the response\n    public let content: String\n    \n    /// Tool calls made during generation (if any)\n    public let toolCalls: [ToolCall]\n    \n    public init(content: String, toolCalls: [ToolCall] = []) {\n        self.content = content\n        self.toolCalls = toolCalls\n    }\n}\n\n/// Service for managing interactions with Apple's SystemLanguageModel\n@available(macOS 26.0, iOS 26.0, *)\npublic actor ModelService {\n    /// The underlying language model\n    private let model: SystemLanguageModel\n    \n    /// Tool call tracker\n    private let tracker = ToolCallTracker()\n    \n    /// Available tools (for fallback inference)\n    private var tools: [any Tool] = []\n    \n    /// Sessions per conversation ID (for contextual conversations)\n    private var conversationSessions: [UUID: LanguageModelSession] = [:]\n    \n    /// Session IDs per conversation (for tracking tool calls in contextual conversations)\n    private var conversationSessionIds: [UUID: String] = [:]\n    \n    /// Context optimizer for managing token limits\n    private let contextOptimizer = ContextOptimizer()\n    \n    /// Initialize the model service\n    public init() {\n        print(\"ðŸ¤– ModelService init() starting...\")\n        print(\"ðŸ¤– About to access SystemLanguageModel.default...\")\n        self.model = SystemLanguageModel.default\n        print(\"âœ… ModelService init() complete - SystemLanguageModel.default accessed\")\n    }\n    \n    /// Check if the model is available\n    public func checkAvailability() -> ModelAvailability {\n        switch model.availability {\n        case .available:\n            return .available\n        case .unavailable(.deviceNotEligible):\n            return .unavailable(.deviceNotEligible)\n        case .unavailable(.appleIntelligenceNotEnabled):\n            return .unavailable(.appleIntelligenceNotEnabled)\n        case .unavailable(.modelNotReady):\n            return .unavailable(.modelNotReady)\n        case .unavailable(let reason):\n            return .unavailable(.other(String(describing: reason)))\n        @unknown default:\n            return .unavailable(.other(\"Unknown availability status\"))\n        }\n    }\n    \n    /// Update the tools available to the model\n    /// - Parameter tools: Array of tools to make available\n    /// Note: Tools are stored and will be used when creating request-scoped sessions.\n    /// Session creation happens at request time, not during tool configuration.\n    public func updateTools(_ tools: [any Tool]) {\n        // Store tools for use in request-scoped sessions\n        self.tools = tools\n        print(\"[DEBUG ModelService] updateTools called with \\(tools.count) tools\")\n    }\n    \n    /// Send a message with image attachments and get a response\n    /// - Parameters:\n    ///   - message: The user's message text\n    ///   - imagePaths: Array of image file paths to include\n    /// - Returns: The model's response\n    /// - Throws: Error if model is unavailable or request fails\n    /// Note: This method currently uses on-device Vision analysis (OCR + basic detections)\n    /// and passes the extracted signals to the model as text.\n    /// This method creates a request-scoped session for each call to support parallel execution.\n    public func respond(to message: String, withImages imagePaths: [String]) async throws -> ModelResponse {\n        let existingPaths = imagePaths.filter { FileManager.default.fileExists(atPath: $0) }\n        var imageBlocks: [String] = []\n        \n        for imagePath in existingPaths {\n            let analysis = await VisionAnalysisService.analyzeImage(atPath: imagePath)\n            var block = \"Image: \\(analysis.fileName)\\nFile size: \\(analysis.fileSizeBytes) bytes\"\n            if let w = analysis.pixelWidth, let h = analysis.pixelHeight {\n                block += \"\\nDimensions: \\(w)x\\(h) px\"\n            }\n            if !analysis.classifications.isEmpty {\n                block += \"\\nLikely contents: \\(analysis.classifications.joined(separator: \", \"))\"\n            }\n            block += \"\\nFaces detected: \\(analysis.faceCount)\"\n            if !analysis.barcodePayloads.isEmpty {\n                block += \"\\nBarcodes: \\(analysis.barcodePayloads.joined(separator: \", \"))\"\n            }\n            if let text = analysis.recognizedText, !text.isEmpty {\n                let maxChars = 6000\n                let clipped = text.count > maxChars ? String(text.prefix(maxChars)) + \"\\nâ€¦(truncated)\" : text\n                block += \"\\n\\nOCR text:\\n\\(clipped)\"\n            }\n            imageBlocks.append(block)\n        }\n        \n        var prompt = message.isEmpty ? \"Please help with the attached image(s).\" : message\n        if !imageBlocks.isEmpty {\n            prompt += \"\\n\\nAttached image analysis signals (OCR + detections; no direct pixel access):\\n\\n\"\n            prompt += imageBlocks.joined(separator: \"\\n\\n---\\n\\n\")\n        } else if !imagePaths.isEmpty {\n            prompt += \"\\n\\n(No readable image files were found at the provided paths.)\"\n        }\n        \n        return try await respond(to: prompt)\n    }\n    \n    /// Send a message and get a response (non-streaming)\n    /// - Parameter message: The user's message\n    /// - Returns: The model's response\n    /// - Throws: Error if model is unavailable or request fails\n    /// Note: This method creates a request-scoped session for each call to support parallel execution.\n    public func respond(to message: String) async throws -> ModelResponse {\n        // Create a request-scoped session for this request\n        // This ensures thread safety when multiple requests run in parallel\n        let requestSessionId = UUID().uuidString\n        let requestSession = createRequestSession(sessionId: requestSessionId)\n        \n        print(\"[DEBUG ModelService] Created request-scoped session (sessionId: \\(requestSessionId))\")\n        \n        // Clear previous tool calls for this session before making the request\n        await tracker.clearSession(requestSessionId)\n        \n        print(\"[DEBUG ModelService] Calling session.respond()...\")\n        let response = try await requestSession.respond(to: message)\n        print(\"[DEBUG ModelService] session.respond() completed\")\n        \n        // Extract tool calls from tracker using the session ID\n        var toolNames = await tracker.getUniqueToolNames(for: requestSessionId)\n        print(\"[DEBUG ModelService] Extracted \\(toolNames.count) tool names from tracker: \\(toolNames)\")\n        \n        // Fallback: If no tools were tracked but we have tools available, try to infer from content\n        if toolNames.isEmpty {\n            let availableToolNames = tools.map { $0.name }\n            let inferred = ToolUsageInference.inferToolUsage(from: response.content, availableTools: availableToolNames)\n            if !inferred.isEmpty {\n                print(\"[DEBUG ModelService] No tools tracked, but inferred \\(inferred.count) tools from content: \\(inferred)\")\n                toolNames = inferred\n            }\n        }\n        \n        let toolCalls = toolNames.map { toolName in\n            ToolCall(toolName: toolName, arguments: \"\")\n        }\n        \n        print(\"[DEBUG ModelService] Returning ModelResponse with \\(toolCalls.count) tool calls\")\n        \n        return ModelResponse(content: response.content, toolCalls: toolCalls)\n    }\n    \n    /// Send a message with conversation context\n    /// - Parameters:\n    ///   - message: The user's message\n    ///   - conversationId: The conversation ID for session management\n    ///   - previousMessages: Previous messages in the conversation (for contextual mode)\n    ///   - useContextual: Whether to use contextual conversations (reuse session)\n    /// - Returns: The model's response\n    /// - Throws: Error if model is unavailable or request fails\n    /// Note: This method manages conversation-scoped sessions for contextual conversations.\n    public func respond(\n        to message: String,\n        conversationId: UUID,\n        previousMessages: [Message],\n        useContextual: Bool\n    ) async throws -> ModelResponse {\n        let session: LanguageModelSession\n        let sessionId: String\n        \n        if useContextual {\n            // Use or create session for this conversation\n            if let existingSession = conversationSessions[conversationId],\n               let existingSessionId = conversationSessionIds[conversationId] {\n                session = existingSession\n                sessionId = existingSessionId\n                print(\"[DEBUG ModelService] Reusing session for conversation \\(conversationId)\")\n            } else {\n                // Create new session from transcript if we have previous messages\n                sessionId = UUID().uuidString\n                conversationSessionIds[conversationId] = sessionId\n                \n                if !previousMessages.isEmpty {\n                    // Optimize context before creating transcript\n                    let optimized = try await contextOptimizer.optimizeContext(\n                        messages: previousMessages,\n                        systemPrompt: nil,\n                        tools: tools\n                    )\n                    \n                    print(\"[DEBUG ModelService] Context optimized: \\(optimized.messagesTruncated) messages truncated, \\(optimized.tokenUsage.totalTokens) tokens used\")\n                    \n                    let transcript = createTranscript(from: optimized.messages)\n                    let trackedTools = createTrackedTools(for: sessionId)\n                    session = LanguageModelSession(tools: trackedTools, transcript: transcript)\n                    conversationSessions[conversationId] = session\n                    print(\"[DEBUG ModelService] Created new session from transcript for conversation \\(conversationId)\")\n                } else {\n                    // No previous messages, create fresh session\n                    let trackedTools = createTrackedTools(for: sessionId)\n                    session = LanguageModelSession(tools: trackedTools)\n                    conversationSessions[conversationId] = session\n                    print(\"[DEBUG ModelService] Created new session for conversation \\(conversationId)\")\n                }\n            }\n        } else {\n            // Non-contextual: create new session each time (request-scoped)\n            sessionId = UUID().uuidString\n            session = createRequestSession(sessionId: sessionId)\n            print(\"[DEBUG ModelService] Created new session (non-contextual mode)\")\n        }\n        \n        // Clear previous tool calls for this session before making the request\n        await tracker.clearSession(sessionId)\n        \n        // Make the request\n        let response = try await session.respond(to: message)\n        \n        // Update session in storage if contextual\n        if useContextual {\n            conversationSessions[conversationId] = session\n        }\n        \n        // Extract tool calls from tracker\n        var toolNames = await tracker.getUniqueToolNames(for: sessionId)\n        \n        // Fallback: If no tools were tracked but we have tools available, try to infer from content\n        if toolNames.isEmpty {\n            let availableToolNames = tools.map { $0.name }\n            let inferred = ToolUsageInference.inferToolUsage(from: response.content, availableTools: availableToolNames)\n            if !inferred.isEmpty {\n                toolNames = inferred\n            }\n        }\n        \n        let toolCalls = toolNames.map { toolName in\n            ToolCall(toolName: toolName, arguments: \"\")\n        }\n        \n        return ModelResponse(content: response.content, toolCalls: toolCalls)\n    }\n    \n    /// Clear session for a conversation\n    /// - Parameter conversationId: The conversation ID\n    public func clearSession(for conversationId: UUID) {\n        conversationSessions.removeValue(forKey: conversationId)\n        conversationSessionIds.removeValue(forKey: conversationId)\n        print(\"[DEBUG ModelService] Cleared session for conversation \\(conversationId)\")\n    }\n    \n    // MARK: - Private Helpers\n    \n    /// Create a request-scoped session with tracked tools\n    /// - Parameter sessionId: Session ID for tool tracking\n    /// - Returns: A new LanguageModelSession configured with tracked tools\n    private func createRequestSession(sessionId: String) -> LanguageModelSession {\n        let trackedTools = createTrackedTools(for: sessionId)\n        return LanguageModelSession(tools: trackedTools)\n    }\n    \n    /// Create tracked tools for a given session ID\n    /// - Parameter sessionId: Session ID for tool tracking\n    /// - Returns: Array of tools with tracking wrappers where applicable\n    private func createTrackedTools(for sessionId: String) -> [any Tool] {\n        var trackedTools: [any Tool] = []\n        for tool in tools {\n            if let ddgTool = tool as? DuckDuckGoFoundationTool {\n                let tracked = TrackedTool(wrapping: ddgTool, sessionId: sessionId, tracker: tracker)\n                trackedTools.append(tracked)\n            } else if let webSearchTool = tool as? WebSearchFoundationTool {\n                // Track web search tool\n                let tracked = TrackedTool(wrapping: webSearchTool, sessionId: sessionId, tracker: tracker)\n                trackedTools.append(tracked)\n                print(\"[DEBUG ModelService] Wrapping WebSearchFoundationTool with tracking\")\n            } else if let serpapiTool = tool as? SerpAPIFoundationTool {\n                // Track SerpAPI tool\n                let tracked = TrackedTool(wrapping: serpapiTool, sessionId: sessionId, tracker: tracker)\n                trackedTools.append(tracked)\n            } else {\n                trackedTools.append(tool)\n            }\n        }\n        return trackedTools\n    }\n    \n    private func createTranscript(from messages: [Message]) -> Transcript {\n        var entries: [Transcript.Entry] = []\n        \n        for message in messages {\n            switch message.role {\n            case .user:\n                // Create segments for this prompt\n                var segments: [Transcript.Segment] = []\n                \n                // Add text segment if there's content\n                if !message.content.isEmpty {\n                    let textSegment = Transcript.TextSegment(content: message.content)\n                    segments.append(.text(textSegment))\n                }\n                \n                // Add image segments for any image attachments\n                // Note: Image segment support will be added when FoundationModels API is confirmed\n                // For now, we include image references in the text content\n                var imageReferences: [String] = []\n                for attachment in message.attachments {\n                    // Check if attachment is an image\n                    if let mimeType = attachment.mimeType,\n                       let utType = UTType(mimeType: mimeType),\n                       utType.conforms(to: UTType.image) {\n                        imageReferences.append(attachment.originalName)\n                    }\n                }\n                \n                // If we have image references but no text content, add them to the text\n                if !imageReferences.isEmpty && message.content.isEmpty {\n                    let imageText = \"Images attached: \\(imageReferences.joined(separator: \", \"))\"\n                    let textSegment = Transcript.TextSegment(content: imageText)\n                    segments.append(.text(textSegment))\n                } else if !imageReferences.isEmpty {\n                    // Append image references to existing content\n                    let combinedContent = \"\\(message.content)\\n\\n[Images: \\(imageReferences.joined(separator: \", \"))]\"\n                    // Replace the text segment with the combined content\n                    segments.removeAll { if case .text = $0 { return true } else { return false } }\n                    let textSegment = Transcript.TextSegment(content: combinedContent)\n                    segments.append(.text(textSegment))\n                }\n                \n                // If no segments were created, add an empty text segment\n                if segments.isEmpty {\n                    let textSegment = Transcript.TextSegment(content: message.content.isEmpty ? \"\" : message.content)\n                    segments.append(.text(textSegment))\n                }\n                \n                let prompt = Transcript.Prompt(segments: segments)\n                entries.append(.prompt(prompt))\n            case .assistant:\n                // Create a Transcript.Response with text segment\n                let textSegment = Transcript.TextSegment(content: message.content)\n                let response = Transcript.Response(assetIDs: [], segments: [.text(textSegment)])\n                entries.append(.response(response))\n            case .system:\n                // System messages are treated as prompts\n                let textSegment = Transcript.TextSegment(content: message.content)\n                let prompt = Transcript.Prompt(segments: [.text(textSegment)])\n                entries.append(.prompt(prompt))\n            }\n        }\n        \n        return Transcript(entries: entries)\n    }\n    \n    \n    /// Send a message and stream the response\n    /// - Parameter message: The user's message\n    /// - Returns: Async sequence of response chunks\n    /// - Throws: Error if model is unavailable or request fails\n    /// Note: Streaming implementation will be added once the FoundationModels API is confirmed\n    public func streamResponse(to message: String) async throws -> AsyncThrowingStream<String, Error> {\n        // For now, return the full response as a single chunk\n        // TODO: Implement proper streaming when FoundationModels streaming API is available\n        let response = try await respond(to: message)\n        return AsyncThrowingStream { continuation in\n            continuation.yield(response.content)\n            continuation.finish()\n        }\n    }\n    \n    /// Get a user-friendly error message for unavailability\n    /// - Parameter availability: The availability status\n    /// - Returns: Human-readable error message\n    public static func errorMessage(for availability: ModelAvailability) -> String {\n        switch availability {\n        case .available:\n            return \"\"\n        case .unavailable(.deviceNotEligible):\n            return \"This device doesn't support Apple Intelligence.\"\n        case .unavailable(.appleIntelligenceNotEnabled):\n            return \"Apple Intelligence is not enabled. Please enable it in Settings.\"\n        case .unavailable(.modelNotReady):\n            return \"Model is not ready. It may be downloading or the system is busy.\"\n        case .unavailable(.other(let reason)):\n            return \"Model unavailable: \\(reason)\"\n        }\n    }\n}\n", "metadata": {"file_path": "ModelService.swift", "file_extension": ".swift", "file_name": "ModelService.swift", "file_size": 19584, "last_modified": 1766491017.6373465}}
